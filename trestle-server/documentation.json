{
    "pipes": [
        {
            "name": "ArraySortPipe",
            "id": "pipe-ArraySortPipe-3fb6aba8db87cd7af43836f796892172",
            "file": "src/main/webapp/src/app/shared/pipes/array-sort.pipe.ts",
            "type": "pipe",
            "description": "",
            "properties": [],
            "methods": [
                {
                    "name": "sortFn",
                    "args": [
                        {
                            "name": "a",
                            "type": "any"
                        },
                        {
                            "name": "b",
                            "type": "any"
                        },
                        {
                            "name": "field",
                            "type": "string",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 18,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "a",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "b",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "field",
                            "type": "string",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "transform",
                    "args": [
                        {
                            "name": "values",
                            "type": "any[]"
                        },
                        {
                            "name": "field",
                            "type": "string",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any[]",
                    "typeParameters": [],
                    "line": 13,
                    "description": "<p>Sorts a given input array either based on the element value, or an optional field</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 262,
                                "end": 268,
                                "flags": 0,
                                "escapedText": "values"
                            },
                            "type": "any[]",
                            "tagName": {
                                "pos": 248,
                                "end": 253,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Array of input values to sort</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 254,
                                "end": 261,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 255,
                                    "end": 260,
                                    "flags": 2097152,
                                    "kind": 166,
                                    "elementType": {
                                        "pos": 255,
                                        "end": 258,
                                        "flags": 2097152,
                                        "kind": 119
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 324,
                                "end": 329,
                                "flags": 0,
                                "escapedText": "field"
                            },
                            "type": "string",
                            "optional": true,
                            "tagName": {
                                "pos": 309,
                                "end": 314,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Optional field to use in sort function</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 315,
                                "end": 323,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 316,
                                    "end": 322,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 379,
                                "end": 386,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>Sorted array</li>\n</ul>\n",
                            "returnType": "[]"
                        }
                    ]
                }
            ],
            "ngname": "ArraySort",
            "sourceCode": "import { Pipe, PipeTransform } from \"@angular/core\";\n\n@Pipe({name: \"ArraySort\"})\nexport class ArraySortPipe implements PipeTransform {\n\n    /**\n     * Sorts a given input array either based on the element value, or an optional field\n     *\n     * @param {any[]} values - Array of input values to sort\n     * @param {string} field - Optional field to use in sort function\n     * @returns {any[]} - Sorted array\n     */\n    public transform(values: any[], field?: string): any[] {\n        return values.sort((a, b) => this.sortFn(a, b, field));\n    }\n\n\n    private sortFn(a: any, b: any, field?: string): number {\n        if (field) {\n\n            if (a[field] < b[field]) {\n                return -1;\n            } else if (a[field] > b[field]) {\n                return 1;\n            }\n            return 0;\n        } else {\n            if (a < b) {\n                return -1;\n            } else if (a > b) {\n                return 1;\n            }\n            return 0;\n        }\n    }\n}\n"
        },
        {
            "name": "MapValuesPipe",
            "id": "pipe-MapValuesPipe-fb8850b1cac5215f1f27be85c0cfa846",
            "file": "src/main/webapp/src/app/shared/pipes/map-values.pipe.ts",
            "type": "pipe",
            "description": "",
            "properties": [],
            "methods": [
                {
                    "name": "transform",
                    "args": [
                        {
                            "name": "value",
                            "type": "Map<any | any>"
                        },
                        {
                            "name": "args",
                            "type": "any[]",
                            "dotDotDotToken": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 8,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "Map<any | any>",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "args",
                            "type": "any[]",
                            "dotDotDotToken": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "ngname": "mapValues",
            "sourceCode": "import { Pipe, PipeTransform } from \"@angular/core\";\n\n@Pipe({name: \"mapValues\"})\nexport class MapValuesPipe implements PipeTransform {\n    public transform(value: Map<any, any>, ...args: any[]): any {\n        console.debug(\"Piping:\", value);\n        const returnArray: any[] = [];\n        value.forEach((entryVal: any, entryKey: any) => {\n            console.debug(\"Pushing:\", entryKey, entryVal);\n            returnArray.push({\n                key: entryKey,\n                value: entryVal\n            });\n        });\n        return returnArray;\n    }\n}\n"
        },
        {
            "name": "RoundingPipe",
            "id": "pipe-RoundingPipe-e1af0f250250cc123403f691eadd33b4",
            "file": "src/main/webapp/src/app/shared/pipes/rounding-pipe.pipe.ts",
            "type": "pipe",
            "description": "",
            "properties": [],
            "methods": [
                {
                    "name": "transform",
                    "args": [
                        {
                            "name": "value",
                            "type": "number"
                        },
                        {
                            "name": "digits",
                            "type": "number"
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 14,
                    "description": "<p>Rounds a number to the specified number of decimal places.\nApparently the most accurate method\nper {@link <a href=\"https://stackoverflow.com/a/43532829/773566\">https://stackoverflow.com/a/43532829/773566</a> this} link</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 335,
                                "end": 340,
                                "flags": 0,
                                "escapedText": "value"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 320,
                                "end": 325,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 326,
                                "end": 334,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 327,
                                    "end": 333,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 362,
                                "end": 368,
                                "flags": 0,
                                "escapedText": "digits"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 347,
                                "end": 352,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 353,
                                "end": 361,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 354,
                                    "end": 360,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 375,
                                "end": 382,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "number"
                        }
                    ]
                }
            ],
            "ngname": "rounding",
            "sourceCode": "import {Pipe, PipeTransform} from \"@angular/core\";\n\n@Pipe({name: \"rounding\"})\nexport class RoundingPipe implements PipeTransform {\n\n  /**\n   * Rounds a number to the specified number of decimal places.\n   * Apparently the most accurate method\n   * per {@link https://stackoverflow.com/a/43532829/773566 this} link\n   * @param {number} value\n   * @param {number} digits\n   * @returns {number}\n   */\n  public transform(value: number, digits: number): number {\n    let negative = false;\n    if (digits === undefined) {\n      digits = 0;\n    }\n    if (value < 0) {\n      negative = true;\n      value = value * -1;\n    }\n    const multiplier = Math.pow(10, digits);\n    value = parseFloat((value * multiplier).toFixed(11));\n    value = Number.parseFloat((Math.round(value) / multiplier).toFixed(2));\n    if (negative) {\n      value = Number.parseFloat((value * -1).toFixed(2));\n    }\n    return value;\n  }\n}\n"
        }
    ],
    "interfaces": [
        {
            "name": "CucumberTable",
            "id": "interface-CucumberTable-42a54ece3828e6d89ea473627792090f",
            "file": "src/test/e2e/step_definitions/user.steps.ts",
            "type": "interface",
            "sourceCode": "import {expect} from 'chai';\nimport {UsersPage} from '../page_objects/users.page';\nimport {Then, When} from 'cucumber';\n\nexport interface CucumberTable<T> {\n  hashes(): T[];\n}\n\nconst userPage = new UsersPage();\n\nThen(/^I create and submit a new \"([^\"]*)\" with the following properties:$/, async (userType, userData) => {\n  await userPage.fillUserForm(userType, userData.hashes()[0]);\n  return userPage.submitModal();\n});\n\nThen(/^I create a new \"([^\"]*)\" with the following properties:$/, async (userType, userData) => {\n  return userPage.fillUserForm(userType, userData.hashes()[0]);\n});\n\nThen(/^I edit user \"([^\"]*)\" properties:$/, async (user, userData) => {\n  return userPage.editUser(user, userData.hashes()[0]);\n});\n\nThen(/^The users table should have (\\d+) users$/, async (userCount) => {\n  return expect(userPage.countUsers())\n    .to.become(userCount);\n});\n\nWhen(/^I delete user \"([^\"]*)\"$/, async (username) => {\n  return userPage.deleteUser(username);\n});\n\nThen(/^Form field \"([^\"]*)\" should have error \"([^\"]*)\"$/, async (field, message) => {\n  return expect(userPage.getFieldMessage(field))\n    .to.become(message);\n});\n\nThen(/I dismiss the modal$/, async () => {\n  return userPage.dismissModal();\n});\n",
            "properties": [],
            "indexSignatures": [],
            "kind": 152,
            "methods": [
                {
                    "name": "hashes",
                    "args": [],
                    "optional": false,
                    "returnType": "T[]",
                    "typeParameters": [],
                    "line": 6
                }
            ]
        },
        {
            "name": "GeoJSONDataSource",
            "id": "interface-GeoJSONDataSource-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "_data",
                    "type": "Feature<GeometryObject> | FeatureCollection<GeometryObject>",
                    "optional": false,
                    "description": "",
                    "line": 60
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "extends": "GeoJSONSource"
        },
        {
            "name": "I3DMapSource",
            "id": "interface-I3DMapSource-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "extrude",
                    "type": "FillExtrusionLayer",
                    "optional": false,
                    "description": "",
                    "line": 56
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "extends": "ITrestleMapSource"
        },
        {
            "name": "IAggregationRequest",
            "id": "interface-IAggregationRequest-fe54b2d3d679234cf105dcc8a39b1bdf",
            "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {GeometryObject} from 'geojson';\nimport {HttpClient} from '@angular/common/http';\nimport {Observable} from 'rxjs';\nimport {environment} from '../../../environments/environment';\n\nexport const BBOX_PROPERTY = 'BOUNDING_BOX';\nexport type AggregationOperation = 'EQ' | 'NEQ' | 'GT' | 'GTEQ' | 'LT' | 'LTEQ';\n\nexport interface IAggregationRestriction {\n  dataset: string;\n  property: string;\n  value: object;\n}\n\nexport interface IAggregationStrategy {\n  field: string;\n  operation: AggregationOperation;\n  value: object;\n}\n\nexport interface IAggregationRequest {\n  restriction: IAggregationRestriction;\n  strategy: IAggregationStrategy;\n}\n\n@Injectable()\nexport class AggregationService {\n\n  private readonly baseURL: string;\n\n  constructor(private http: HttpClient) {\n    this.baseURL = environment.baseUrl;\n  }\n\n  public performAggregation<T>(request: IAggregationRequest): Observable<GeometryObject> {\n    console.debug('Aggregating!', request);\n    return this.http.post<GeometryObject>(this.baseURL + '/aggregate', request)\n  }\n}\n",
            "properties": [
                {
                    "name": "restriction",
                    "type": "IAggregationRestriction",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "strategy",
                    "type": "IAggregationStrategy",
                    "optional": false,
                    "description": "",
                    "line": 24
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IAggregationRestriction",
            "id": "interface-IAggregationRestriction-fe54b2d3d679234cf105dcc8a39b1bdf",
            "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {GeometryObject} from 'geojson';\nimport {HttpClient} from '@angular/common/http';\nimport {Observable} from 'rxjs';\nimport {environment} from '../../../environments/environment';\n\nexport const BBOX_PROPERTY = 'BOUNDING_BOX';\nexport type AggregationOperation = 'EQ' | 'NEQ' | 'GT' | 'GTEQ' | 'LT' | 'LTEQ';\n\nexport interface IAggregationRestriction {\n  dataset: string;\n  property: string;\n  value: object;\n}\n\nexport interface IAggregationStrategy {\n  field: string;\n  operation: AggregationOperation;\n  value: object;\n}\n\nexport interface IAggregationRequest {\n  restriction: IAggregationRestriction;\n  strategy: IAggregationStrategy;\n}\n\n@Injectable()\nexport class AggregationService {\n\n  private readonly baseURL: string;\n\n  constructor(private http: HttpClient) {\n    this.baseURL = environment.baseUrl;\n  }\n\n  public performAggregation<T>(request: IAggregationRequest): Observable<GeometryObject> {\n    console.debug('Aggregating!', request);\n    return this.http.post<GeometryObject>(this.baseURL + '/aggregate', request)\n  }\n}\n",
            "properties": [
                {
                    "name": "dataset",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "property",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "value",
                    "type": "object",
                    "optional": false,
                    "description": "",
                    "line": 13
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IAggregationStrategy",
            "id": "interface-IAggregationStrategy-fe54b2d3d679234cf105dcc8a39b1bdf",
            "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {GeometryObject} from 'geojson';\nimport {HttpClient} from '@angular/common/http';\nimport {Observable} from 'rxjs';\nimport {environment} from '../../../environments/environment';\n\nexport const BBOX_PROPERTY = 'BOUNDING_BOX';\nexport type AggregationOperation = 'EQ' | 'NEQ' | 'GT' | 'GTEQ' | 'LT' | 'LTEQ';\n\nexport interface IAggregationRestriction {\n  dataset: string;\n  property: string;\n  value: object;\n}\n\nexport interface IAggregationStrategy {\n  field: string;\n  operation: AggregationOperation;\n  value: object;\n}\n\nexport interface IAggregationRequest {\n  restriction: IAggregationRestriction;\n  strategy: IAggregationStrategy;\n}\n\n@Injectable()\nexport class AggregationService {\n\n  private readonly baseURL: string;\n\n  constructor(private http: HttpClient) {\n    this.baseURL = environment.baseUrl;\n  }\n\n  public performAggregation<T>(request: IAggregationRequest): Observable<GeometryObject> {\n    console.debug('Aggregating!', request);\n    return this.http.post<GeometryObject>(this.baseURL + '/aggregate', request)\n  }\n}\n",
            "properties": [
                {
                    "name": "field",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "operation",
                    "type": "AggregationOperation",
                    "optional": false,
                    "description": "",
                    "line": 18
                },
                {
                    "name": "value",
                    "type": "object",
                    "optional": false,
                    "description": "",
                    "line": 19
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ICacheServiceConfig",
            "id": "interface-ICacheServiceConfig-9890687b30eba710c996147df7a71794",
            "file": "src/main/webapp/src/app/shared/cache/cache.service.config.ts",
            "type": "interface",
            "sourceCode": "import { InjectionToken } from \"@angular/core\";\n\nexport const CACHE_SERVICE_CONFIG = new InjectionToken<ICacheServiceConfig>(\"cache.service.config\");\nexport interface ICacheServiceConfig {\n    maxAge: number;\n    maxSize: number;\n}",
            "properties": [
                {
                    "name": "maxAge",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "maxSize",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 6
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ICacheStatistics",
            "id": "interface-ICacheStatistics-2af1f1b55678fcfc2e51e62f69864cba",
            "file": "src/main/webapp/src/app/admin/indicies/index.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {Observable} from 'rxjs';\n\nexport interface IIndexLeafStatistics {\n  binaryID: string;\n  type: string;\n  coordinates: number[];\n  leafID: number;\n  direction: number;\n  records: number;\n}\n\nexport interface ICacheStatistics {\n  offsetValue: number;\n  maxValue: number;\n  dbIndexFragmentation: number;\n  dbIndexSize: number;\n  dbLeafStats: IIndexLeafStatistics[];\n  validIndexFragmentation: number;\n  validIndexSize: number;\n  validLeafStats: IIndexLeafStatistics[];\n}\n\n@Injectable()\nexport class IndexService {\n\n  private readonly baseUrl: string;\n\n  public constructor(private http: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get statistics for both caches\n   * @returns {Observable<ICacheStatistics>}\n   */\n  public getIndexStatistics(): Observable<ICacheStatistics> {\n    return this.http\n      .get<ICacheStatistics>(this.baseUrl + '/cache/index');\n  }\n\n  /**\n   * Rebuild specified index\n   * @param {string} index to rebuild\n   * @returns {Observable<void>}\n   */\n  public rebuildIndex(index: string): Observable<void> {\n    return this.http\n      .get<void>(this.baseUrl + '/cache/rebuild/' + index.toLocaleLowerCase());\n  }\n\n  /**\n   * Purge the specified index\n   * @param {string} cache to purge\n   * @returns {Observable<void>}\n   */\n  public purgeCache(cache: string): Observable<void> {\n    return this.http\n      .get<void>(this.baseUrl + '/cache/purge/' + cache.toLocaleLowerCase());\n  }\n}\n",
            "properties": [
                {
                    "name": "dbIndexFragmentation",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 18
                },
                {
                    "name": "dbIndexSize",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 19
                },
                {
                    "name": "dbLeafStats",
                    "type": "IIndexLeafStatistics[]",
                    "optional": false,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "maxValue",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "offsetValue",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "validIndexFragmentation",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "validIndexSize",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "validLeafStats",
                    "type": "IIndexLeafStatistics[]",
                    "optional": false,
                    "description": "",
                    "line": 23
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IColorServiceConfig",
            "id": "interface-IColorServiceConfig-bfea32b5654d858f2afc3fce934625c1",
            "file": "src/main/webapp/src/app/explore/explore.config.ts",
            "type": "interface",
            "sourceCode": "import {ICacheServiceConfig} from '../shared/cache/cache.service.config';\nimport {InjectionToken} from '@angular/core';\n\nexport const COLOR_SERVICE_CONFIG = new InjectionToken<IColorServiceConfig>(\"color-service.config\");\n\nexport enum COLOR_SCHEME {\n  CATEGORY_20B,\n  CATEGORY_20C,\n  CATEGORY_20,\n  CATEGORY_10\n}\n\nexport interface IColorServiceConfig {\n  colorType: COLOR_SCHEME;\n}\n\nexport const COLOR_DI_CONFIG: IColorServiceConfig = {\n  colorType: COLOR_SCHEME.CATEGORY_20B\n};\n\nexport const INDIVIDUAL_CACHE_DI_CONFIG: ICacheServiceConfig = {\n  maxAge: 30000,\n  maxSize: 1000\n};\n",
            "properties": [
                {
                    "name": "colorType",
                    "type": "COLOR_SCHEME",
                    "optional": false,
                    "description": "",
                    "line": 14
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IColorServiceConfig",
            "id": "interface-IColorServiceConfig-f69d28da357008db65b234f9b654b29d-1",
            "file": "src/main/webapp/src/app/shared/color/color-service.config.ts",
            "type": "interface",
            "sourceCode": "import { InjectionToken } from \"@angular/core\";\n\nexport const COLOR_SERVICE_CONFIG = new InjectionToken<IColorServiceConfig>(\"color-service.config\");\n\nexport enum COLOR_SCHEME {\n    CATEGORY_20B,\n    CATEGORY_20C,\n    CATEGORY_20,\n    CATEGORY_10\n}\n\nexport interface IColorServiceConfig {\n    colorType: COLOR_SCHEME;\n}\n",
            "properties": [
                {
                    "name": "colorType",
                    "type": "COLOR_SCHEME",
                    "optional": false,
                    "description": "",
                    "line": 13
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "IColorServiceConfig-1"
        },
        {
            "name": "ICompareBody",
            "id": "interface-ICompareBody-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "compare",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 57
                },
                {
                    "name": "compareAgainst",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 58
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ICompareIndividual",
            "id": "interface-ICompareIndividual-76b2c67b99f63b7db50272eed3499d5a",
            "file": "src/main/webapp/src/app/explore/compare/compare.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewChecked, AfterViewInit, ChangeDetectorRef, Component, ElementRef, ViewChild} from \"@angular/core\";\nimport {ISpatialComparisonReport, MapService} from \"../viewer/map.service\";\nimport moment from \"moment\";\nimport {interpolateReds} from \"d3-scale-chromatic\";\nimport {IDataExport} from \"../exporter/exporter.component\";\nimport {parse} from \"wellknown\";\nimport {MultiPolygon} from \"geojson\";\nimport {ActivatedRoute} from \"@angular/router\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {IMapAttributeChange, MapSource, TrestleMapComponent} from \"../../ui/trestle-map/trestle-map.component\";\nimport {IndividualService} from \"../../shared/individual/individual.service\";\nimport {LoadingSpinnerService} from \"../../ui/loading-spinner/loading-spinner.service\";\nimport {ColorService} from \"../../shared/color/color.service\";\nimport {TrestleTemporal} from \"../../shared/individual/TrestleIndividual/trestle-temporal\";\nimport {MapboxOptions} from \"mapbox-gl\";\nimport {MatSliderChange} from \"@angular/material/slider\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\ninterface ICompareIndividual {\n  individual: TrestleIndividual;\n  color: string;\n  visible: boolean;\n  focused: boolean;\n  height: number;\n  base: number;\n  sliderValue: number;\n  report?: ISpatialComparisonReport;\n}\n\ninterface ILoadingState {\n  color: loadingColor;\n  type: loadingState;\n  visible: boolean;\n}\n\nexport type loadingState = 'determinate' | 'indeterminate';\nexport type loadingColor = 'accent' | 'warn' | 'primary';\n\n@Component({\n  selector: 'compare',\n  templateUrl: './compare.component.html',\n  styleUrls: ['./compare.component.scss']\n})\nexport class CompareComponent implements AfterViewInit, AfterViewChecked {\n\n  public zoomMap = true;\n  public mapConfig: MapboxOptions;\n  public selectedIndividuals: Map<string, ICompareIndividual>;\n  public baseIndividual: ICompareIndividual | null;\n  public dataChanges: BehaviorSubject<MapSource | undefined>;\n  public layerChanges: Subject<IMapAttributeChange>;\n  public exportValues: IDataExport[];\n  public loadedOverlap: ISpatialComparisonReport | null;\n  public loading: ILoadingState;\n  public currentSliderValue: number;\n\n  private filterCompareResults: boolean;\n  private layerDepth: number;\n  private maxHeight: number;\n  private layerNumber: number;\n  @ViewChild(TrestleMapComponent)\n  private mapComponent: TrestleMapComponent;\n  @ViewChild('loadable')\n  private mapRef: ElementRef;\n  private disabledFocusIndividuals: string[];\n\n  constructor(private is: IndividualService,\n              private vs: MapService,\n              private spinner: LoadingSpinnerService,\n              private route: ActivatedRoute,\n              private cdRef: ChangeDetectorRef,\n              private cs: ColorService\n  ) {\n\n    this.mapConfig = {\n      style: 'mapbox://styles/nrobison/cj3n7if3q000s2sutls5a1ny7',\n      center: [32.3558991, -25.6854313],\n      zoom: 8,\n      pitch: 40,\n      bearing: 20,\n      container: \"map\"\n    };\n    this.layerDepth = 50;\n    this.maxHeight = 2016;\n    this.selectedIndividuals = new Map();\n    // Setup layer coloring\n    this.layerNumber = 0;\n    this.currentSliderValue = 0;\n    this.dataChanges = new BehaviorSubject(undefined);\n    this.layerChanges = new Subject();\n    this.filterCompareResults = true;\n    this.exportValues = [{\n      dataset: 'GAUL',\n      individuals: []\n    }];\n    this.loadedOverlap = null;\n\n    this.loading = {\n      color: 'primary',\n      type: 'indeterminate',\n      visible: false\n    };\n    this.disabledFocusIndividuals = [];\n  }\n\n  public ngAfterViewInit(): void {\n    // Subscribe to route observables\n    this.route.queryParams\n      .subscribe((queryParams) => {\n        console.debug('params', queryParams);\n        const individual = queryParams['id'];\n        if (individual !== null) {\n          this.addBaseIndividual(individual);\n        }\n      });\n\n    console.debug('Child', this.mapComponent);\n    this.spinner.setViewContainerRef(this.mapRef.nativeElement);\n  }\n\n  /**\n   * Recheck the view.\n   * I'm really not sure why I need this, but SO says so\n   * https://stackoverflow.com/questions/43513421/ngif-expression-has-changed-after-it-was-checked\n   */\n  public ngAfterViewChecked(): void {\n    this.cdRef.detectChanges();\n  }\n\n  /**\n   * Compare the base individual against all the other currently visible objects\n   */\n  public compareIndividuals(): void {\n    // Get all the individuals\n    if (this.baseIndividual) {\n      this.loading = {\n        color: 'accent',\n        type: 'indeterminate',\n        visible: true\n      };\n      this.vs.compareIndividuals({\n        compare: this.baseIndividual.individual.getID(),\n        compareAgainst: Array.from(this.selectedIndividuals.values())\n          // Filter out invisible members\n          .filter((individual) => individual.visible === true)\n          .map((individual) => individual.individual.getID())\n      })\n        .subscribe((data) => {\n          console.debug('Has data from compare', data);\n          // Add the comparison reports to each individual,\n          // or set them equal to undefined\n          data.reports.forEach((report) => {\n            this.loading.visible = false;\n            const selection = this.selectedIndividuals.get(report.objectBID);\n            if (selection) {\n              if (selection.visible) {\n                selection.report = report;\n                //    Change the color to something on the red scale\n                if (report.spatialOverlapPercentage) {\n                  const interpolated = interpolateReds(\n                    report.spatialOverlapPercentage);\n                  selection.color = interpolated;\n                  this.layerChanges.next({\n                    individual: selection.individual.getID(),\n                    // Change the color and set the opacity a little higher\n                    changes: [\n                      {\n                        attribute: 'fill-extrusion-color',\n                        value: interpolated\n                      },\n                      {\n                        attribute: 'fill-extrusion-opacity',\n                        value: 0.85\n                      }]\n                  });\n                } else {\n                  // If we don't have any overlap, are we supposed to filter ou those individuals?\n                  if (this.filterCompareResults) {\n                    this.removeIndividual(selection);\n                  }\n                }\n              } else {\n                selection.report = undefined;\n              }\n            }\n          });\n        }, (error) => {\n          console.debug(error);\n          this.loading = {\n            color: 'warn',\n            type: 'determinate',\n            visible: true\n          };\n        });\n    }\n  }\n\n  /**\n   * Handler function to load the selected individual\n   * @param {string} individual\n   */\n  public selectedHandler(individual: string): void {\n    console.debug('Selected:', individual);\n    this.loadSelectedIndividual(individual);\n  }\n\n  /**\n   * Add base individual to compare\n   * @param {string} individual\n   */\n  public addBaseIndividual(individual: string): void {\n    this.loadSelectedIndividual(individual, true);\n  }\n\n  /**\n   * Reset comparison to the base state\n   *\n   * If a new individual is provided, add it\n   * @param {string} individual\n   */\n  public reset(individual?: string): void {\n    //    Clear the map\n    //    Remove all the individuals from map\n    this.mapComponent.clearMap();\n    this.zoomMap = true;\n    // this.selectedIndividuals = [];\n    this.selectedIndividuals = new Map();\n    //    Clear the base selection\n    this.baseIndividual = null;\n    this.layerNumber = 0;\n    this.currentSliderValue = 0;\n    this.cs.reset();\n\n    //    Should we add the given individual to the compare?\n    if (individual) {\n      this.addBaseIndividual(individual);\n    }\n  }\n\n  /**\n   * Toggle the visibility of the given individual\n   * @param {ICompareIndividual} individual\n   */\n  public toggleVisibility(individual: ICompareIndividual): void {\n    individual.visible = !individual.visible;\n    this.mapComponent\n      .toggleIndividualVisibility(individual\n          .individual.getID(),\n        individual.visible);\n  }\n\n  /**\n   * Toggle the focus of a given individual, this will hide all other currently visible individuals\n   * @param {ICompareIndividual} individual\n   */\n  public toggleFocus(individual: ICompareIndividual): void {\n    individual.focused = !individual.focused;\n\n    // If we've selected the focus option, grab all the currently visible layers, disable them, and stash them for later\n    if (individual.focused) {\n      // If we have previously disabled individuals, reenable them, then do your thing\n      if (!(this.disabledFocusIndividuals.length === 0)) {\n        this.disabledFocusIndividuals\n          .forEach((fIndividual) => {\n            const mapValue = this.selectedIndividuals.get(fIndividual);\n            if (mapValue) {\n              this.toggleVisibility(mapValue);\n            }\n          });\n        // Also, find any other focused layers, and unfocus them.\n        this.selectedIndividuals\n          .forEach((value) => {\n            if (value !== individual && value.focused) {\n              value.focused = false;\n            }\n          });\n        this.disabledFocusIndividuals = [];\n      }\n      //    Get all the currently visible layers\n      this.selectedIndividuals\n        .forEach((value, key) => {\n          // If the individual is visible, stash it's value so we can enable it later\n          if (value !== individual && value.visible) {\n            this.disabledFocusIndividuals.push(key);\n            this.toggleVisibility(value);\n          }\n        });\n      //    If the individual isn't supposed to be focused, grab all the stashed individuals and reenable them.\n    } else {\n      this.disabledFocusIndividuals\n        .forEach((fIndividual) => {\n          const mapValue = this.selectedIndividuals.get(fIndividual);\n          if (mapValue) {\n            this.toggleVisibility(mapValue);\n          }\n        });\n      //    Reset the focused list\n      this.disabledFocusIndividuals = [];\n    }\n  }\n\n  /**\n   * Remove the given individual from the comparison list\n   * @param {ICompareIndividual} individual\n   */\n  public removeIndividual(individual: ICompareIndividual): void {\n    console.debug('Remove:', individual);\n    // Remove from the array first, then from the map\n    this.selectedIndividuals.delete(individual.individual.getID());\n    this.mapComponent\n      .removeIndividual(individual.individual.getID());\n\n    //    Remove from export\n    const idx = this.exportValues[0].individuals.indexOf(individual.individual.getID());\n    if (idx > -1) {\n      this.exportValues[0].individuals.splice(idx);\n    }\n\n    //    Return the color to reuse\n    this.cs.returnColor(individual.color);\n  }\n\n  /**\n   * Update explode slider and change the values on the map\n   * @param {MatSliderChange} event\n   * @param {ICompareIndividual | null} selection\n   */\n  public sliderUpdate(event: MatSliderChange, selection = this.baseIndividual) {\n    if ((event.value !== null) && (selection !== null)) {\n      //     For now, let's just change the base individual,\n      // we'll figure out the rest later\n      const newOffset = (event.value - selection.sliderValue) * 50;\n      this.mapComponent.change3DOffset(selection.height,\n        newOffset,\n        selection.individual.getID());\n      selection.sliderValue = event.value;\n      selection.height = selection.height + newOffset;\n      selection.base = selection.base + newOffset;\n    }\n  }\n\n  /**\n   * Filter compare results to only return objects which overlap in some way\n   * @param {MatSlideToggleChange} event\n   */\n  public filterChanged(event: MatSlideToggleChange): void {\n    this.filterCompareResults = event.checked;\n  }\n\n  /**\n   * Perform spatial intersection with base individual\n   */\n  public intersectBaseIndividual(): void {\n    if (this.baseIndividual) {\n      // this.spinner.reveal();\n      this.loading = {\n        color: 'accent',\n        type: 'indeterminate',\n        visible: true\n      };\n      this.vs\n        .stIntersectIndividual('GAUL',\n          this.baseIndividual.individual.getSpatialValue(),\n          undefined,\n          moment(),\n          0)\n        .subscribe((results) => {\n          console.debug('IDs', results.map((indv) => indv.withoutHostname()));\n          // If we have results, turn off the loading bar\n          this.loading.visible = false;\n          results\n            .filter((result) => {\n              // Filter out the base individual,\n              // if it exists, in the grossest way possible\n              if (this.baseIndividual !== null) {\n                return !(result.getID() === this.baseIndividual.individual.getID());\n              }\n              return true;\n            })\n            .forEach((result) => this.addIndividualToCompare(result, false));\n          // this.spinner.hide();\n        }, (error) => {\n          console.error(error);\n          this.loading = {\n            color: 'warn',\n            type: 'determinate',\n            visible: true\n          };\n        });\n    }\n  };\n\n  /**\n   * Get all currently selected individuals\n   * @returns {ICompareIndividual[]}\n   */\n  public getSelectedIndividuals(): ICompareIndividual[] {\n    return Array.from(this.selectedIndividuals.values());\n  }\n\n  /**\n   * Pipe function to enable the view to check for changes\n   * @returns {ICompareIndividual[]}\n   */\n  public get mapValues(): ICompareIndividual[] {\n    return Array.from(this.selectedIndividuals.values());\n  }\n\n  /**\n   * Toggle overlap between the base individual and the selected individual\n   * @param {ISpatialComparisonReport} overlap\n   */\n  public toggleOverlap(overlap: ISpatialComparisonReport): void {\n    const id = TrestleIndividual.filterID(overlap.objectAID)\n      + '-' + TrestleIndividual.filterID(overlap.objectBID);\n    // If we have an overlap, and we haven't loaded it yet\n    if (overlap.spatialOverlap) {\n      // If the loaded overlap is null, add the new one\n      if (this.loadedOverlap === null) {\n        // Build the change value\n        const changes: MapSource = {\n          id,\n          data: {\n            type: 'Feature',\n            // TODO(nickrobison): Gross?\n            geometry: (parse(overlap.spatialOverlap) as MultiPolygon),\n            properties: null,\n            id\n          },\n          extrude: {\n            id: id + '-extrude',\n            type: 'fill-extrusion',\n            source: id,\n            paint: {\n              'fill-extrusion-color': 'blue',\n              'fill-extrusion-height': 3050,\n              'fill-extrusion-base': 3000,\n              'fill-extrusion-opacity': 0.7\n            }\n          }\n        };\n\n        //    Turn off all layers except objects A and B that we need\n        this.selectedIndividuals.forEach((value) => {\n          if (CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            this.toggleVisibility(value);\n          }\n        });\n\n        //    Now, add the new overlap\n        this.dataChanges.next(changes);\n        this.loadedOverlap = overlap;\n\n        //    If we are the overlap, remove us and turn everything back on\n      } else if (this.loadedOverlap === overlap) {\n        this.selectedIndividuals.forEach((value) => {\n          if (CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            this.toggleVisibility(value);\n          }\n        });\n        this.mapComponent.removeIndividual(id);\n        this.loadedOverlap = null;\n        //    Otherwise, remove the current overlap, and cycle what needs to be toggled\n      } else {\n        //    Unload the current overlap\n        const overlapID = TrestleIndividual.filterID(this.loadedOverlap.objectAID)\n          + '-' + TrestleIndividual.filterID(this.loadedOverlap.objectBID);\n        this.mapComponent.removeIndividual(overlapID);\n        //    Build the change value\n        const changes: MapSource = {\n          id,\n          data: {\n            type: 'Feature',\n            // TODO(nickrobison): Gross?\n            geometry: (parse(overlap.spatialOverlap) as MultiPolygon),\n            properties: null,\n            id\n          },\n          extrude: {\n            id: id + '-extrude',\n            type: 'fill-extrusion',\n            source: id,\n            paint: {\n              'fill-extrusion-color': 'blue',\n              'fill-extrusion-height': 4000,\n              'fill-extrusion-base': 3000,\n              'fill-extrusion-opacity': 0.7\n            }\n          }\n        };\n\n        this.selectedIndividuals.forEach((value) => {\n          //    If it's part of the new overlap, and is not visible, turn it on\n          if (!CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            if (!value.visible) {\n              this.toggleVisibility(value);\n            }\n            //    If it's visible and not part of the new overlap, turn it off\n          } else if (value.visible) {\n            this.toggleVisibility(value);\n          }\n        });\n\n        //    Set the new overlap\n        this.dataChanges.next(changes);\n        this.loadedOverlap = overlap;\n      }\n    }\n  }\n\n  /**\n   * Load the selected individual by fetching its value from the database\n   * @param {string} individual\n   * @param {boolean} baseIndividual\n   */\n  private loadSelectedIndividual(individual: string, baseIndividual = false): void {\n    this.is.getTrestleIndividual(individual)\n      .subscribe((result) => this.addIndividualToCompare(result, baseIndividual));\n  }\n\n  /**\n   * Add individual to the comparison set and the map\n   * @param {TrestleIndividual} individual\n   * @param {boolean} baseIndividual\n   */\n  private addIndividualToCompare(individual: TrestleIndividual, baseIndividual = false): void {\n    console.debug('Adding individual:', individual);\n    // Before we add any individuals to the map, we need to see if we're loading the base individual or not\n    // This is to deal with some racy behavior between drawing the individual on the map and moving on from the data load\n    // It's gross, but what do you expect?\n    if (baseIndividual) {\n      console.debug('Setting zoom true');\n      this.zoomMap = true;\n    } else {\n      console.debug('Setting zoom false');\n      // If zoom is true, manually run the change detection.\n      // Why? no idea\n      if (this.zoomMap === true) {\n        this.zoomMap = false;\n        this.cdRef.detectChanges();\n      } else {\n        this.zoomMap = false;\n      }\n    }\n\n    // This is one way to filter out the base individual\n    console.debug('Adding %s to map', individual.getFilteredID());\n    const color = this.cs.getColor(this.layerNumber);\n    const height = this.getHeight(individual.getTemporal());\n    const baseHeight = CompareComponent.getBase(individual.getTemporal());\n    this.dataChanges.next({\n      id: individual.getID(),\n      data: {\n        type: 'Feature',\n        geometry: individual.getSpatialValue(),\n        id: individual.getFilteredID(),\n        properties: individual.getFactValues()\n      },\n      extrude: {\n        id: individual.getID() + '-extrude',\n        type: 'fill-extrusion',\n        source: individual.getID(),\n        paint: {\n          'fill-extrusion-color': color,\n          'fill-extrusion-height': height,\n          'fill-extrusion-base': baseHeight,\n          'fill-extrusion-opacity': 0.7\n        }\n      },\n      labelField: 'adm2_name'\n    });\n\n    const compare = {\n      individual,\n      color,\n      visible: true,\n      focused: false,\n      height,\n      base: baseHeight,\n      sliderValue: 50\n    };\n\n    // Are we loading the base selection, or not?\n    if (baseIndividual) {\n      // Reset the slider value to 0\n      compare.sliderValue = 0;\n      this.baseIndividual = compare;\n    } else {\n      //    Add the selection to the list\n      this.selectedIndividuals.set(compare.individual.getID(),\n        compare);\n      // this.selectedIndividuals.push(compare);\n    }\n    this.layerNumber++;\n\n    //    Add them to the export record\n    this.exportValues[0].individuals.push(compare.individual.getID());\n  }\n\n  private getHeight(temporal: TrestleTemporal): number {\n    const to = temporal.getTo();\n    if (to === undefined) {\n      return this.maxHeight;\n    } else {\n      return to.get('year');\n    }\n  }\n\n  private static getBase(temporal: TrestleTemporal): number {\n    return temporal.getFrom().get('year');\n  }\n\n  /**\n   * Filter only individuals actually involved in the overlap\n   * @param {ICompareIndividual} value\n   * @param {ISpatialComparisonReport} overlap\n   * @returns {boolean}\n   */\n  private static filterOverlapIndividuals(value: ICompareIndividual, overlap: ISpatialComparisonReport) {\n    const id = value.individual.getID();\n    return (id !== overlap.objectAID) &&\n      (id !== overlap.objectBID);\n  }\n}\n",
            "properties": [
                {
                    "name": "base",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "color",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "focused",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "height",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 25
                },
                {
                    "name": "individual",
                    "type": "TrestleIndividual",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "report",
                    "type": "ISpatialComparisonReport",
                    "optional": true,
                    "description": "",
                    "line": 28
                },
                {
                    "name": "sliderValue",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 27
                },
                {
                    "name": "visible",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 23
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IComparisonReport",
            "id": "interface-IComparisonReport-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "reports",
                    "type": "ISpatialComparisonReport[]",
                    "optional": false,
                    "description": "",
                    "line": 31
                },
                {
                    "name": "union",
                    "type": "IContributionReport | null",
                    "optional": false,
                    "description": "",
                    "line": 30
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IContributionPart",
            "id": "interface-IContributionPart-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "contribution",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "object",
                    "type": "any",
                    "optional": false,
                    "description": "",
                    "line": 35
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IContributionReport",
            "id": "interface-IContributionReport-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "area",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 25
                },
                {
                    "name": "contributingParts",
                    "type": "IContributionPart[]",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "object",
                    "type": "any",
                    "optional": false,
                    "description": "",
                    "line": 24
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ID3Margin",
            "id": "interface-ID3Margin-a751aa0e176867187373c75fc4223367",
            "file": "src/main/webapp/src/app/ui/common.ts",
            "type": "interface",
            "sourceCode": "export interface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n",
            "properties": [
                {
                    "name": "bottom",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "left",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "right",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 3
                },
                {
                    "name": "top",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 2
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ID3Margin",
            "id": "interface-ID3Margin-2e6af61f3453851a2c05192ad406e122-1",
            "file": "src/main/webapp/src/app/admin/metrics-graph/metrics-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChange, ViewChild} from '@angular/core';\nimport {BaseType, select, Selection} from 'd3-selection';\nimport {scaleLinear, scaleOrdinal, scaleTime, ScaleTime} from 'd3-scale';\nimport {curveBasis, line} from 'd3-shape';\nimport {max, min} from 'd3-array';\nimport {axisBottom, axisLeft} from 'd3-axis';\nimport {schemeCategory10} from 'd3';\nimport {IMetricsData} from './metrics.service';\n\ninterface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\n@Component({\n  selector: 'metrics-graph',\n  templateUrl: './metrics-graph.component.html',\n  styleUrls: ['./metrics-graph.component.scss']\n})\n\nexport class MetricsGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('container') private element: ElementRef;\n  @Input() public data: IMetricsData;\n  @Input() public minTime: Date;\n  @Input() public maxTime: Date;\n  private graphData: IMetricsData[] = [];\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IMetricsData, null, undefined>;\n  private svg: Selection<BaseType, IMetricsData, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private x: ScaleTime<number, number>;\n  private visible: Map<string, boolean> = new Map();\n\n  constructor() {\n  }\n\n  public ngAfterViewInit(): void {\n    console.debug('Graph view-init');\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const dataChange = changes['data'];\n    if (dataChange != null\n      && !dataChange.isFirstChange()\n      && (dataChange.currentValue !== dataChange.previousValue)) {\n      console.debug('Updated, plotting');\n      const currentValue: IMetricsData = changes['data'].currentValue;\n      this.graphData.push(currentValue);\n      console.debug('Adding as visible:', currentValue.metric);\n      this.visible.set(currentValue.metric, true);\n      this.plotData();\n    }\n  }\n\n  /**\n   * Get all metrics that aren't currently disabled\n   * @returns {string[]}\n   */\n  public getVisibleMetrics(): string[] {\n    const metrics = Array<string>();\n    this.visible.forEach((value, key) => {\n      if (value) {\n        metrics.push(key);\n      }\n    });\n    return metrics;\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IMetricsData>(this.htmlElement);\n    this.margin = {top: 20, right: 200, bottom: 20, left: 70};\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n    console.debug('Creating D3 graph with width/height', this.width + '/' + this.height);\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    // Setup the x axis\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis axis-x')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n    // this.x.domain(extent(this.graphData[0].values, (d: IMetricsValue)=> d.timestamp));\n    console.debug('D3 initialized');\n\n  }\n\n  private plotData(): void {\n\n    const y = scaleLinear().range([this.height, 0]);\n    const z = scaleOrdinal(schemeCategory10);\n\n    const metricsLine = line()\n      .curve(curveBasis)\n      .x((d: any) => this.x(d.timestamp))\n      .y((d: any) => y(d.value));\n\n    // Build domain values\n    y.domain([\n      (min(this.graphData,\n        (d) => min(d.values,\n          (mv) => mv.value) || 0) || 0),\n      (max(this.graphData,\n        (d) => max(d.values,\n          (mv) => mv.value) || 0) || 0)\n    ]);\n\n    z.domain(this.graphData.map((d) => d.metric));\n    console.debug('Z-domain', z.domain());\n\n    this.svg\n      .append('g')\n      .attr('class', 'axis axis-y')\n      .call(axisLeft(y))\n      .append('text')\n      .attr('transform', 'rotate(-90)')\n      .attr('y', 6)\n      .attr('dy', '0.71em')\n      .attr('fill', '#000')\n      .text('Value');\n\n    const metric = this.svg.selectAll('.metric')\n      .data(this.graphData)\n      .enter().append('g')\n      .attr('class', 'metric');\n\n    metric\n      .append('path')\n      .attr('class', 'line')\n      .attr('id', (d) => d.metric.replace(/\\./g, '-'))\n      .attr('d', (d: any) => metricsLine(d.values))\n      // .attr(\"data-legend\", (d) => d.metric)\n      .style('stroke', (d) => z(d.metric));\n\n    //    Add the legend\n    const legend = this.svg.selectAll('.legend')\n      .data(z.domain())\n      .enter()\n      .append('g')\n      .attr('class', 'legend')\n      .attr('id', (d) => 'legend-' + d.replace(/\\./g, '-'))\n      .attr('transform',\n        (d, i) => 'translate('\n          + (this.width) + ','\n          + (i * ((this.width / 100) * 2) + 15) + ')')\n      .on('click', this.legendClickHandler);\n\n    legend\n      .append('circle')\n      .attr('cx', 30)\n      .attr('cy', 30)\n      .attr('r', this.width / 150)\n      .style('fill', z);\n\n    legend\n      .append('text')\n      .attr('x', 40)\n      .attr('y', 30)\n      .attr('dy', '0.25em')\n      .style('text-anchor', 'start')\n      .text(d => d);\n\n  }\n\n  private legendClickHandler = (d: string): void => {\n    console.debug('Clicked', d);\n    console.debug('Visible', this.visible);\n    const isVisible = this.visible.get(d);\n    console.debug('Metric: ' + d + ' is visible?', isVisible);\n    if (isVisible) {\n      console.debug('Going out');\n      this.svg.selectAll('#' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', 0);\n\n      // Fade the legend\n      this.svg.select('#legend-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', .2);\n\n      // Fade the y-axis\n      this.svg.select('#y-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', .2);\n\n      this.visible.set(d, false);\n    } else {\n      console.debug('Coming back');\n      this.svg.selectAll('#' + d.replace(/\\./g, '-'))\n        // .style(\"display\", \"block\")\n        .transition()\n        .duration(1000)\n        .style('opacity', 1);\n\n      // Fade the legend\n      this.svg.select('#legend-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', 1);\n\n      // Fade the y-axis\n      this.svg.select('#y-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', 1);\n\n      this.visible.set(d, true);\n    }\n  };\n}\n",
            "properties": [
                {
                    "name": "bottom",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "left",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "right",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "top",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 14
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "ID3Margin-1"
        },
        {
            "name": "ID3Margin",
            "id": "interface-ID3Margin-d838f5efb91e80799d08955b6677568c-2",
            "file": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  Input,\n  OnChanges,\n  SimpleChange,\n  ViewChild,\n  ViewEncapsulation\n} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {ScaleOrdinal, scaleOrdinal} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {\n  forceCenter,\n  forceLink,\n  forceManyBody,\n  forceSimulation,\n  Simulation,\n  SimulationLinkDatum,\n  SimulationNodeDatum\n} from \"d3-force\";\nimport * as moment from \"moment\";\nimport {TrestleIndividual} from \"../../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject} from \"rxjs\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\nexport interface IIndividualConfig {\n  data: TrestleIndividual;\n  validAt: moment.Moment;\n  dbAt?: moment.Moment;\n}\n\nconst enum NodeType {\n  INDIVIDUAL,\n  VTEMPORAL,\n  FACT,\n  RELATION\n}\n\ninterface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\ninterface IGraphLayout {\n  nodes: IFactNode[];\n  links: Array<SimulationLinkDatum<IFactNode>>;\n}\n\ninterface IFactNode extends SimulationNodeDatum {\n  id: string;\n  name: string;\n  valid: boolean;\n  group: number;\n}\n\n@Component({\n  selector: 'individual-graph',\n  templateUrl: './individual-graph.component.html',\n  styleUrls: ['./individual-graph.component.scss'],\n  encapsulation: ViewEncapsulation.None\n})\n\nexport class IndividualGraphComponent implements AfterViewInit, OnChanges {\n\n  @ViewChild('container') public element: ElementRef;\n  @Input() public config: IIndividualConfig;\n\n  public factToggleName = 'fact-toggle';\n  public relationToggleName = 'relation-toggle';\n  public graphFacts = true;\n  public graphRelations = false;\n\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IFactNode, null, undefined>;\n  private svg: Selection<BaseType, IFactNode, null, undefined>;\n  private margin: ID3Margin;\n  private height: number;\n  private width: number;\n  private color: ScaleOrdinal<string, string>;\n  private layout: IGraphLayout;\n  private links: Selection<BaseType, SimulationLinkDatum<IFactNode>, any, any>;\n  private nodes: Selection<any, IFactNode, any, any>;\n  private simulation: Simulation<IFactNode, any>;\n  private nodeSize: number;\n  private nodeSizeLarge: number;\n  private dataChanges: BehaviorSubject<IIndividualConfig | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    console.debug('graph view-init');\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n    //    Subscribe\n    this.dataChanges\n      .subscribe((value) => {\n        if (value !== undefined) {\n          this.buildGraph(value);\n          this.update({\n            nodes: [],\n            links: [],\n          });\n          this.update(this.layout);\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const configChange = changes['config'];\n    console.debug('Changed', configChange);\n    if (configChange.currentValue !== configChange.previousValue) {\n      console.debug('Config changed', configChange);\n      this.dataChanges.next(configChange.currentValue);\n    }\n  }\n\n  private setupD3() {\n    this.host = select<HTMLElement, IFactNode>(this.htmlElement);\n    this.margin = {top: 10, right: 20, bottom: 10, left: 10};\n    console.debug('offsetWidth', this.htmlElement.offsetWidth);\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n    this.nodeSize = this.width / 75;\n    this.nodeSizeLarge = this.width / 50;\n    console.debug('Creating D3 graph with width/height', this.width + '/' + this.height);\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.color = scaleOrdinal(schemeCategory10);\n    console.debug('D3 initialized');\n  }\n\n  private update(data: IGraphLayout): void {\n    console.debug('Data in update function', data);\n    const force = forceManyBody();\n    force.strength(-1000);\n    this.simulation = forceSimulation<IFactNode>()\n      .force('link', forceLink().id((d: IFactNode) => d.id))\n      .force('charge', force)\n      .force('center', forceCenter(this.width / 2, this.height / 2));\n\n    const linkData = this.svg.selectAll('.link')\n      .data(data.links, (d: any) => d.source.id + '_' + d.target.id);\n\n    this.links = linkData.enter()\n      .append('line')\n      .attr('class', 'link');\n\n    const nodeData = this.svg.selectAll('.node')\n      .data(data.nodes, (d: IFactNode) => d.id);\n\n    this.nodes = nodeData\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .on('click', this.nodeClick)\n      .on('mouseover', this.nodeMouseOver)\n      .on('mouseout', this.nodeMouseOut);\n\n    this.nodes\n      .append('circle')\n      .attr('r', this.nodeSize)\n      .style('fill', (d) => this.color(d.group.toString(10)))\n      .style('opacity', (d) => d.valid ? 1.0 : 0.5);\n\n    this.nodes\n      .append('text')\n      .attr('x', 16)\n      .attr('dy', '.35em')\n      .text((d) => d.name);\n\n    //    Legend\n    const legend = this.svg.selectAll('.legend')\n      .data(this.color.domain())\n      .enter()\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', (d, i) => 'translate(0,' + (i * ((this.nodeSize) * 2) + 20) + ')');\n\n    legend.append('circle')\n      .attr('cx', this.width - 18)\n      .attr('r', this.nodeSize)\n      .attr('cy', this.nodeSize)\n      .style('fill', this.color);\n\n    legend\n      .append('text')\n      .attr('x', this.width - (this.nodeSize) * 2 - 12)\n      .attr('y', this.nodeSize)\n      .attr('dy', '0.35em')\n      .style('text-anchor', 'end')\n      .text((d) => IndividualGraphComponent.parseColorGroup(d));\n    // Force setup\n    this.simulation\n      .nodes(data.nodes)\n      .on('tick', this.forceTick);\n\n    // For some reason, the links() function doesn't exist on the simulation type, so we do a simple cast to get around it.\n    // Seems to work, and the only other option is to lose all type checking for the simulation object\n    (this.simulation.force('link') as any).links(data.links);\n\n    linkData.exit().remove();\n    nodeData.exit().remove();\n  }\n\n  private nodeClick = (d: IFactNode): void => {\n    console.debug('Clicked', d);\n  };\n\n  private nodeMouseOver = (event: any): void => {\n    select(event.currentTarget).select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSizeLarge);\n  };\n\n  private nodeMouseOut = (event: any): void => {\n    select(event.currentTarget)\n      .select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSize);\n  };\n\n  private forceTick = (): void => {\n    this.nodes\n      .attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')');\n\n    this.links\n      .attr('x1', (d: any) => d.source.x)\n      .attr('y1', (d: any) => d.source.y)\n      .attr('x2', (d: any) => d.target.x)\n      .attr('y2', (d: any) => d.target.y);\n  };\n\n  private buildGraph(config: IIndividualConfig): void {\n    const individual = config.data;\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n\n    //    Add the selection as node 0\n    const individualNode = {\n      id: individual.getID(),\n      name: IndividualGraphComponent.parseIndividualID(individual.getID()),\n      valid: true,\n      group: NodeType.INDIVIDUAL\n    };\n\n    const individualTemporal = {\n      id: individual.getTemporal().getID(),\n      name: 'selection-temporal',\n      valid: true,\n      group: NodeType.VTEMPORAL\n    };\n\n    this.layout.nodes.push(individualNode, individualTemporal);\n\n    this.layout.links.push({\n      source: individualNode,\n      target: individualTemporal\n    });\n\n    if (this.graphFacts) {\n      individual.getFacts().forEach(fact => {\n        const factNode = {\n          id: fact.getID(),\n          name: fact.getName(),\n          valid: fact.isActive(config.validAt, config.dbAt),\n          group: NodeType.FACT\n        };\n        this.layout.nodes.push(factNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: factNode\n        });\n      });\n    }\n\n    //    Relations\n    if (this.graphRelations) {\n      individual.getRelations().forEach(relation => {\n        const relationNode = {\n          id: relation.getObject(),\n          name: relation.getType().toString() + ': ' + IndividualGraphComponent.parseIndividualID(relation.getObject()),\n          valid: true,\n          group: NodeType.RELATION\n        };\n        this.layout.nodes.push(relationNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: relationNode\n        });\n      });\n    }\n  }\n\n  public changeGraphMembers(event: MatSlideToggleChange): void {\n    if (event.source.id === this.factToggleName) {\n      console.debug('Graph facts?', event.checked);\n      this.graphFacts = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    } else if (event.source.id === this.relationToggleName) {\n      console.debug('Graph relations?', event.checked);\n      this.graphRelations = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    }\n  }\n\n  private static parseColorGroup(group: string): string {\n    switch (parseInt(group, 10)) {\n      case 0:\n        return 'Individual';\n      case 1:\n        return 'Valid Temporal';\n      case 2:\n        return 'Fact';\n      case 3:\n        return 'Relation';\n      default:\n        return 'unknown';\n    }\n  }\n\n  private static parseIndividualID(id: string): string {\n    const matches = id.match(/(#)(.*)/g);\n    if (matches) {\n      return matches[0].replace('#', '');\n    }\n    return id;\n  }\n}\n",
            "properties": [
                {
                    "name": "bottom",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "left",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "right",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 46
                },
                {
                    "name": "top",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 45
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "isDuplicate": true,
            "duplicateId": 2,
            "duplicateName": "ID3Margin-2"
        },
        {
            "name": "IDataExport",
            "id": "interface-IDataExport-a8596a9437f298269896bff17cd3c4fb",
            "file": "src/main/webapp/src/app/explore/exporter/exporter.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, Input} from '@angular/core';\nimport {ExporterService} from './exporter.service';\nimport {forkJoin} from 'rxjs';\nimport {finalize} from 'rxjs/operators';\nimport {saveAs} from \"file-saver\";\nimport {MatSelectChange} from '@angular/material/select';\n\nexport interface IDataExport {\n  dataset: string;\n  individuals: string[];\n}\n\n@Component({\n  selector: 'data-exporter',\n  templateUrl: './exporter.component.html',\n  styleUrls: ['./exporter.component.scss']\n})\nexport class ExporterComponent {\n\n  @Input() public dataExport: IDataExport[];\n  @Input() public label = true;\n  public options: { value: string, viewValue: string }[];\n  public selectedValue: string;\n  public loading: boolean;\n\n  public constructor(private es: ExporterService) {\n    this.options = [\n      {value: 'SHAPEFILE', viewValue: 'Shapefile'},\n      {value: 'GEOJSON', viewValue: 'GeoJson'},\n      {value: 'KML', viewValue: 'KML'},\n      {value: 'KMZ', viewValue: 'KMZ'}\n      // {value: \"TOPOJSON\", viewValue: \"TopoJSON\"}\n    ];\n    this.selectedValue = this.options[0].value;\n    this.loading = false;\n  }\n\n  public handleChange(change: MatSelectChange): void {\n    this.selectedValue = change.value;\n  }\n\n  /**\n   * Click handler to export given dataset objects\n   */\n  public click(): void {\n    console.debug('Clicked export', this.dataExport);\n    // If the input is undefined, or there are not individuals, skip\n    if ((this.dataExport !== undefined)) {\n      this.loading = true;\n\n      const exportArray = this.dataExport\n        .filter((de) => de.individuals.length > 0)\n        .map((de) => {\n          return this.es.exportIndividuals({\n            dataset: de.dataset,\n            individuals: de.individuals,\n            type: this.selectedValue\n          });\n        });\n      forkJoin(exportArray)\n        .pipe(finalize(() => this.loading = false))\n        .subscribe((exports) => {\n          exports.forEach((data) => {\n            console.debug('exported data:', data);\n            let fileName = '';\n            switch (this.selectedValue) {\n              case 'GEOJSON': {\n                fileName = 'trestle.json';\n                break;\n              }\n              case 'KML': {\n                fileName = 'trestle.kml';\n                break;\n              }\n              case 'KMZ': {\n                fileName = 'trestle.kmz';\n                break;\n              }\n              default: {\n                fileName = 'trestle.zip';\n                break;\n              }\n            }\n            saveAs(data, fileName);\n          });\n        });\n    }\n  }\n}\n",
            "properties": [
                {
                    "name": "dataset",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "individuals",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 10
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IDatasetState",
            "id": "interface-IDatasetState-6fa726ac636353c5cf4028cf8eafec10",
            "file": "src/main/webapp/src/app/explore/viewer/viewer.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, OnInit, ViewChild} from '@angular/core';\nimport {MapService} from './map.service';\nimport {animate, style, transition, trigger} from '@angular/animations';\nimport moment from \"moment\";\nimport {TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\nimport {Subject} from 'rxjs';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {IndividualService} from '../../shared/individual/individual.service';\nimport {MatSliderChange} from '@angular/material/slider';\nimport {DatasetService} from '../../shared/dataset/dataset.service';\nimport {IIndividualHistory} from '../../ui/history-graph/history-graph.component';\nimport {IDataExport} from '../exporter/exporter.component';\nimport {MapSource, TrestleMapComponent} from '../../ui/trestle-map/trestle-map.component';\n\nenum DatasetState {\n  UNLOADED,\n  LOADING,\n  LOADED,\n  ERROR\n}\n\ninterface IDatasetState {\n  name: string;\n  state: DatasetState;\n  error?: string;\n}\n\n@Component({\n  selector: 'dataset-viewer',\n  templateUrl: './viewer.component.html',\n  styleUrls: ['./viewer.component.scss'],\n  animations: [\n    trigger('fadeInOut', [\n      transition(':enter', [\n        style({transform: 'scale(0)', opacity: 0}),\n        animate('500ms', style({transform: 'scale(1)', opacity: 1}))\n      ]),\n    ])\n  ]\n})\nexport class ViewerComponent implements OnInit {\n  public availableDatasets: IDatasetState[] = [];\n  public DatasetState = DatasetState;\n  public minTime = moment('1990-01-01');\n  public maxTime = moment('2016-01-01');\n  public sliderValue = 2013;\n  public selectedIndividual: TrestleIndividual;\n  public objectHistory: IIndividualHistory;\n  public dataChanges: Subject<MapSource>;\n  public exportIndividuals: IDataExport[];\n  @ViewChild('map')\n  public map: TrestleMapComponent;\n  private mapBounds: LngLatBounds;\n\n  constructor(private mapService: MapService,\n              private is: IndividualService,\n              private ds: DatasetService) {\n    this.dataChanges = new Subject();\n    this.exportIndividuals = [];\n  }\n\n  public ngOnInit(): void {\n    this.objectHistory = {\n      entities: []\n    };\n    this.ds.getAvailableDatasets()\n      .subscribe((results: string[]) => {\n        results.forEach((ds) => {\n          this.availableDatasets.push({\n            name: ds,\n            state: DatasetState.UNLOADED\n          });\n        });\n      });\n  }\n\n  /**\n   * Load new data (or an entirely new dataset)\n   * If one's already loaded, unload it, unless we mark the keep flag\n   * @param {IDatasetState} dataset - dataset to load\n   * @param {boolean} keepLoaded - true if we need to keep the dataset loaded, false to unload it\n   */\n  public loadDataset(dataset: IDatasetState, keepLoaded = false): void {\n    if (dataset.state === DatasetState.LOADED && !keepLoaded) {\n      console.debug('Unloading dataset:', dataset.name);\n      this.map.removeIndividual('intersection-query');\n      dataset.state = DatasetState.UNLOADED;\n    } else {\n      console.debug('Loading:', dataset.name);\n      dataset.state = DatasetState.LOADING;\n      this.mapService.stIntersect(dataset.name,\n        this.mapBounds, moment()\n          .year(this.sliderValue)\n          .startOf('year'))\n        .subscribe((data) => {\n          dataset.state = DatasetState.LOADED;\n          console.debug('Data:', data);\n          // Get the list of individuals, for exporting\n          this.exportIndividuals.push({\n            dataset: this.availableDatasets[0].name,\n            individuals: (data.features\n              .filter((feature) => feature.id)\n              // We can do this cast, because we filter to make sure the features have an id\n              .map((feature) => feature.id) as string[])\n          });\n          this.dataChanges.next({\n            id: 'intersection-query',\n            idField: 'id',\n            labelField: 'objectName',\n            data\n          });\n        }, (error) => {\n          console.error('Error loading dataset:', error);\n          dataset.state = DatasetState.ERROR;\n          dataset.error = error;\n        });\n    }\n  }\n\n  /**\n   * Update map bounds, and fetch new data, if necessary\n   * @param {mapboxgl.LngLatBounds} bounds\n   */\n  public updateBounds(bounds: LngLatBounds): void {\n    console.debug('Moving, updating bounds', bounds);\n    // If we haven't loaded any datasets, keep resetting the map bounds\n    if (!this.availableDatasets.some((ds) => ds.state === DatasetState.LOADED)) {\n      this.mapBounds = bounds;\n    }\n\n    // If we've moved outside of the current bounds, get new data\n    if (this.needNewData(bounds)) {\n      this.mapBounds = bounds;\n      this.availableDatasets\n        .filter((ds) => ds.state === DatasetState.LOADED)\n        .forEach((ds) => this.loadDataset(ds, true));\n    }\n    // On the first time around, set the map bounds\n    if (!this.mapBounds) {\n      this.mapBounds = bounds;\n    }\n  }\n\n  /**\n   * Handler to update time slider, and fetch new data\n   * @param {MatSliderChange} event\n   */\n  public sliderChanged = (event: MatSliderChange): void => {\n    console.debug('Value changed to:', event);\n    if (event.value) {\n      this.sliderValue = event.value;\n      //    Reload all the currently loaded datasets\n      this.availableDatasets\n        .filter((ds) => ds.state === DatasetState.LOADED)\n        .forEach((ds) => this.loadDataset(ds, true));\n    }\n  };\n\n  /**\n   * Map click handler, which currently fetches the object as a {TrestleIndividual}\n   * @param {string} event\n   */\n  public mapClicked = (event: string): void => {\n    console.debug('Clicked:', event);\n    this.is.getTrestleIndividual(event)\n      .subscribe((data) => {\n        console.debug('Has selection', data);\n        this.selectedIndividual = data;\n      });\n  };\n\n  /**\n   * Get error from {IDatasetState}\n   * @param {IDatasetState} ds\n   * @returns {string}\n   */\n  public getError(ds: IDatasetState): string {\n    return ds.error === undefined ? 'Error' : ds.error;\n  }\n\n  private needNewData(newBounds: mapboxgl.LngLatBounds) {\n    console.debug('Need new data', newBounds, 'old Data', this.mapBounds);\n    // This short circuits the checks to avoid loading data on the first go 'round.\n    if (newBounds === null || this.mapBounds === undefined) {\n      return false;\n    }\n    // Moved up/down\n    if ((newBounds.getNorth() > this.mapBounds.getNorth())\n      || (newBounds.getSouth() < this.mapBounds.getSouth())) {\n      console.debug(newBounds.getNorth() + ', ' + this.mapBounds.getNorth());\n      console.debug(newBounds.getSouth() + ', ' + this.mapBounds.getSouth());\n      console.debug('Moved north/south, so true');\n      return true;\n      //    Moved east/west\n    } else if ((newBounds.getEast() > this.mapBounds.getEast())\n      || (newBounds.getWest() < this.mapBounds.getWest())) {\n      console.debug(newBounds.getEast() + ', ' + this.mapBounds.getEast());\n      console.debug(newBounds.getWest() + ', ' + this.mapBounds.getWest());\n      console.debug('Moved east/west, so true');\n    }\n    return false;\n  }\n}\n",
            "properties": [
                {
                    "name": "error",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 28
                },
                {
                    "name": "name",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "state",
                    "type": "DatasetState",
                    "optional": false,
                    "description": "",
                    "line": 27
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IEventData",
            "id": "interface-IEventData-ea0c561eeea2d6596a2cf4d50bd8a44d",
            "file": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChanges, ViewChild} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {scaleLinear, scaleOrdinal, scaleTime} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {axisBottom} from \"d3-axis\";\nimport {ID3Margin} from \"../common\";\n\nexport interface IEventElement {\n  id: string;\n  entity: string;\n  temporal: Date;\n  bin: number;\n  value: any;\n  continuing?: boolean;\n}\n\nexport interface IEventLink {\n  source: IEventElement;\n  target: IEventElement;\n}\n\nexport interface IEventData {\n  bins: number;\n  nodes: IEventElement[];\n  links: IEventLink[];\n}\n\n@Component({\n  selector: 'event-graph',\n  templateUrl: './event-graph.component.html',\n  styleUrls: ['./event-graph.component.scss']\n})\nexport class EventGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('graph') public element: ElementRef;\n  @ViewChild('tooltip') private tooltipEl: ElementRef;\n  @Input() public selectedIndividual: string;\n  @Input() public data: IEventData;\n  @Input() public graphHeight: number;\n  @Input() public graphWidth: number;\n  @Input() public minDate: Date;\n  @Input() public maxDate: Date;\n  @Input() public filterLabel?: (input: IEventElement) => string;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IEventElement | IEventLink, null, undefined>;\n  private svg: Selection<BaseType, IEventElement | IEventLink, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private tooltip: any;\n\n\n  public constructor() {\n\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n  }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    const dataChange = changes['data'];\n    if (dataChange.currentValue !== undefined\n      && (dataChange.currentValue !== dataChange.previousValue)) {\n      console.debug('Changed, plotting data', this.data);\n      this.plotData();\n    }\n  }\n\n  private plotData(): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    //    Setup the X/Y/Z values\n    const entityNames = this.data.nodes.map((d) => d.entity);\n    const x = scaleTime()\n      .range([120, this.width])\n      .domain([this.minDate, this.maxDate]);\n    const y = scaleLinear()\n      .range([this.height, 0])\n      .domain([0, this.data.bins]);\n    const z = scaleOrdinal(schemeCategory10)\n      .domain(entityNames);\n\n    // Filter down the events, to make sure they don't go off the screen\n    this.data.nodes.map((node) => {\n      if (node.temporal > this.maxDate) {\n        node.continuing = true;\n        node.temporal = this.maxDate;\n      } else if (node.temporal < this.minDate) {\n        node.continuing = true;\n        node.temporal = this.minDate;\n      }\n    });\n\n    // Let's draw a box around the selectHandler selection\n    const focusedIndividual = this.svg.selectAll<SVGRectElement, BaseType>('.selected')\n      .data(this.data.nodes\n          .filter((node) => node.entity === this.selectedIndividual),\n        (d: IEventElement) => d.entity);\n\n    // Calculate bin height\n    const binHeight = y(1) - y(2);\n\n    focusedIndividual\n      .enter()\n      .append('rect')\n      .attr('class', 'selected')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin + 1) + (binHeight / 2))\n      .attr('height', binHeight)\n      .attr('width', () => x(this.maxDate) + 120)\n      .attr('fill', '#FAFAD2')\n      .attr('opacity', '0.7')\n      .merge(focusedIndividual);\n\n    focusedIndividual\n      .exit()\n      .remove();\n\n    //    Add the lines\n    const links = this.svg\n      .selectAll<SVGLineElement, BaseType>('.link')\n      .data(this.data.links, (link: IEventLink) => link.source.id + '_' + link.target.id);\n\n    links\n      .enter()\n      .append('line')\n      .attr('class', 'link')\n      .attr('x1', (d) => x(d.source.temporal))\n      .attr('y1', (d) => y(d.source.bin) || null)\n      .attr('x2', (d) => x(d.target.temporal))\n      .attr('y2', (d) => y(d.target.bin) || null)\n      .merge(links);\n\n    links\n      .exit()\n      .remove();\n\n    //    Add the nodes to the graph\n    const nodes = this.svg\n      .selectAll<SVGCircleElement, BaseType>('.node')\n      .data(this.data.nodes, (data: IEventElement) => data.id);\n\n    nodes\n      .enter()\n      .append('circle')\n      .attr('class', 'node')\n      .attr('cx', (d) => x(d.temporal))\n      .attr('cy', (d) => y(d.bin) || null)\n      .attr('r', 9)\n      .attr('name', (d) => d.bin)\n      .attr('node-id', (d) => d.id)\n      .attr('entity', (d) => d.entity)\n      .style('fill', (d: IEventElement) => z(d.entity))\n      .style('opacity', (d) => d.continuing ? 0.7 : 1.0)\n      .merge(nodes);\n\n    nodes\n      .exit()\n      .remove();\n\n    // Add the labels\n    const mainLabels = this.svg.selectAll<SVGTextElement, BaseType>('.entityName')\n      .data(this.data.nodes, (d: IEventElement) => d.entity);\n\n    mainLabels\n      .enter()\n      .append('text')\n      .text((d) => this.applyFilter(d))\n      .attr('class', 'entityName')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin) || 0)\n      .attr('text-anchor', 'start')\n      .attr('dy', '.1ex')\n      .attr('font-size', '12px')\n      .merge(mainLabels);\n\n    mainLabels\n      .exit()\n      .remove();\n\n    //    Update the X-axis\n    const xSelection = this.svg.selectAll('g.x-axis');\n    if (xSelection.empty()) {\n      this.svg\n        .append('g')\n        .attr('class', 'axis x-axis')\n        .attr('transform', 'translate(0,' + this.height + ')')\n        .call(axisBottom(x));\n    } else {\n      xSelection\n        .call(axisBottom(x));\n    }\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IEventElement | IEventLink>(this.htmlElement);\n    console.debug('Width for event graph:', this.htmlElement.offsetWidth);\n    this.margin = {top: 20, right: 30, bottom: 20, left: 20};\n    // this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    // Calculate width\n    // If the element isn't actually on the screen, then the width will be 0 which is wrong\n    // So we'll either take it from the input, or just make something up\n    if (this.graphWidth === undefined) {\n      if (this.htmlElement.offsetWidth == 0) {\n        this.width = 800 - this.margin.left - this.margin.right;\n      } else {\n        this.width = (this.htmlElement.offsetWidth) - this.margin.left - this.margin.right;\n      }\n    } else {\n      this.width = this.graphWidth - this.margin.left - this.margin.right;\n    }\n\n    this.height = this.graphHeight - this.margin.top - this.margin.bottom;\n\n    // Add the tooltip\n    this.tooltip = select('body')\n      .append('div')\n      // .style(\"position\", \"absolute\")\n      .style('z-index', '10')\n      .style('visibility', 'hidden')\n      .style('background', 'steelblue')\n      .text('a simple tooltip');\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    console.debug('Event Graph Initialized');\n  }\n\n  /**\n   * Apply the filter function, if it exists, otherwise, return the entity as the label\n   * @param {IEventElement} input\n   * @returns {string}\n   */\n  private applyFilter = (input: IEventElement): string => {\n    if (this.filterLabel) {\n      return this.filterLabel(input);\n    } else {\n      return input.entity;\n    }\n  };\n\n\n}\n",
            "properties": [
                {
                    "name": "bins",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "links",
                    "type": "IEventLink[]",
                    "optional": false,
                    "description": "",
                    "line": 25
                },
                {
                    "name": "nodes",
                    "type": "IEventElement[]",
                    "optional": false,
                    "description": "",
                    "line": 24
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IEventElement",
            "id": "interface-IEventElement-ea0c561eeea2d6596a2cf4d50bd8a44d",
            "file": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChanges, ViewChild} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {scaleLinear, scaleOrdinal, scaleTime} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {axisBottom} from \"d3-axis\";\nimport {ID3Margin} from \"../common\";\n\nexport interface IEventElement {\n  id: string;\n  entity: string;\n  temporal: Date;\n  bin: number;\n  value: any;\n  continuing?: boolean;\n}\n\nexport interface IEventLink {\n  source: IEventElement;\n  target: IEventElement;\n}\n\nexport interface IEventData {\n  bins: number;\n  nodes: IEventElement[];\n  links: IEventLink[];\n}\n\n@Component({\n  selector: 'event-graph',\n  templateUrl: './event-graph.component.html',\n  styleUrls: ['./event-graph.component.scss']\n})\nexport class EventGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('graph') public element: ElementRef;\n  @ViewChild('tooltip') private tooltipEl: ElementRef;\n  @Input() public selectedIndividual: string;\n  @Input() public data: IEventData;\n  @Input() public graphHeight: number;\n  @Input() public graphWidth: number;\n  @Input() public minDate: Date;\n  @Input() public maxDate: Date;\n  @Input() public filterLabel?: (input: IEventElement) => string;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IEventElement | IEventLink, null, undefined>;\n  private svg: Selection<BaseType, IEventElement | IEventLink, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private tooltip: any;\n\n\n  public constructor() {\n\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n  }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    const dataChange = changes['data'];\n    if (dataChange.currentValue !== undefined\n      && (dataChange.currentValue !== dataChange.previousValue)) {\n      console.debug('Changed, plotting data', this.data);\n      this.plotData();\n    }\n  }\n\n  private plotData(): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    //    Setup the X/Y/Z values\n    const entityNames = this.data.nodes.map((d) => d.entity);\n    const x = scaleTime()\n      .range([120, this.width])\n      .domain([this.minDate, this.maxDate]);\n    const y = scaleLinear()\n      .range([this.height, 0])\n      .domain([0, this.data.bins]);\n    const z = scaleOrdinal(schemeCategory10)\n      .domain(entityNames);\n\n    // Filter down the events, to make sure they don't go off the screen\n    this.data.nodes.map((node) => {\n      if (node.temporal > this.maxDate) {\n        node.continuing = true;\n        node.temporal = this.maxDate;\n      } else if (node.temporal < this.minDate) {\n        node.continuing = true;\n        node.temporal = this.minDate;\n      }\n    });\n\n    // Let's draw a box around the selectHandler selection\n    const focusedIndividual = this.svg.selectAll<SVGRectElement, BaseType>('.selected')\n      .data(this.data.nodes\n          .filter((node) => node.entity === this.selectedIndividual),\n        (d: IEventElement) => d.entity);\n\n    // Calculate bin height\n    const binHeight = y(1) - y(2);\n\n    focusedIndividual\n      .enter()\n      .append('rect')\n      .attr('class', 'selected')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin + 1) + (binHeight / 2))\n      .attr('height', binHeight)\n      .attr('width', () => x(this.maxDate) + 120)\n      .attr('fill', '#FAFAD2')\n      .attr('opacity', '0.7')\n      .merge(focusedIndividual);\n\n    focusedIndividual\n      .exit()\n      .remove();\n\n    //    Add the lines\n    const links = this.svg\n      .selectAll<SVGLineElement, BaseType>('.link')\n      .data(this.data.links, (link: IEventLink) => link.source.id + '_' + link.target.id);\n\n    links\n      .enter()\n      .append('line')\n      .attr('class', 'link')\n      .attr('x1', (d) => x(d.source.temporal))\n      .attr('y1', (d) => y(d.source.bin) || null)\n      .attr('x2', (d) => x(d.target.temporal))\n      .attr('y2', (d) => y(d.target.bin) || null)\n      .merge(links);\n\n    links\n      .exit()\n      .remove();\n\n    //    Add the nodes to the graph\n    const nodes = this.svg\n      .selectAll<SVGCircleElement, BaseType>('.node')\n      .data(this.data.nodes, (data: IEventElement) => data.id);\n\n    nodes\n      .enter()\n      .append('circle')\n      .attr('class', 'node')\n      .attr('cx', (d) => x(d.temporal))\n      .attr('cy', (d) => y(d.bin) || null)\n      .attr('r', 9)\n      .attr('name', (d) => d.bin)\n      .attr('node-id', (d) => d.id)\n      .attr('entity', (d) => d.entity)\n      .style('fill', (d: IEventElement) => z(d.entity))\n      .style('opacity', (d) => d.continuing ? 0.7 : 1.0)\n      .merge(nodes);\n\n    nodes\n      .exit()\n      .remove();\n\n    // Add the labels\n    const mainLabels = this.svg.selectAll<SVGTextElement, BaseType>('.entityName')\n      .data(this.data.nodes, (d: IEventElement) => d.entity);\n\n    mainLabels\n      .enter()\n      .append('text')\n      .text((d) => this.applyFilter(d))\n      .attr('class', 'entityName')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin) || 0)\n      .attr('text-anchor', 'start')\n      .attr('dy', '.1ex')\n      .attr('font-size', '12px')\n      .merge(mainLabels);\n\n    mainLabels\n      .exit()\n      .remove();\n\n    //    Update the X-axis\n    const xSelection = this.svg.selectAll('g.x-axis');\n    if (xSelection.empty()) {\n      this.svg\n        .append('g')\n        .attr('class', 'axis x-axis')\n        .attr('transform', 'translate(0,' + this.height + ')')\n        .call(axisBottom(x));\n    } else {\n      xSelection\n        .call(axisBottom(x));\n    }\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IEventElement | IEventLink>(this.htmlElement);\n    console.debug('Width for event graph:', this.htmlElement.offsetWidth);\n    this.margin = {top: 20, right: 30, bottom: 20, left: 20};\n    // this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    // Calculate width\n    // If the element isn't actually on the screen, then the width will be 0 which is wrong\n    // So we'll either take it from the input, or just make something up\n    if (this.graphWidth === undefined) {\n      if (this.htmlElement.offsetWidth == 0) {\n        this.width = 800 - this.margin.left - this.margin.right;\n      } else {\n        this.width = (this.htmlElement.offsetWidth) - this.margin.left - this.margin.right;\n      }\n    } else {\n      this.width = this.graphWidth - this.margin.left - this.margin.right;\n    }\n\n    this.height = this.graphHeight - this.margin.top - this.margin.bottom;\n\n    // Add the tooltip\n    this.tooltip = select('body')\n      .append('div')\n      // .style(\"position\", \"absolute\")\n      .style('z-index', '10')\n      .style('visibility', 'hidden')\n      .style('background', 'steelblue')\n      .text('a simple tooltip');\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    console.debug('Event Graph Initialized');\n  }\n\n  /**\n   * Apply the filter function, if it exists, otherwise, return the entity as the label\n   * @param {IEventElement} input\n   * @returns {string}\n   */\n  private applyFilter = (input: IEventElement): string => {\n    if (this.filterLabel) {\n      return this.filterLabel(input);\n    } else {\n      return input.entity;\n    }\n  };\n\n\n}\n",
            "properties": [
                {
                    "name": "bin",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "continuing",
                    "type": "boolean",
                    "optional": true,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "entity",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "temporal",
                    "type": "Date",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "value",
                    "type": "any",
                    "optional": false,
                    "description": "",
                    "line": 13
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IEventLink",
            "id": "interface-IEventLink-ea0c561eeea2d6596a2cf4d50bd8a44d",
            "file": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChanges, ViewChild} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {scaleLinear, scaleOrdinal, scaleTime} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {axisBottom} from \"d3-axis\";\nimport {ID3Margin} from \"../common\";\n\nexport interface IEventElement {\n  id: string;\n  entity: string;\n  temporal: Date;\n  bin: number;\n  value: any;\n  continuing?: boolean;\n}\n\nexport interface IEventLink {\n  source: IEventElement;\n  target: IEventElement;\n}\n\nexport interface IEventData {\n  bins: number;\n  nodes: IEventElement[];\n  links: IEventLink[];\n}\n\n@Component({\n  selector: 'event-graph',\n  templateUrl: './event-graph.component.html',\n  styleUrls: ['./event-graph.component.scss']\n})\nexport class EventGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('graph') public element: ElementRef;\n  @ViewChild('tooltip') private tooltipEl: ElementRef;\n  @Input() public selectedIndividual: string;\n  @Input() public data: IEventData;\n  @Input() public graphHeight: number;\n  @Input() public graphWidth: number;\n  @Input() public minDate: Date;\n  @Input() public maxDate: Date;\n  @Input() public filterLabel?: (input: IEventElement) => string;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IEventElement | IEventLink, null, undefined>;\n  private svg: Selection<BaseType, IEventElement | IEventLink, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private tooltip: any;\n\n\n  public constructor() {\n\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n  }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    const dataChange = changes['data'];\n    if (dataChange.currentValue !== undefined\n      && (dataChange.currentValue !== dataChange.previousValue)) {\n      console.debug('Changed, plotting data', this.data);\n      this.plotData();\n    }\n  }\n\n  private plotData(): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    //    Setup the X/Y/Z values\n    const entityNames = this.data.nodes.map((d) => d.entity);\n    const x = scaleTime()\n      .range([120, this.width])\n      .domain([this.minDate, this.maxDate]);\n    const y = scaleLinear()\n      .range([this.height, 0])\n      .domain([0, this.data.bins]);\n    const z = scaleOrdinal(schemeCategory10)\n      .domain(entityNames);\n\n    // Filter down the events, to make sure they don't go off the screen\n    this.data.nodes.map((node) => {\n      if (node.temporal > this.maxDate) {\n        node.continuing = true;\n        node.temporal = this.maxDate;\n      } else if (node.temporal < this.minDate) {\n        node.continuing = true;\n        node.temporal = this.minDate;\n      }\n    });\n\n    // Let's draw a box around the selectHandler selection\n    const focusedIndividual = this.svg.selectAll<SVGRectElement, BaseType>('.selected')\n      .data(this.data.nodes\n          .filter((node) => node.entity === this.selectedIndividual),\n        (d: IEventElement) => d.entity);\n\n    // Calculate bin height\n    const binHeight = y(1) - y(2);\n\n    focusedIndividual\n      .enter()\n      .append('rect')\n      .attr('class', 'selected')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin + 1) + (binHeight / 2))\n      .attr('height', binHeight)\n      .attr('width', () => x(this.maxDate) + 120)\n      .attr('fill', '#FAFAD2')\n      .attr('opacity', '0.7')\n      .merge(focusedIndividual);\n\n    focusedIndividual\n      .exit()\n      .remove();\n\n    //    Add the lines\n    const links = this.svg\n      .selectAll<SVGLineElement, BaseType>('.link')\n      .data(this.data.links, (link: IEventLink) => link.source.id + '_' + link.target.id);\n\n    links\n      .enter()\n      .append('line')\n      .attr('class', 'link')\n      .attr('x1', (d) => x(d.source.temporal))\n      .attr('y1', (d) => y(d.source.bin) || null)\n      .attr('x2', (d) => x(d.target.temporal))\n      .attr('y2', (d) => y(d.target.bin) || null)\n      .merge(links);\n\n    links\n      .exit()\n      .remove();\n\n    //    Add the nodes to the graph\n    const nodes = this.svg\n      .selectAll<SVGCircleElement, BaseType>('.node')\n      .data(this.data.nodes, (data: IEventElement) => data.id);\n\n    nodes\n      .enter()\n      .append('circle')\n      .attr('class', 'node')\n      .attr('cx', (d) => x(d.temporal))\n      .attr('cy', (d) => y(d.bin) || null)\n      .attr('r', 9)\n      .attr('name', (d) => d.bin)\n      .attr('node-id', (d) => d.id)\n      .attr('entity', (d) => d.entity)\n      .style('fill', (d: IEventElement) => z(d.entity))\n      .style('opacity', (d) => d.continuing ? 0.7 : 1.0)\n      .merge(nodes);\n\n    nodes\n      .exit()\n      .remove();\n\n    // Add the labels\n    const mainLabels = this.svg.selectAll<SVGTextElement, BaseType>('.entityName')\n      .data(this.data.nodes, (d: IEventElement) => d.entity);\n\n    mainLabels\n      .enter()\n      .append('text')\n      .text((d) => this.applyFilter(d))\n      .attr('class', 'entityName')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin) || 0)\n      .attr('text-anchor', 'start')\n      .attr('dy', '.1ex')\n      .attr('font-size', '12px')\n      .merge(mainLabels);\n\n    mainLabels\n      .exit()\n      .remove();\n\n    //    Update the X-axis\n    const xSelection = this.svg.selectAll('g.x-axis');\n    if (xSelection.empty()) {\n      this.svg\n        .append('g')\n        .attr('class', 'axis x-axis')\n        .attr('transform', 'translate(0,' + this.height + ')')\n        .call(axisBottom(x));\n    } else {\n      xSelection\n        .call(axisBottom(x));\n    }\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IEventElement | IEventLink>(this.htmlElement);\n    console.debug('Width for event graph:', this.htmlElement.offsetWidth);\n    this.margin = {top: 20, right: 30, bottom: 20, left: 20};\n    // this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    // Calculate width\n    // If the element isn't actually on the screen, then the width will be 0 which is wrong\n    // So we'll either take it from the input, or just make something up\n    if (this.graphWidth === undefined) {\n      if (this.htmlElement.offsetWidth == 0) {\n        this.width = 800 - this.margin.left - this.margin.right;\n      } else {\n        this.width = (this.htmlElement.offsetWidth) - this.margin.left - this.margin.right;\n      }\n    } else {\n      this.width = this.graphWidth - this.margin.left - this.margin.right;\n    }\n\n    this.height = this.graphHeight - this.margin.top - this.margin.bottom;\n\n    // Add the tooltip\n    this.tooltip = select('body')\n      .append('div')\n      // .style(\"position\", \"absolute\")\n      .style('z-index', '10')\n      .style('visibility', 'hidden')\n      .style('background', 'steelblue')\n      .text('a simple tooltip');\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    console.debug('Event Graph Initialized');\n  }\n\n  /**\n   * Apply the filter function, if it exists, otherwise, return the entity as the label\n   * @param {IEventElement} input\n   * @returns {string}\n   */\n  private applyFilter = (input: IEventElement): string => {\n    if (this.filterLabel) {\n      return this.filterLabel(input);\n    } else {\n      return input.entity;\n    }\n  };\n\n\n}\n",
            "properties": [
                {
                    "name": "source",
                    "type": "IEventElement",
                    "optional": false,
                    "description": "",
                    "line": 18
                },
                {
                    "name": "target",
                    "type": "IEventElement",
                    "optional": false,
                    "description": "",
                    "line": 19
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IExportRequest",
            "id": "interface-IExportRequest-b921c60b5c0562fa659d144dfa66aafb",
            "file": "src/main/webapp/src/app/explore/exporter/exporter.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from \"@angular/core\";\nimport {Observable} from 'rxjs';\nimport {HttpClient} from '@angular/common/http';\n\nexport interface IExportRequest {\n    dataset: string;\n    individuals: string[];\n    type: string;\n}\n\n@Injectable()\nexport class ExporterService {\n\n    constructor(private http: HttpClient) {\n\n    }\n\n    /**\n     * Export indivduals and return the built result from the database\n     * @param {IExportRequest} request\n     * @returns {Observable<Blob>}\n     */\n    public exportIndividuals(request: IExportRequest): Observable<Blob> {\n        return this.http.post(\"/export\", request, {\n            responseType: 'blob'\n        });\n    }\n}\n",
            "properties": [
                {
                    "name": "dataset",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "individuals",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "type",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IFactNode",
            "id": "interface-IFactNode-d838f5efb91e80799d08955b6677568c",
            "file": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  Input,\n  OnChanges,\n  SimpleChange,\n  ViewChild,\n  ViewEncapsulation\n} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {ScaleOrdinal, scaleOrdinal} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {\n  forceCenter,\n  forceLink,\n  forceManyBody,\n  forceSimulation,\n  Simulation,\n  SimulationLinkDatum,\n  SimulationNodeDatum\n} from \"d3-force\";\nimport * as moment from \"moment\";\nimport {TrestleIndividual} from \"../../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject} from \"rxjs\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\nexport interface IIndividualConfig {\n  data: TrestleIndividual;\n  validAt: moment.Moment;\n  dbAt?: moment.Moment;\n}\n\nconst enum NodeType {\n  INDIVIDUAL,\n  VTEMPORAL,\n  FACT,\n  RELATION\n}\n\ninterface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\ninterface IGraphLayout {\n  nodes: IFactNode[];\n  links: Array<SimulationLinkDatum<IFactNode>>;\n}\n\ninterface IFactNode extends SimulationNodeDatum {\n  id: string;\n  name: string;\n  valid: boolean;\n  group: number;\n}\n\n@Component({\n  selector: 'individual-graph',\n  templateUrl: './individual-graph.component.html',\n  styleUrls: ['./individual-graph.component.scss'],\n  encapsulation: ViewEncapsulation.None\n})\n\nexport class IndividualGraphComponent implements AfterViewInit, OnChanges {\n\n  @ViewChild('container') public element: ElementRef;\n  @Input() public config: IIndividualConfig;\n\n  public factToggleName = 'fact-toggle';\n  public relationToggleName = 'relation-toggle';\n  public graphFacts = true;\n  public graphRelations = false;\n\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IFactNode, null, undefined>;\n  private svg: Selection<BaseType, IFactNode, null, undefined>;\n  private margin: ID3Margin;\n  private height: number;\n  private width: number;\n  private color: ScaleOrdinal<string, string>;\n  private layout: IGraphLayout;\n  private links: Selection<BaseType, SimulationLinkDatum<IFactNode>, any, any>;\n  private nodes: Selection<any, IFactNode, any, any>;\n  private simulation: Simulation<IFactNode, any>;\n  private nodeSize: number;\n  private nodeSizeLarge: number;\n  private dataChanges: BehaviorSubject<IIndividualConfig | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    console.debug('graph view-init');\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n    //    Subscribe\n    this.dataChanges\n      .subscribe((value) => {\n        if (value !== undefined) {\n          this.buildGraph(value);\n          this.update({\n            nodes: [],\n            links: [],\n          });\n          this.update(this.layout);\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const configChange = changes['config'];\n    console.debug('Changed', configChange);\n    if (configChange.currentValue !== configChange.previousValue) {\n      console.debug('Config changed', configChange);\n      this.dataChanges.next(configChange.currentValue);\n    }\n  }\n\n  private setupD3() {\n    this.host = select<HTMLElement, IFactNode>(this.htmlElement);\n    this.margin = {top: 10, right: 20, bottom: 10, left: 10};\n    console.debug('offsetWidth', this.htmlElement.offsetWidth);\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n    this.nodeSize = this.width / 75;\n    this.nodeSizeLarge = this.width / 50;\n    console.debug('Creating D3 graph with width/height', this.width + '/' + this.height);\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.color = scaleOrdinal(schemeCategory10);\n    console.debug('D3 initialized');\n  }\n\n  private update(data: IGraphLayout): void {\n    console.debug('Data in update function', data);\n    const force = forceManyBody();\n    force.strength(-1000);\n    this.simulation = forceSimulation<IFactNode>()\n      .force('link', forceLink().id((d: IFactNode) => d.id))\n      .force('charge', force)\n      .force('center', forceCenter(this.width / 2, this.height / 2));\n\n    const linkData = this.svg.selectAll('.link')\n      .data(data.links, (d: any) => d.source.id + '_' + d.target.id);\n\n    this.links = linkData.enter()\n      .append('line')\n      .attr('class', 'link');\n\n    const nodeData = this.svg.selectAll('.node')\n      .data(data.nodes, (d: IFactNode) => d.id);\n\n    this.nodes = nodeData\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .on('click', this.nodeClick)\n      .on('mouseover', this.nodeMouseOver)\n      .on('mouseout', this.nodeMouseOut);\n\n    this.nodes\n      .append('circle')\n      .attr('r', this.nodeSize)\n      .style('fill', (d) => this.color(d.group.toString(10)))\n      .style('opacity', (d) => d.valid ? 1.0 : 0.5);\n\n    this.nodes\n      .append('text')\n      .attr('x', 16)\n      .attr('dy', '.35em')\n      .text((d) => d.name);\n\n    //    Legend\n    const legend = this.svg.selectAll('.legend')\n      .data(this.color.domain())\n      .enter()\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', (d, i) => 'translate(0,' + (i * ((this.nodeSize) * 2) + 20) + ')');\n\n    legend.append('circle')\n      .attr('cx', this.width - 18)\n      .attr('r', this.nodeSize)\n      .attr('cy', this.nodeSize)\n      .style('fill', this.color);\n\n    legend\n      .append('text')\n      .attr('x', this.width - (this.nodeSize) * 2 - 12)\n      .attr('y', this.nodeSize)\n      .attr('dy', '0.35em')\n      .style('text-anchor', 'end')\n      .text((d) => IndividualGraphComponent.parseColorGroup(d));\n    // Force setup\n    this.simulation\n      .nodes(data.nodes)\n      .on('tick', this.forceTick);\n\n    // For some reason, the links() function doesn't exist on the simulation type, so we do a simple cast to get around it.\n    // Seems to work, and the only other option is to lose all type checking for the simulation object\n    (this.simulation.force('link') as any).links(data.links);\n\n    linkData.exit().remove();\n    nodeData.exit().remove();\n  }\n\n  private nodeClick = (d: IFactNode): void => {\n    console.debug('Clicked', d);\n  };\n\n  private nodeMouseOver = (event: any): void => {\n    select(event.currentTarget).select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSizeLarge);\n  };\n\n  private nodeMouseOut = (event: any): void => {\n    select(event.currentTarget)\n      .select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSize);\n  };\n\n  private forceTick = (): void => {\n    this.nodes\n      .attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')');\n\n    this.links\n      .attr('x1', (d: any) => d.source.x)\n      .attr('y1', (d: any) => d.source.y)\n      .attr('x2', (d: any) => d.target.x)\n      .attr('y2', (d: any) => d.target.y);\n  };\n\n  private buildGraph(config: IIndividualConfig): void {\n    const individual = config.data;\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n\n    //    Add the selection as node 0\n    const individualNode = {\n      id: individual.getID(),\n      name: IndividualGraphComponent.parseIndividualID(individual.getID()),\n      valid: true,\n      group: NodeType.INDIVIDUAL\n    };\n\n    const individualTemporal = {\n      id: individual.getTemporal().getID(),\n      name: 'selection-temporal',\n      valid: true,\n      group: NodeType.VTEMPORAL\n    };\n\n    this.layout.nodes.push(individualNode, individualTemporal);\n\n    this.layout.links.push({\n      source: individualNode,\n      target: individualTemporal\n    });\n\n    if (this.graphFacts) {\n      individual.getFacts().forEach(fact => {\n        const factNode = {\n          id: fact.getID(),\n          name: fact.getName(),\n          valid: fact.isActive(config.validAt, config.dbAt),\n          group: NodeType.FACT\n        };\n        this.layout.nodes.push(factNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: factNode\n        });\n      });\n    }\n\n    //    Relations\n    if (this.graphRelations) {\n      individual.getRelations().forEach(relation => {\n        const relationNode = {\n          id: relation.getObject(),\n          name: relation.getType().toString() + ': ' + IndividualGraphComponent.parseIndividualID(relation.getObject()),\n          valid: true,\n          group: NodeType.RELATION\n        };\n        this.layout.nodes.push(relationNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: relationNode\n        });\n      });\n    }\n  }\n\n  public changeGraphMembers(event: MatSlideToggleChange): void {\n    if (event.source.id === this.factToggleName) {\n      console.debug('Graph facts?', event.checked);\n      this.graphFacts = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    } else if (event.source.id === this.relationToggleName) {\n      console.debug('Graph relations?', event.checked);\n      this.graphRelations = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    }\n  }\n\n  private static parseColorGroup(group: string): string {\n    switch (parseInt(group, 10)) {\n      case 0:\n        return 'Individual';\n      case 1:\n        return 'Valid Temporal';\n      case 2:\n        return 'Fact';\n      case 3:\n        return 'Relation';\n      default:\n        return 'unknown';\n    }\n  }\n\n  private static parseIndividualID(id: string): string {\n    const matches = id.match(/(#)(.*)/g);\n    if (matches) {\n      return matches[0].replace('#', '');\n    }\n    return id;\n  }\n}\n",
            "properties": [
                {
                    "name": "group",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 57
                },
                {
                    "name": "name",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "valid",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 59
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "extends": "SimulationNodeDatum"
        },
        {
            "name": "IGraphHeader",
            "id": "interface-IGraphHeader-4bbe3c61bc8ee2fd14063cc86d055136",
            "file": "src/main/webapp/src/app/admin/indicies/tree-graph/tree-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  Output,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation\n} from '@angular/core';\nimport {ScaleLinear, scaleLinear} from 'd3-scale';\nimport {BaseType, select, Selection} from 'd3-selection';\nimport moment, {Moment} from 'moment';\nimport {axisBottom, axisLeft} from 'd3-axis';\nimport {IIndexLeafStatistics} from '../index.service';\nimport {interpolateHsl} from 'd3-interpolate';\nimport {ID3Margin} from '../../../ui/common';\nimport {BehaviorSubject, Subject} from 'rxjs';\nimport {RoundingPipe} from '../../../shared/pipes/rounding-pipe.pipe';\n\nexport interface IGraphHeader {\n  maxValue: number;\n  offsetValue: number;\n  leafs: IIndexLeafStatistics[];\n}\n\n@Component({\n  selector: 'tree-graph',\n  templateUrl: './tree-graph.component.html',\n  styleUrls: ['./tree-graph.component.scss'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class TreeGraphComponent implements AfterViewInit, OnChanges {\n\n  @ViewChild('graph')\n  public element: ElementRef;\n  @Input()\n  public data: IGraphHeader;\n  @Output()\n  public hovered: EventEmitter<string>;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IIndexLeafStatistics, null, undefined>;\n  private svg: Selection<BaseType, IIndexLeafStatistics, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private maxTime: Moment;\n  private x: ScaleLinear<number, number>;\n  private y: ScaleLinear<number, number>;\n  private colorScale: (value: number) => string;\n  private dataSubject: Subject<IGraphHeader | undefined>;\n  private rounder: RoundingPipe;\n\n  public constructor() {\n    this.maxTime = moment('5000-01-01').startOf('year');\n    this.colorScale = interpolateHsl('steelblue', 'brown');\n    this.rounder = new RoundingPipe();\n    this.hovered = new EventEmitter<string>();\n    this.dataSubject = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n\n    //    Subscribe\n    this.dataSubject\n      .subscribe((value) => {\n        if (value !== undefined) {\n          this.plotData(value);\n          this.data = value;\n        }\n      });\n  }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    const dataChanges = changes['data'];\n    if (dataChanges.currentValue !== dataChanges.previousValue) {\n      console.debug('Plotting new changes');\n      this.dataSubject.next(dataChanges.currentValue);\n    }\n  }\n\n  private plotData(data: IGraphHeader): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    // Calculate the max time, which need to adjust from the cache values\n    this.maxTime = moment(data.maxValue - data.offsetValue);\n\n    console.debug('Plotting with max: %s and offset: %s', data.maxValue, data.offsetValue);\n\n    // Set the X/Y scales\n    this.x = scaleLinear().range([0, this.width]);\n    this.x.domain([0, data.maxValue]);\n    // We need to invert this, in order to get the triangles to draw in the correct direction\n    this.y = scaleLinear().range([this.height, 0]);\n    this.y.domain([0, data.maxValue]);\n\n    // Add the axises\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x)\n        .tickFormat((d) => TreeGraphComponent.adjustTemporals(d, data.offsetValue)))\n      .selectAll('text')\n      .attr('y', 0)\n      .attr('x', 9)\n      .attr('dy', '.35em')\n      .attr('transform', 'rotate(45)')\n      .style('text-anchor', 'start');\n\n    this.svg\n      .append('g')\n      .attr('class', 'axis axis-y')\n      .call(axisLeft(this.y)\n        .tickFormat((d) => TreeGraphComponent.adjustTemporals(d, data.offsetValue)))\n      .selectAll('text')\n      .attr('y', 0)\n      .attr('x', -10)\n      .attr('dy', '.35em')\n      .style('text-anchor', 'end');\n\n    //    Draw a line\n    // this.svg\n    //     .append(\"g\")\n    //     .attr(\"class\", \"dividing-line\")\n    //     .append(\"line\")\n    //     .attr(\"x1\", 0)\n    //     .attr(\"x2\", this.x(data.maxValue))\n    //     // .attr(\"y1\", this.height)\n    //     .attr(\"y1\", this.height)\n    //     .attr(\"y2\", 0)\n    //     .attr(\"stroke-width\", 3)\n    //     .attr(\"stroke\", \"black\");\n\n\n    //    For each, leaf, draw the triangle\n    const leafData = this.svg\n      .selectAll<SVGPolygonElement, BaseType>('.leaf')\n      // This index function needs to be a string, for some reason\n      .data(data.leafs, (d: IIndexLeafStatistics) => d.binaryID);\n\n    leafData\n      .enter()\n      .append('polygon')\n      .attr('id', (d) => d.binaryID)\n      .attr('direction', (d) => d.direction.toString())\n      .attr('coords', (d) => d.coordinates.join(','))\n      .attr('class', 'leaf')\n      .attr('points', (d) => this.normalizeTriangle(d.coordinates))\n      .attr('stroke-width', 1)\n      .attr('stroke', 'black')\n      // .attr(\"fill\", (d) => this.colorScale((d.records / 20) + 0.01))\n      .attr('fill', 'blue')\n      .style('fill-opacity', 0.7)\n      // Hover handlers\n      .on('mouseover', this.hoverHandler)\n      .merge(leafData);\n\n  }\n\n  private hoverHandler = (d: IIndexLeafStatistics): void => {\n    console.debug('Hovered', d.leafID.toString());\n    this.hovered.next(d.leafID.toString());\n  };\n\n  /**\n   * Normalize coordinates (represented as millis from UTC epoch) into D3 coordinates\n   * @param {number[]} coordinates\n   * @returns {string}\n   */\n  private normalizeTriangle(coordinates: number[]): string {\n    const size = coordinates.length;\n    const normalized = new Array(size);\n    let isX = true;\n    for (let idx = 0; idx < size; idx++) {\n      // console.debug(\"Rounding %s to %s\", coordinates[idx], this.rounder.transform(coordinates[idx], 0));\n      const rounded = this.rounder.transform(coordinates[idx], 0);\n      normalized[idx] = isX ? this.x(rounded) : this.y(rounded);\n      isX = !isX;\n    }\n    return normalized.join(',');\n  }\n\n  private static adjustTemporals(domain: any, offsetValue: number): string {\n    return new Date(domain - offsetValue).toISOString();\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IIndexLeafStatistics>(this.htmlElement);\n    this.margin = this.margin = {top: 20, right: 30, bottom: 100, left: 150};\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n  }\n}\n",
            "properties": [
                {
                    "name": "leafs",
                    "type": "IIndexLeafStatistics[]",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "maxValue",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "offsetValue",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 25
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IGraphLayout",
            "id": "interface-IGraphLayout-d838f5efb91e80799d08955b6677568c",
            "file": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  Input,\n  OnChanges,\n  SimpleChange,\n  ViewChild,\n  ViewEncapsulation\n} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {ScaleOrdinal, scaleOrdinal} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {\n  forceCenter,\n  forceLink,\n  forceManyBody,\n  forceSimulation,\n  Simulation,\n  SimulationLinkDatum,\n  SimulationNodeDatum\n} from \"d3-force\";\nimport * as moment from \"moment\";\nimport {TrestleIndividual} from \"../../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject} from \"rxjs\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\nexport interface IIndividualConfig {\n  data: TrestleIndividual;\n  validAt: moment.Moment;\n  dbAt?: moment.Moment;\n}\n\nconst enum NodeType {\n  INDIVIDUAL,\n  VTEMPORAL,\n  FACT,\n  RELATION\n}\n\ninterface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\ninterface IGraphLayout {\n  nodes: IFactNode[];\n  links: Array<SimulationLinkDatum<IFactNode>>;\n}\n\ninterface IFactNode extends SimulationNodeDatum {\n  id: string;\n  name: string;\n  valid: boolean;\n  group: number;\n}\n\n@Component({\n  selector: 'individual-graph',\n  templateUrl: './individual-graph.component.html',\n  styleUrls: ['./individual-graph.component.scss'],\n  encapsulation: ViewEncapsulation.None\n})\n\nexport class IndividualGraphComponent implements AfterViewInit, OnChanges {\n\n  @ViewChild('container') public element: ElementRef;\n  @Input() public config: IIndividualConfig;\n\n  public factToggleName = 'fact-toggle';\n  public relationToggleName = 'relation-toggle';\n  public graphFacts = true;\n  public graphRelations = false;\n\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IFactNode, null, undefined>;\n  private svg: Selection<BaseType, IFactNode, null, undefined>;\n  private margin: ID3Margin;\n  private height: number;\n  private width: number;\n  private color: ScaleOrdinal<string, string>;\n  private layout: IGraphLayout;\n  private links: Selection<BaseType, SimulationLinkDatum<IFactNode>, any, any>;\n  private nodes: Selection<any, IFactNode, any, any>;\n  private simulation: Simulation<IFactNode, any>;\n  private nodeSize: number;\n  private nodeSizeLarge: number;\n  private dataChanges: BehaviorSubject<IIndividualConfig | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    console.debug('graph view-init');\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n    //    Subscribe\n    this.dataChanges\n      .subscribe((value) => {\n        if (value !== undefined) {\n          this.buildGraph(value);\n          this.update({\n            nodes: [],\n            links: [],\n          });\n          this.update(this.layout);\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const configChange = changes['config'];\n    console.debug('Changed', configChange);\n    if (configChange.currentValue !== configChange.previousValue) {\n      console.debug('Config changed', configChange);\n      this.dataChanges.next(configChange.currentValue);\n    }\n  }\n\n  private setupD3() {\n    this.host = select<HTMLElement, IFactNode>(this.htmlElement);\n    this.margin = {top: 10, right: 20, bottom: 10, left: 10};\n    console.debug('offsetWidth', this.htmlElement.offsetWidth);\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n    this.nodeSize = this.width / 75;\n    this.nodeSizeLarge = this.width / 50;\n    console.debug('Creating D3 graph with width/height', this.width + '/' + this.height);\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.color = scaleOrdinal(schemeCategory10);\n    console.debug('D3 initialized');\n  }\n\n  private update(data: IGraphLayout): void {\n    console.debug('Data in update function', data);\n    const force = forceManyBody();\n    force.strength(-1000);\n    this.simulation = forceSimulation<IFactNode>()\n      .force('link', forceLink().id((d: IFactNode) => d.id))\n      .force('charge', force)\n      .force('center', forceCenter(this.width / 2, this.height / 2));\n\n    const linkData = this.svg.selectAll('.link')\n      .data(data.links, (d: any) => d.source.id + '_' + d.target.id);\n\n    this.links = linkData.enter()\n      .append('line')\n      .attr('class', 'link');\n\n    const nodeData = this.svg.selectAll('.node')\n      .data(data.nodes, (d: IFactNode) => d.id);\n\n    this.nodes = nodeData\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .on('click', this.nodeClick)\n      .on('mouseover', this.nodeMouseOver)\n      .on('mouseout', this.nodeMouseOut);\n\n    this.nodes\n      .append('circle')\n      .attr('r', this.nodeSize)\n      .style('fill', (d) => this.color(d.group.toString(10)))\n      .style('opacity', (d) => d.valid ? 1.0 : 0.5);\n\n    this.nodes\n      .append('text')\n      .attr('x', 16)\n      .attr('dy', '.35em')\n      .text((d) => d.name);\n\n    //    Legend\n    const legend = this.svg.selectAll('.legend')\n      .data(this.color.domain())\n      .enter()\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', (d, i) => 'translate(0,' + (i * ((this.nodeSize) * 2) + 20) + ')');\n\n    legend.append('circle')\n      .attr('cx', this.width - 18)\n      .attr('r', this.nodeSize)\n      .attr('cy', this.nodeSize)\n      .style('fill', this.color);\n\n    legend\n      .append('text')\n      .attr('x', this.width - (this.nodeSize) * 2 - 12)\n      .attr('y', this.nodeSize)\n      .attr('dy', '0.35em')\n      .style('text-anchor', 'end')\n      .text((d) => IndividualGraphComponent.parseColorGroup(d));\n    // Force setup\n    this.simulation\n      .nodes(data.nodes)\n      .on('tick', this.forceTick);\n\n    // For some reason, the links() function doesn't exist on the simulation type, so we do a simple cast to get around it.\n    // Seems to work, and the only other option is to lose all type checking for the simulation object\n    (this.simulation.force('link') as any).links(data.links);\n\n    linkData.exit().remove();\n    nodeData.exit().remove();\n  }\n\n  private nodeClick = (d: IFactNode): void => {\n    console.debug('Clicked', d);\n  };\n\n  private nodeMouseOver = (event: any): void => {\n    select(event.currentTarget).select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSizeLarge);\n  };\n\n  private nodeMouseOut = (event: any): void => {\n    select(event.currentTarget)\n      .select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSize);\n  };\n\n  private forceTick = (): void => {\n    this.nodes\n      .attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')');\n\n    this.links\n      .attr('x1', (d: any) => d.source.x)\n      .attr('y1', (d: any) => d.source.y)\n      .attr('x2', (d: any) => d.target.x)\n      .attr('y2', (d: any) => d.target.y);\n  };\n\n  private buildGraph(config: IIndividualConfig): void {\n    const individual = config.data;\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n\n    //    Add the selection as node 0\n    const individualNode = {\n      id: individual.getID(),\n      name: IndividualGraphComponent.parseIndividualID(individual.getID()),\n      valid: true,\n      group: NodeType.INDIVIDUAL\n    };\n\n    const individualTemporal = {\n      id: individual.getTemporal().getID(),\n      name: 'selection-temporal',\n      valid: true,\n      group: NodeType.VTEMPORAL\n    };\n\n    this.layout.nodes.push(individualNode, individualTemporal);\n\n    this.layout.links.push({\n      source: individualNode,\n      target: individualTemporal\n    });\n\n    if (this.graphFacts) {\n      individual.getFacts().forEach(fact => {\n        const factNode = {\n          id: fact.getID(),\n          name: fact.getName(),\n          valid: fact.isActive(config.validAt, config.dbAt),\n          group: NodeType.FACT\n        };\n        this.layout.nodes.push(factNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: factNode\n        });\n      });\n    }\n\n    //    Relations\n    if (this.graphRelations) {\n      individual.getRelations().forEach(relation => {\n        const relationNode = {\n          id: relation.getObject(),\n          name: relation.getType().toString() + ': ' + IndividualGraphComponent.parseIndividualID(relation.getObject()),\n          valid: true,\n          group: NodeType.RELATION\n        };\n        this.layout.nodes.push(relationNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: relationNode\n        });\n      });\n    }\n  }\n\n  public changeGraphMembers(event: MatSlideToggleChange): void {\n    if (event.source.id === this.factToggleName) {\n      console.debug('Graph facts?', event.checked);\n      this.graphFacts = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    } else if (event.source.id === this.relationToggleName) {\n      console.debug('Graph relations?', event.checked);\n      this.graphRelations = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    }\n  }\n\n  private static parseColorGroup(group: string): string {\n    switch (parseInt(group, 10)) {\n      case 0:\n        return 'Individual';\n      case 1:\n        return 'Valid Temporal';\n      case 2:\n        return 'Fact';\n      case 3:\n        return 'Relation';\n      default:\n        return 'unknown';\n    }\n  }\n\n  private static parseIndividualID(id: string): string {\n    const matches = id.match(/(#)(.*)/g);\n    if (matches) {\n      return matches[0].replace('#', '');\n    }\n    return id;\n  }\n}\n",
            "properties": [
                {
                    "name": "links",
                    "type": "Array<SimulationLinkDatum<IFactNode>>",
                    "optional": false,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "nodes",
                    "type": "IFactNode[]",
                    "optional": false,
                    "description": "",
                    "line": 52
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IIndexLeafStatistics",
            "id": "interface-IIndexLeafStatistics-2af1f1b55678fcfc2e51e62f69864cba",
            "file": "src/main/webapp/src/app/admin/indicies/index.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {Observable} from 'rxjs';\n\nexport interface IIndexLeafStatistics {\n  binaryID: string;\n  type: string;\n  coordinates: number[];\n  leafID: number;\n  direction: number;\n  records: number;\n}\n\nexport interface ICacheStatistics {\n  offsetValue: number;\n  maxValue: number;\n  dbIndexFragmentation: number;\n  dbIndexSize: number;\n  dbLeafStats: IIndexLeafStatistics[];\n  validIndexFragmentation: number;\n  validIndexSize: number;\n  validLeafStats: IIndexLeafStatistics[];\n}\n\n@Injectable()\nexport class IndexService {\n\n  private readonly baseUrl: string;\n\n  public constructor(private http: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get statistics for both caches\n   * @returns {Observable<ICacheStatistics>}\n   */\n  public getIndexStatistics(): Observable<ICacheStatistics> {\n    return this.http\n      .get<ICacheStatistics>(this.baseUrl + '/cache/index');\n  }\n\n  /**\n   * Rebuild specified index\n   * @param {string} index to rebuild\n   * @returns {Observable<void>}\n   */\n  public rebuildIndex(index: string): Observable<void> {\n    return this.http\n      .get<void>(this.baseUrl + '/cache/rebuild/' + index.toLocaleLowerCase());\n  }\n\n  /**\n   * Purge the specified index\n   * @param {string} cache to purge\n   * @returns {Observable<void>}\n   */\n  public purgeCache(cache: string): Observable<void> {\n    return this.http\n      .get<void>(this.baseUrl + '/cache/purge/' + cache.toLocaleLowerCase());\n  }\n}\n",
            "properties": [
                {
                    "name": "binaryID",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "coordinates",
                    "type": "number[]",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "direction",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "leafID",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "records",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "type",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IIndividualConfig",
            "id": "interface-IIndividualConfig-d838f5efb91e80799d08955b6677568c",
            "file": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  Input,\n  OnChanges,\n  SimpleChange,\n  ViewChild,\n  ViewEncapsulation\n} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {ScaleOrdinal, scaleOrdinal} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {\n  forceCenter,\n  forceLink,\n  forceManyBody,\n  forceSimulation,\n  Simulation,\n  SimulationLinkDatum,\n  SimulationNodeDatum\n} from \"d3-force\";\nimport * as moment from \"moment\";\nimport {TrestleIndividual} from \"../../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject} from \"rxjs\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\nexport interface IIndividualConfig {\n  data: TrestleIndividual;\n  validAt: moment.Moment;\n  dbAt?: moment.Moment;\n}\n\nconst enum NodeType {\n  INDIVIDUAL,\n  VTEMPORAL,\n  FACT,\n  RELATION\n}\n\ninterface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\ninterface IGraphLayout {\n  nodes: IFactNode[];\n  links: Array<SimulationLinkDatum<IFactNode>>;\n}\n\ninterface IFactNode extends SimulationNodeDatum {\n  id: string;\n  name: string;\n  valid: boolean;\n  group: number;\n}\n\n@Component({\n  selector: 'individual-graph',\n  templateUrl: './individual-graph.component.html',\n  styleUrls: ['./individual-graph.component.scss'],\n  encapsulation: ViewEncapsulation.None\n})\n\nexport class IndividualGraphComponent implements AfterViewInit, OnChanges {\n\n  @ViewChild('container') public element: ElementRef;\n  @Input() public config: IIndividualConfig;\n\n  public factToggleName = 'fact-toggle';\n  public relationToggleName = 'relation-toggle';\n  public graphFacts = true;\n  public graphRelations = false;\n\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IFactNode, null, undefined>;\n  private svg: Selection<BaseType, IFactNode, null, undefined>;\n  private margin: ID3Margin;\n  private height: number;\n  private width: number;\n  private color: ScaleOrdinal<string, string>;\n  private layout: IGraphLayout;\n  private links: Selection<BaseType, SimulationLinkDatum<IFactNode>, any, any>;\n  private nodes: Selection<any, IFactNode, any, any>;\n  private simulation: Simulation<IFactNode, any>;\n  private nodeSize: number;\n  private nodeSizeLarge: number;\n  private dataChanges: BehaviorSubject<IIndividualConfig | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    console.debug('graph view-init');\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n    //    Subscribe\n    this.dataChanges\n      .subscribe((value) => {\n        if (value !== undefined) {\n          this.buildGraph(value);\n          this.update({\n            nodes: [],\n            links: [],\n          });\n          this.update(this.layout);\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const configChange = changes['config'];\n    console.debug('Changed', configChange);\n    if (configChange.currentValue !== configChange.previousValue) {\n      console.debug('Config changed', configChange);\n      this.dataChanges.next(configChange.currentValue);\n    }\n  }\n\n  private setupD3() {\n    this.host = select<HTMLElement, IFactNode>(this.htmlElement);\n    this.margin = {top: 10, right: 20, bottom: 10, left: 10};\n    console.debug('offsetWidth', this.htmlElement.offsetWidth);\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n    this.nodeSize = this.width / 75;\n    this.nodeSizeLarge = this.width / 50;\n    console.debug('Creating D3 graph with width/height', this.width + '/' + this.height);\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.color = scaleOrdinal(schemeCategory10);\n    console.debug('D3 initialized');\n  }\n\n  private update(data: IGraphLayout): void {\n    console.debug('Data in update function', data);\n    const force = forceManyBody();\n    force.strength(-1000);\n    this.simulation = forceSimulation<IFactNode>()\n      .force('link', forceLink().id((d: IFactNode) => d.id))\n      .force('charge', force)\n      .force('center', forceCenter(this.width / 2, this.height / 2));\n\n    const linkData = this.svg.selectAll('.link')\n      .data(data.links, (d: any) => d.source.id + '_' + d.target.id);\n\n    this.links = linkData.enter()\n      .append('line')\n      .attr('class', 'link');\n\n    const nodeData = this.svg.selectAll('.node')\n      .data(data.nodes, (d: IFactNode) => d.id);\n\n    this.nodes = nodeData\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .on('click', this.nodeClick)\n      .on('mouseover', this.nodeMouseOver)\n      .on('mouseout', this.nodeMouseOut);\n\n    this.nodes\n      .append('circle')\n      .attr('r', this.nodeSize)\n      .style('fill', (d) => this.color(d.group.toString(10)))\n      .style('opacity', (d) => d.valid ? 1.0 : 0.5);\n\n    this.nodes\n      .append('text')\n      .attr('x', 16)\n      .attr('dy', '.35em')\n      .text((d) => d.name);\n\n    //    Legend\n    const legend = this.svg.selectAll('.legend')\n      .data(this.color.domain())\n      .enter()\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', (d, i) => 'translate(0,' + (i * ((this.nodeSize) * 2) + 20) + ')');\n\n    legend.append('circle')\n      .attr('cx', this.width - 18)\n      .attr('r', this.nodeSize)\n      .attr('cy', this.nodeSize)\n      .style('fill', this.color);\n\n    legend\n      .append('text')\n      .attr('x', this.width - (this.nodeSize) * 2 - 12)\n      .attr('y', this.nodeSize)\n      .attr('dy', '0.35em')\n      .style('text-anchor', 'end')\n      .text((d) => IndividualGraphComponent.parseColorGroup(d));\n    // Force setup\n    this.simulation\n      .nodes(data.nodes)\n      .on('tick', this.forceTick);\n\n    // For some reason, the links() function doesn't exist on the simulation type, so we do a simple cast to get around it.\n    // Seems to work, and the only other option is to lose all type checking for the simulation object\n    (this.simulation.force('link') as any).links(data.links);\n\n    linkData.exit().remove();\n    nodeData.exit().remove();\n  }\n\n  private nodeClick = (d: IFactNode): void => {\n    console.debug('Clicked', d);\n  };\n\n  private nodeMouseOver = (event: any): void => {\n    select(event.currentTarget).select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSizeLarge);\n  };\n\n  private nodeMouseOut = (event: any): void => {\n    select(event.currentTarget)\n      .select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSize);\n  };\n\n  private forceTick = (): void => {\n    this.nodes\n      .attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')');\n\n    this.links\n      .attr('x1', (d: any) => d.source.x)\n      .attr('y1', (d: any) => d.source.y)\n      .attr('x2', (d: any) => d.target.x)\n      .attr('y2', (d: any) => d.target.y);\n  };\n\n  private buildGraph(config: IIndividualConfig): void {\n    const individual = config.data;\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n\n    //    Add the selection as node 0\n    const individualNode = {\n      id: individual.getID(),\n      name: IndividualGraphComponent.parseIndividualID(individual.getID()),\n      valid: true,\n      group: NodeType.INDIVIDUAL\n    };\n\n    const individualTemporal = {\n      id: individual.getTemporal().getID(),\n      name: 'selection-temporal',\n      valid: true,\n      group: NodeType.VTEMPORAL\n    };\n\n    this.layout.nodes.push(individualNode, individualTemporal);\n\n    this.layout.links.push({\n      source: individualNode,\n      target: individualTemporal\n    });\n\n    if (this.graphFacts) {\n      individual.getFacts().forEach(fact => {\n        const factNode = {\n          id: fact.getID(),\n          name: fact.getName(),\n          valid: fact.isActive(config.validAt, config.dbAt),\n          group: NodeType.FACT\n        };\n        this.layout.nodes.push(factNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: factNode\n        });\n      });\n    }\n\n    //    Relations\n    if (this.graphRelations) {\n      individual.getRelations().forEach(relation => {\n        const relationNode = {\n          id: relation.getObject(),\n          name: relation.getType().toString() + ': ' + IndividualGraphComponent.parseIndividualID(relation.getObject()),\n          valid: true,\n          group: NodeType.RELATION\n        };\n        this.layout.nodes.push(relationNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: relationNode\n        });\n      });\n    }\n  }\n\n  public changeGraphMembers(event: MatSlideToggleChange): void {\n    if (event.source.id === this.factToggleName) {\n      console.debug('Graph facts?', event.checked);\n      this.graphFacts = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    } else if (event.source.id === this.relationToggleName) {\n      console.debug('Graph relations?', event.checked);\n      this.graphRelations = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    }\n  }\n\n  private static parseColorGroup(group: string): string {\n    switch (parseInt(group, 10)) {\n      case 0:\n        return 'Individual';\n      case 1:\n        return 'Valid Temporal';\n      case 2:\n        return 'Fact';\n      case 3:\n        return 'Relation';\n      default:\n        return 'unknown';\n    }\n  }\n\n  private static parseIndividualID(id: string): string {\n    const matches = id.match(/(#)(.*)/g);\n    if (matches) {\n      return matches[0].replace('#', '');\n    }\n    return id;\n  }\n}\n",
            "properties": [
                {
                    "name": "data",
                    "type": "TrestleIndividual",
                    "optional": false,
                    "description": "",
                    "line": 32
                },
                {
                    "name": "dbAt",
                    "type": "moment.Moment",
                    "optional": true,
                    "description": "",
                    "line": 34
                },
                {
                    "name": "validAt",
                    "type": "moment.Moment",
                    "optional": false,
                    "description": "",
                    "line": 33
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IIndividualHistory",
            "id": "interface-IIndividualHistory-caf45312bb04768d43ef7bd188e9014e",
            "file": "src/main/webapp/src/app/ui/history-graph/history-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChange, ViewChild, ViewEncapsulation} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs';\nimport {BaseType, select, Selection} from 'd3-selection';\nimport {scaleBand, scaleOrdinal, ScaleTime, scaleTime} from 'd3-scale';\nimport {axisBottom, axisLeft} from 'd3-axis';\nimport {schemeCategory10} from 'd3';\nimport {ID3Margin} from '../common';\nimport moment from 'moment';\nimport Base = moment.unitOfTime.Base;\n\nexport interface ITemporalEntity {\n  label: string;\n  start: Date;\n  end?: Date;\n  value: any;\n}\n\nexport interface IIndividualHistory {\n  entities: ITemporalEntity[];\n}\n\n@Component({\n  selector: 'history-graph',\n  templateUrl: './history-graph.component.html',\n  styleUrls: ['./history-graph.component.scss'],\n    encapsulation: ViewEncapsulation.None,\n})\nexport class HistoryGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('graph') public element: ElementRef;\n  @Input() public data: IIndividualHistory;\n  @Input() public graphHeight: number;\n  @Input() public minTime: Date;\n  @Input() public maxTime: Date;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, ITemporalEntity, BaseType, ITemporalEntity>;\n  private svg: Selection<BaseType, ITemporalEntity, BaseType, ITemporalEntity>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private x: ScaleTime<number, number>;\n  private dataChanges: BehaviorSubject<IIndividualHistory | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.dataChanges\n      .subscribe((value) => {\n        console.debug('Updating plot with:', this.data);\n        if (value !== undefined) {\n          this.plotData();\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const dataChange = changes['data'];\n    if (dataChange != null && (dataChange.previousValue !== dataChange.currentValue)) {\n      this.dataChanges.next(dataChange.currentValue);\n    }\n  }\n\n  private plotData(): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n\n    //    Build the domain values\n    console.debug('Building with data:', this.data);\n    const entityNames = this.data.entities.map((d) => d.label);\n    console.debug('Names:', entityNames);\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    const y = scaleBand()\n      .range([this.height, 0])\n      .domain(entityNames);\n    console.debug('Y values', y.range());\n    console.debug('Y values', y.domain());\n\n    const z = scaleOrdinal(schemeCategory10)\n      .domain(entityNames);\n\n    // Build the lane lines\n    this.svg.selectAll('.laneLine')\n      .data(this.data.entities.map((entity) => entity.label))\n      .enter().append('line')\n      .attr('class', 'laneLine')\n      .attr('x1', 0)\n      .attr('y1', (d) => y(d) || 0)\n      .attr('x2', this.width)\n      .attr('y2', (d) => y(d) || 0);\n\n    //    Build the Y-Axis\n    const ySelection = this.svg.selectAll('g.y-axis');\n    if (ySelection.empty()) {\n      this.svg\n        .append('g')\n        .attr('class', 'axis y-axis')\n        .call(axisLeft(y));\n    } else {\n      ySelection\n        .call(axisLeft(y));\n    }\n\n    // And the X-Axis\n    this.svg.select('.x-axis')\n      .call(axisBottom(this.x));\n\n    //    Add the data\n    const mainItems = this.svg.selectAll<SVGRectElement, Base>('.fact')\n      .data(this.data.entities, (entity: ITemporalEntity) => entity.label);\n\n    mainItems\n      .enter()\n      .append('rect')\n      .attr('class', 'fact')\n      .attr('x', (d) => this.normalizeAxis('x', this.x(d.start)))\n      .attr('y', (d) => y(d.label) || 0)\n      .attr('width',\n        (d) => {\n          const end = this.normalizeAxis('x',\n            this.x(this.maybeDate(d.end)));\n          const start = this.normalizeAxis('x',\n            this.x(d.start));\n          return end - start;\n        })\n      .attr('height', () => y.bandwidth())\n      // .style(\"fill\", (d: TrestleFact) => z(d.getName()))\n      .style('fill', (d) => z(d.label))\n      .style('fill-opacity', 0.7)\n      .merge(mainItems);\n\n    // Labels\n    const mainLabels = this.svg.selectAll<SVGTextElement, BaseType>('.mainLabels')\n      .data(this.data.entities, (d: ITemporalEntity) => d.label);\n\n    mainLabels\n      .enter()\n      .append('text')\n      .text((d) => HistoryGraphComponent.parseValue(d.value))\n      .attr('class', 'mainLabels')\n      .attr('x', (d) => {\n        const end = d.end;\n        const start = d.start;\n        const width = this.x(this.maybeDate(end)) - this.x(start);\n        return this.x(start) + width / 2;\n      })\n      .attr('y', (d) => (y(d.label) || 0) + y.bandwidth() - 5)\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.1ex')\n      .merge(mainLabels);\n\n    mainItems.exit().remove();\n    mainLabels.exit().remove();\n  }\n\n  private maybeDate(date: string | Date | undefined): Date {\n    if (date instanceof Date) {\n      return date;\n    }\n    if (date === undefined) {\n      return this.minTime;\n    }\n    if (date === '') {\n      return this.maxTime;\n    }\n    return new Date(date);\n  }\n\n  private static parseValue(value: string | number): string {\n    if (typeof value === 'number') {\n      return value.toString();\n    }\n    if (value.length > 20) {\n      return value.substring(0, 20) + '...';\n    }\n    return value;\n  }\n\n  private normalizeAxis(axis: 'x' | 'y', value: number): number {\n    // Normalize X Axis\n    if (axis === 'x') {\n      if (value < 0) {\n        return 0;\n      }\n      if (value > this.width) {\n        return this.width;\n      }\n      return value;\n    } else {\n      if (value < 0) {\n        return 0;\n      }\n      if (value > this.height) {\n        return this.height;\n      }\n      return value;\n    }\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, ITemporalEntity>(this.htmlElement);\n    this.margin = {top: 20, right: 30, bottom: 20, left: 150};\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = this.graphHeight - this.margin.top - this.margin.bottom;\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n\n    console.debug('D3 Initialized');\n  }\n}\n",
            "properties": [
                {
                    "name": "entities",
                    "type": "ITemporalEntity[]",
                    "optional": false,
                    "description": "",
                    "line": 22
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IInterfacable",
            "id": "interface-IInterfacable-7d03ae66a7d1656bc2dbff79561e1773",
            "file": "src/main/webapp/src/app/shared/interfacable.ts",
            "type": "interface",
            "sourceCode": "export interface IInterfacable<I> {\n    asInterface(): I;\n}\n",
            "properties": [],
            "indexSignatures": [],
            "kind": 152,
            "methods": [
                {
                    "name": "asInterface",
                    "args": [],
                    "optional": false,
                    "returnType": "I",
                    "typeParameters": [],
                    "line": 2
                }
            ]
        },
        {
            "name": "IIntersectionBody",
            "id": "interface-IIntersectionBody-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "buffer",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "databaseAt",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "dataset",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "geojson",
                    "type": "Polygon | MultiPolygon",
                    "optional": false,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "validAt",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 52
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ILoadingState",
            "id": "interface-ILoadingState-76b2c67b99f63b7db50272eed3499d5a",
            "file": "src/main/webapp/src/app/explore/compare/compare.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewChecked, AfterViewInit, ChangeDetectorRef, Component, ElementRef, ViewChild} from \"@angular/core\";\nimport {ISpatialComparisonReport, MapService} from \"../viewer/map.service\";\nimport moment from \"moment\";\nimport {interpolateReds} from \"d3-scale-chromatic\";\nimport {IDataExport} from \"../exporter/exporter.component\";\nimport {parse} from \"wellknown\";\nimport {MultiPolygon} from \"geojson\";\nimport {ActivatedRoute} from \"@angular/router\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {IMapAttributeChange, MapSource, TrestleMapComponent} from \"../../ui/trestle-map/trestle-map.component\";\nimport {IndividualService} from \"../../shared/individual/individual.service\";\nimport {LoadingSpinnerService} from \"../../ui/loading-spinner/loading-spinner.service\";\nimport {ColorService} from \"../../shared/color/color.service\";\nimport {TrestleTemporal} from \"../../shared/individual/TrestleIndividual/trestle-temporal\";\nimport {MapboxOptions} from \"mapbox-gl\";\nimport {MatSliderChange} from \"@angular/material/slider\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\ninterface ICompareIndividual {\n  individual: TrestleIndividual;\n  color: string;\n  visible: boolean;\n  focused: boolean;\n  height: number;\n  base: number;\n  sliderValue: number;\n  report?: ISpatialComparisonReport;\n}\n\ninterface ILoadingState {\n  color: loadingColor;\n  type: loadingState;\n  visible: boolean;\n}\n\nexport type loadingState = 'determinate' | 'indeterminate';\nexport type loadingColor = 'accent' | 'warn' | 'primary';\n\n@Component({\n  selector: 'compare',\n  templateUrl: './compare.component.html',\n  styleUrls: ['./compare.component.scss']\n})\nexport class CompareComponent implements AfterViewInit, AfterViewChecked {\n\n  public zoomMap = true;\n  public mapConfig: MapboxOptions;\n  public selectedIndividuals: Map<string, ICompareIndividual>;\n  public baseIndividual: ICompareIndividual | null;\n  public dataChanges: BehaviorSubject<MapSource | undefined>;\n  public layerChanges: Subject<IMapAttributeChange>;\n  public exportValues: IDataExport[];\n  public loadedOverlap: ISpatialComparisonReport | null;\n  public loading: ILoadingState;\n  public currentSliderValue: number;\n\n  private filterCompareResults: boolean;\n  private layerDepth: number;\n  private maxHeight: number;\n  private layerNumber: number;\n  @ViewChild(TrestleMapComponent)\n  private mapComponent: TrestleMapComponent;\n  @ViewChild('loadable')\n  private mapRef: ElementRef;\n  private disabledFocusIndividuals: string[];\n\n  constructor(private is: IndividualService,\n              private vs: MapService,\n              private spinner: LoadingSpinnerService,\n              private route: ActivatedRoute,\n              private cdRef: ChangeDetectorRef,\n              private cs: ColorService\n  ) {\n\n    this.mapConfig = {\n      style: 'mapbox://styles/nrobison/cj3n7if3q000s2sutls5a1ny7',\n      center: [32.3558991, -25.6854313],\n      zoom: 8,\n      pitch: 40,\n      bearing: 20,\n      container: \"map\"\n    };\n    this.layerDepth = 50;\n    this.maxHeight = 2016;\n    this.selectedIndividuals = new Map();\n    // Setup layer coloring\n    this.layerNumber = 0;\n    this.currentSliderValue = 0;\n    this.dataChanges = new BehaviorSubject(undefined);\n    this.layerChanges = new Subject();\n    this.filterCompareResults = true;\n    this.exportValues = [{\n      dataset: 'GAUL',\n      individuals: []\n    }];\n    this.loadedOverlap = null;\n\n    this.loading = {\n      color: 'primary',\n      type: 'indeterminate',\n      visible: false\n    };\n    this.disabledFocusIndividuals = [];\n  }\n\n  public ngAfterViewInit(): void {\n    // Subscribe to route observables\n    this.route.queryParams\n      .subscribe((queryParams) => {\n        console.debug('params', queryParams);\n        const individual = queryParams['id'];\n        if (individual !== null) {\n          this.addBaseIndividual(individual);\n        }\n      });\n\n    console.debug('Child', this.mapComponent);\n    this.spinner.setViewContainerRef(this.mapRef.nativeElement);\n  }\n\n  /**\n   * Recheck the view.\n   * I'm really not sure why I need this, but SO says so\n   * https://stackoverflow.com/questions/43513421/ngif-expression-has-changed-after-it-was-checked\n   */\n  public ngAfterViewChecked(): void {\n    this.cdRef.detectChanges();\n  }\n\n  /**\n   * Compare the base individual against all the other currently visible objects\n   */\n  public compareIndividuals(): void {\n    // Get all the individuals\n    if (this.baseIndividual) {\n      this.loading = {\n        color: 'accent',\n        type: 'indeterminate',\n        visible: true\n      };\n      this.vs.compareIndividuals({\n        compare: this.baseIndividual.individual.getID(),\n        compareAgainst: Array.from(this.selectedIndividuals.values())\n          // Filter out invisible members\n          .filter((individual) => individual.visible === true)\n          .map((individual) => individual.individual.getID())\n      })\n        .subscribe((data) => {\n          console.debug('Has data from compare', data);\n          // Add the comparison reports to each individual,\n          // or set them equal to undefined\n          data.reports.forEach((report) => {\n            this.loading.visible = false;\n            const selection = this.selectedIndividuals.get(report.objectBID);\n            if (selection) {\n              if (selection.visible) {\n                selection.report = report;\n                //    Change the color to something on the red scale\n                if (report.spatialOverlapPercentage) {\n                  const interpolated = interpolateReds(\n                    report.spatialOverlapPercentage);\n                  selection.color = interpolated;\n                  this.layerChanges.next({\n                    individual: selection.individual.getID(),\n                    // Change the color and set the opacity a little higher\n                    changes: [\n                      {\n                        attribute: 'fill-extrusion-color',\n                        value: interpolated\n                      },\n                      {\n                        attribute: 'fill-extrusion-opacity',\n                        value: 0.85\n                      }]\n                  });\n                } else {\n                  // If we don't have any overlap, are we supposed to filter ou those individuals?\n                  if (this.filterCompareResults) {\n                    this.removeIndividual(selection);\n                  }\n                }\n              } else {\n                selection.report = undefined;\n              }\n            }\n          });\n        }, (error) => {\n          console.debug(error);\n          this.loading = {\n            color: 'warn',\n            type: 'determinate',\n            visible: true\n          };\n        });\n    }\n  }\n\n  /**\n   * Handler function to load the selected individual\n   * @param {string} individual\n   */\n  public selectedHandler(individual: string): void {\n    console.debug('Selected:', individual);\n    this.loadSelectedIndividual(individual);\n  }\n\n  /**\n   * Add base individual to compare\n   * @param {string} individual\n   */\n  public addBaseIndividual(individual: string): void {\n    this.loadSelectedIndividual(individual, true);\n  }\n\n  /**\n   * Reset comparison to the base state\n   *\n   * If a new individual is provided, add it\n   * @param {string} individual\n   */\n  public reset(individual?: string): void {\n    //    Clear the map\n    //    Remove all the individuals from map\n    this.mapComponent.clearMap();\n    this.zoomMap = true;\n    // this.selectedIndividuals = [];\n    this.selectedIndividuals = new Map();\n    //    Clear the base selection\n    this.baseIndividual = null;\n    this.layerNumber = 0;\n    this.currentSliderValue = 0;\n    this.cs.reset();\n\n    //    Should we add the given individual to the compare?\n    if (individual) {\n      this.addBaseIndividual(individual);\n    }\n  }\n\n  /**\n   * Toggle the visibility of the given individual\n   * @param {ICompareIndividual} individual\n   */\n  public toggleVisibility(individual: ICompareIndividual): void {\n    individual.visible = !individual.visible;\n    this.mapComponent\n      .toggleIndividualVisibility(individual\n          .individual.getID(),\n        individual.visible);\n  }\n\n  /**\n   * Toggle the focus of a given individual, this will hide all other currently visible individuals\n   * @param {ICompareIndividual} individual\n   */\n  public toggleFocus(individual: ICompareIndividual): void {\n    individual.focused = !individual.focused;\n\n    // If we've selected the focus option, grab all the currently visible layers, disable them, and stash them for later\n    if (individual.focused) {\n      // If we have previously disabled individuals, reenable them, then do your thing\n      if (!(this.disabledFocusIndividuals.length === 0)) {\n        this.disabledFocusIndividuals\n          .forEach((fIndividual) => {\n            const mapValue = this.selectedIndividuals.get(fIndividual);\n            if (mapValue) {\n              this.toggleVisibility(mapValue);\n            }\n          });\n        // Also, find any other focused layers, and unfocus them.\n        this.selectedIndividuals\n          .forEach((value) => {\n            if (value !== individual && value.focused) {\n              value.focused = false;\n            }\n          });\n        this.disabledFocusIndividuals = [];\n      }\n      //    Get all the currently visible layers\n      this.selectedIndividuals\n        .forEach((value, key) => {\n          // If the individual is visible, stash it's value so we can enable it later\n          if (value !== individual && value.visible) {\n            this.disabledFocusIndividuals.push(key);\n            this.toggleVisibility(value);\n          }\n        });\n      //    If the individual isn't supposed to be focused, grab all the stashed individuals and reenable them.\n    } else {\n      this.disabledFocusIndividuals\n        .forEach((fIndividual) => {\n          const mapValue = this.selectedIndividuals.get(fIndividual);\n          if (mapValue) {\n            this.toggleVisibility(mapValue);\n          }\n        });\n      //    Reset the focused list\n      this.disabledFocusIndividuals = [];\n    }\n  }\n\n  /**\n   * Remove the given individual from the comparison list\n   * @param {ICompareIndividual} individual\n   */\n  public removeIndividual(individual: ICompareIndividual): void {\n    console.debug('Remove:', individual);\n    // Remove from the array first, then from the map\n    this.selectedIndividuals.delete(individual.individual.getID());\n    this.mapComponent\n      .removeIndividual(individual.individual.getID());\n\n    //    Remove from export\n    const idx = this.exportValues[0].individuals.indexOf(individual.individual.getID());\n    if (idx > -1) {\n      this.exportValues[0].individuals.splice(idx);\n    }\n\n    //    Return the color to reuse\n    this.cs.returnColor(individual.color);\n  }\n\n  /**\n   * Update explode slider and change the values on the map\n   * @param {MatSliderChange} event\n   * @param {ICompareIndividual | null} selection\n   */\n  public sliderUpdate(event: MatSliderChange, selection = this.baseIndividual) {\n    if ((event.value !== null) && (selection !== null)) {\n      //     For now, let's just change the base individual,\n      // we'll figure out the rest later\n      const newOffset = (event.value - selection.sliderValue) * 50;\n      this.mapComponent.change3DOffset(selection.height,\n        newOffset,\n        selection.individual.getID());\n      selection.sliderValue = event.value;\n      selection.height = selection.height + newOffset;\n      selection.base = selection.base + newOffset;\n    }\n  }\n\n  /**\n   * Filter compare results to only return objects which overlap in some way\n   * @param {MatSlideToggleChange} event\n   */\n  public filterChanged(event: MatSlideToggleChange): void {\n    this.filterCompareResults = event.checked;\n  }\n\n  /**\n   * Perform spatial intersection with base individual\n   */\n  public intersectBaseIndividual(): void {\n    if (this.baseIndividual) {\n      // this.spinner.reveal();\n      this.loading = {\n        color: 'accent',\n        type: 'indeterminate',\n        visible: true\n      };\n      this.vs\n        .stIntersectIndividual('GAUL',\n          this.baseIndividual.individual.getSpatialValue(),\n          undefined,\n          moment(),\n          0)\n        .subscribe((results) => {\n          console.debug('IDs', results.map((indv) => indv.withoutHostname()));\n          // If we have results, turn off the loading bar\n          this.loading.visible = false;\n          results\n            .filter((result) => {\n              // Filter out the base individual,\n              // if it exists, in the grossest way possible\n              if (this.baseIndividual !== null) {\n                return !(result.getID() === this.baseIndividual.individual.getID());\n              }\n              return true;\n            })\n            .forEach((result) => this.addIndividualToCompare(result, false));\n          // this.spinner.hide();\n        }, (error) => {\n          console.error(error);\n          this.loading = {\n            color: 'warn',\n            type: 'determinate',\n            visible: true\n          };\n        });\n    }\n  };\n\n  /**\n   * Get all currently selected individuals\n   * @returns {ICompareIndividual[]}\n   */\n  public getSelectedIndividuals(): ICompareIndividual[] {\n    return Array.from(this.selectedIndividuals.values());\n  }\n\n  /**\n   * Pipe function to enable the view to check for changes\n   * @returns {ICompareIndividual[]}\n   */\n  public get mapValues(): ICompareIndividual[] {\n    return Array.from(this.selectedIndividuals.values());\n  }\n\n  /**\n   * Toggle overlap between the base individual and the selected individual\n   * @param {ISpatialComparisonReport} overlap\n   */\n  public toggleOverlap(overlap: ISpatialComparisonReport): void {\n    const id = TrestleIndividual.filterID(overlap.objectAID)\n      + '-' + TrestleIndividual.filterID(overlap.objectBID);\n    // If we have an overlap, and we haven't loaded it yet\n    if (overlap.spatialOverlap) {\n      // If the loaded overlap is null, add the new one\n      if (this.loadedOverlap === null) {\n        // Build the change value\n        const changes: MapSource = {\n          id,\n          data: {\n            type: 'Feature',\n            // TODO(nickrobison): Gross?\n            geometry: (parse(overlap.spatialOverlap) as MultiPolygon),\n            properties: null,\n            id\n          },\n          extrude: {\n            id: id + '-extrude',\n            type: 'fill-extrusion',\n            source: id,\n            paint: {\n              'fill-extrusion-color': 'blue',\n              'fill-extrusion-height': 3050,\n              'fill-extrusion-base': 3000,\n              'fill-extrusion-opacity': 0.7\n            }\n          }\n        };\n\n        //    Turn off all layers except objects A and B that we need\n        this.selectedIndividuals.forEach((value) => {\n          if (CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            this.toggleVisibility(value);\n          }\n        });\n\n        //    Now, add the new overlap\n        this.dataChanges.next(changes);\n        this.loadedOverlap = overlap;\n\n        //    If we are the overlap, remove us and turn everything back on\n      } else if (this.loadedOverlap === overlap) {\n        this.selectedIndividuals.forEach((value) => {\n          if (CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            this.toggleVisibility(value);\n          }\n        });\n        this.mapComponent.removeIndividual(id);\n        this.loadedOverlap = null;\n        //    Otherwise, remove the current overlap, and cycle what needs to be toggled\n      } else {\n        //    Unload the current overlap\n        const overlapID = TrestleIndividual.filterID(this.loadedOverlap.objectAID)\n          + '-' + TrestleIndividual.filterID(this.loadedOverlap.objectBID);\n        this.mapComponent.removeIndividual(overlapID);\n        //    Build the change value\n        const changes: MapSource = {\n          id,\n          data: {\n            type: 'Feature',\n            // TODO(nickrobison): Gross?\n            geometry: (parse(overlap.spatialOverlap) as MultiPolygon),\n            properties: null,\n            id\n          },\n          extrude: {\n            id: id + '-extrude',\n            type: 'fill-extrusion',\n            source: id,\n            paint: {\n              'fill-extrusion-color': 'blue',\n              'fill-extrusion-height': 4000,\n              'fill-extrusion-base': 3000,\n              'fill-extrusion-opacity': 0.7\n            }\n          }\n        };\n\n        this.selectedIndividuals.forEach((value) => {\n          //    If it's part of the new overlap, and is not visible, turn it on\n          if (!CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            if (!value.visible) {\n              this.toggleVisibility(value);\n            }\n            //    If it's visible and not part of the new overlap, turn it off\n          } else if (value.visible) {\n            this.toggleVisibility(value);\n          }\n        });\n\n        //    Set the new overlap\n        this.dataChanges.next(changes);\n        this.loadedOverlap = overlap;\n      }\n    }\n  }\n\n  /**\n   * Load the selected individual by fetching its value from the database\n   * @param {string} individual\n   * @param {boolean} baseIndividual\n   */\n  private loadSelectedIndividual(individual: string, baseIndividual = false): void {\n    this.is.getTrestleIndividual(individual)\n      .subscribe((result) => this.addIndividualToCompare(result, baseIndividual));\n  }\n\n  /**\n   * Add individual to the comparison set and the map\n   * @param {TrestleIndividual} individual\n   * @param {boolean} baseIndividual\n   */\n  private addIndividualToCompare(individual: TrestleIndividual, baseIndividual = false): void {\n    console.debug('Adding individual:', individual);\n    // Before we add any individuals to the map, we need to see if we're loading the base individual or not\n    // This is to deal with some racy behavior between drawing the individual on the map and moving on from the data load\n    // It's gross, but what do you expect?\n    if (baseIndividual) {\n      console.debug('Setting zoom true');\n      this.zoomMap = true;\n    } else {\n      console.debug('Setting zoom false');\n      // If zoom is true, manually run the change detection.\n      // Why? no idea\n      if (this.zoomMap === true) {\n        this.zoomMap = false;\n        this.cdRef.detectChanges();\n      } else {\n        this.zoomMap = false;\n      }\n    }\n\n    // This is one way to filter out the base individual\n    console.debug('Adding %s to map', individual.getFilteredID());\n    const color = this.cs.getColor(this.layerNumber);\n    const height = this.getHeight(individual.getTemporal());\n    const baseHeight = CompareComponent.getBase(individual.getTemporal());\n    this.dataChanges.next({\n      id: individual.getID(),\n      data: {\n        type: 'Feature',\n        geometry: individual.getSpatialValue(),\n        id: individual.getFilteredID(),\n        properties: individual.getFactValues()\n      },\n      extrude: {\n        id: individual.getID() + '-extrude',\n        type: 'fill-extrusion',\n        source: individual.getID(),\n        paint: {\n          'fill-extrusion-color': color,\n          'fill-extrusion-height': height,\n          'fill-extrusion-base': baseHeight,\n          'fill-extrusion-opacity': 0.7\n        }\n      },\n      labelField: 'adm2_name'\n    });\n\n    const compare = {\n      individual,\n      color,\n      visible: true,\n      focused: false,\n      height,\n      base: baseHeight,\n      sliderValue: 50\n    };\n\n    // Are we loading the base selection, or not?\n    if (baseIndividual) {\n      // Reset the slider value to 0\n      compare.sliderValue = 0;\n      this.baseIndividual = compare;\n    } else {\n      //    Add the selection to the list\n      this.selectedIndividuals.set(compare.individual.getID(),\n        compare);\n      // this.selectedIndividuals.push(compare);\n    }\n    this.layerNumber++;\n\n    //    Add them to the export record\n    this.exportValues[0].individuals.push(compare.individual.getID());\n  }\n\n  private getHeight(temporal: TrestleTemporal): number {\n    const to = temporal.getTo();\n    if (to === undefined) {\n      return this.maxHeight;\n    } else {\n      return to.get('year');\n    }\n  }\n\n  private static getBase(temporal: TrestleTemporal): number {\n    return temporal.getFrom().get('year');\n  }\n\n  /**\n   * Filter only individuals actually involved in the overlap\n   * @param {ICompareIndividual} value\n   * @param {ISpatialComparisonReport} overlap\n   * @returns {boolean}\n   */\n  private static filterOverlapIndividuals(value: ICompareIndividual, overlap: ISpatialComparisonReport) {\n    const id = value.individual.getID();\n    return (id !== overlap.objectAID) &&\n      (id !== overlap.objectBID);\n  }\n}\n",
            "properties": [
                {
                    "name": "color",
                    "type": "loadingColor",
                    "optional": false,
                    "description": "",
                    "line": 32
                },
                {
                    "name": "type",
                    "type": "loadingState",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "visible",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 34
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IMapAttributeChange",
            "id": "interface-IMapAttributeChange-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "changes",
                    "type": "Array<literal type>",
                    "optional": false,
                    "description": "",
                    "line": 65
                },
                {
                    "name": "individual",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 64
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IMapEventHandler",
            "id": "interface-IMapEventHandler-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "event",
                    "type": "MapEvent",
                    "optional": false,
                    "description": "",
                    "line": 71
                },
                {
                    "name": "handler",
                    "type": "function",
                    "optional": false,
                    "description": "",
                    "line": 72
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IMapFillLayer",
            "id": "interface-IMapFillLayer-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "type",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "extends": "FillLayer"
        },
        {
            "name": "IMapHoverLayer",
            "id": "interface-IMapHoverLayer-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "filter",
                    "type": "[\"==\", \"name\", \"\"]",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "type",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "extends": "FillLayer"
        },
        {
            "name": "IMapLineLayer",
            "id": "interface-IMapLineLayer-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "type",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 31
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "extends": "LineLayer"
        },
        {
            "name": "IMapWorkerRequest",
            "id": "interface-IMapWorkerRequest-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "id",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "response",
                    "type": "object[]",
                    "optional": false,
                    "description": "",
                    "line": 63
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IMapWorkerResponse",
            "id": "interface-IMapWorkerResponse-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "geom",
                    "type": "FeatureCollection<GeometryObject>",
                    "optional": false,
                    "description": "",
                    "line": 68
                },
                {
                    "name": "id",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 67
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IMetricsData",
            "id": "interface-IMetricsData-2df419d1f3a9f8f616352bc29217c0ea",
            "file": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {HttpClient, HttpHeaders} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {Observable, throwError} from 'rxjs';\nimport {catchError, map, tap} from 'rxjs/operators';\n\nexport interface ITrestleMetricsHeader {\n  upTime: number;\n  startTime: number;\n  meters: Map<string, string>;\n}\n\nexport interface IMetricsData {\n  metric: string;\n  values: IMetricsValue[];\n}\n\nexport interface IMetricsValue {\n  timestamp: Date;\n  value: number;\n}\n\n@Injectable()\nexport class MetricsService {\n\n  private readonly baseUrl: string;\n\n  constructor(private authHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get initial data about available metrics\n   * @returns {Observable<ITrestleMetricsHeader>}\n   */\n  public getMetrics(): Observable<ITrestleMetricsHeader> {\n    return this.authHttp.get<ITrestleMetricsHeader>(this.baseUrl + '/metrics')\n      .pipe(catchError((error: Error) => throwError(error || 'Server Error')));\n  }\n\n  /**\n   * Get values for a specified metric ID that falls within the given range\n   * @param {string} metricID to fetch\n   * @param {number} start of temporal period for metrics data\n   * @param {number} end of temporal period for metrics data\n   * @returns {Observable<IMetricsData>}\n   */\n  public getMetricValues(metricID: string, start: number, end: number): Observable<IMetricsData> {\n    console.debug('Retrieving values for metric: ' + metricID + ' from: ' + start + ' to: ' + end);\n    const params = new HttpHeaders();\n    params.append('start', start.toString());\n    params.append('end', end.toString());\n    return this.authHttp.get(this.baseUrl + '/metrics/metric/' + metricID, {\n      params: {\n        start: start.toString(),\n        end: end.toString()\n      }\n    })\n      .pipe(\n        tap(json => console.debug('Metric values:', json)),\n        map(json => {\n          const metricValues: IMetricsValue[] = [];\n          Object.keys(json).forEach((key) => {\n            const longKey = parseInt(key, 10);\n            if (longKey !== 0) {\n              metricValues.push({\n                timestamp: new Date(longKey),\n                value: json[longKey]\n              });\n            }\n          });\n          return {\n            metric: metricID,\n            values: metricValues.sort((a, b) => {\n              if (a.timestamp === b.timestamp) {\n                return 0;\n              }\n              if (a.timestamp < b.timestamp) {\n                return -1;\n              }\n              return 1;\n            })\n          };\n        }));\n  }\n\n  /**\n   * Export the given metric values as a CSV file\n   * @param {string[] | null} metrics to export\n   * @param {number} start of temporal period\n   * @param {number} end of temporal period\n   * @returns {Observable<Blob>}\n   */\n  public exportMetricValues(metrics: null | string[], start: number, end?: number): Observable<Blob> {\n    return this.authHttp.post(this.baseUrl + '/metrics/export', {\n        metrics,\n        start,\n        end\n      },\n      {\n        responseType: 'blob'\n      });\n  }\n}\n",
            "properties": [
                {
                    "name": "metric",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "values",
                    "type": "IMetricsValue[]",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IMetricsValue",
            "id": "interface-IMetricsValue-2df419d1f3a9f8f616352bc29217c0ea",
            "file": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {HttpClient, HttpHeaders} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {Observable, throwError} from 'rxjs';\nimport {catchError, map, tap} from 'rxjs/operators';\n\nexport interface ITrestleMetricsHeader {\n  upTime: number;\n  startTime: number;\n  meters: Map<string, string>;\n}\n\nexport interface IMetricsData {\n  metric: string;\n  values: IMetricsValue[];\n}\n\nexport interface IMetricsValue {\n  timestamp: Date;\n  value: number;\n}\n\n@Injectable()\nexport class MetricsService {\n\n  private readonly baseUrl: string;\n\n  constructor(private authHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get initial data about available metrics\n   * @returns {Observable<ITrestleMetricsHeader>}\n   */\n  public getMetrics(): Observable<ITrestleMetricsHeader> {\n    return this.authHttp.get<ITrestleMetricsHeader>(this.baseUrl + '/metrics')\n      .pipe(catchError((error: Error) => throwError(error || 'Server Error')));\n  }\n\n  /**\n   * Get values for a specified metric ID that falls within the given range\n   * @param {string} metricID to fetch\n   * @param {number} start of temporal period for metrics data\n   * @param {number} end of temporal period for metrics data\n   * @returns {Observable<IMetricsData>}\n   */\n  public getMetricValues(metricID: string, start: number, end: number): Observable<IMetricsData> {\n    console.debug('Retrieving values for metric: ' + metricID + ' from: ' + start + ' to: ' + end);\n    const params = new HttpHeaders();\n    params.append('start', start.toString());\n    params.append('end', end.toString());\n    return this.authHttp.get(this.baseUrl + '/metrics/metric/' + metricID, {\n      params: {\n        start: start.toString(),\n        end: end.toString()\n      }\n    })\n      .pipe(\n        tap(json => console.debug('Metric values:', json)),\n        map(json => {\n          const metricValues: IMetricsValue[] = [];\n          Object.keys(json).forEach((key) => {\n            const longKey = parseInt(key, 10);\n            if (longKey !== 0) {\n              metricValues.push({\n                timestamp: new Date(longKey),\n                value: json[longKey]\n              });\n            }\n          });\n          return {\n            metric: metricID,\n            values: metricValues.sort((a, b) => {\n              if (a.timestamp === b.timestamp) {\n                return 0;\n              }\n              if (a.timestamp < b.timestamp) {\n                return -1;\n              }\n              return 1;\n            })\n          };\n        }));\n  }\n\n  /**\n   * Export the given metric values as a CSV file\n   * @param {string[] | null} metrics to export\n   * @param {number} start of temporal period\n   * @param {number} end of temporal period\n   * @returns {Observable<Blob>}\n   */\n  public exportMetricValues(metrics: null | string[], start: number, end?: number): Observable<Blob> {\n    return this.authHttp.post(this.baseUrl + '/metrics/export', {\n        metrics,\n        start,\n        end\n      },\n      {\n        responseType: 'blob'\n      });\n  }\n}\n",
            "properties": [
                {
                    "name": "timestamp",
                    "type": "Date",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "value",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 23
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IRouteObservable",
            "id": "interface-IRouteObservable-030cedf9d7376469b30c829dd34fdb26",
            "file": "src/main/webapp/src/app/explore/visualize/visualize-details/visualize-details.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewInit, Component} from \"@angular/core\";\nimport moment, {Moment} from \"moment\";\nimport {ActivatedRoute, Params} from '@angular/router';\nimport {TrestleIndividual} from '../../../shared/individual/TrestleIndividual/trestle-individual';\nimport {BehaviorSubject, combineLatest, Observable} from 'rxjs';\nimport {MapSource} from '../../../ui/trestle-map/trestle-map.component';\nimport {IIndividualHistory} from '../../../ui/history-graph/history-graph.component';\nimport {IndividualService} from '../../../shared/individual/individual.service';\nimport {map} from 'rxjs/operators';\n\ninterface IRouteObservable {\n    route: Params;\n    query: Params;\n}\n\n@Component({\n    selector: \"visualize-details\",\n    templateUrl: \"./visualize-details.component.html\",\n    styleUrls: [\"./visualize-details.component.scss\"]\n})\nexport class VisualizeDetailsComponent implements AfterViewInit {\n\n    public individual: TrestleIndividual;\n    public mapIndividual: BehaviorSubject<MapSource | undefined>;\n    public individualFactHistory: IIndividualHistory;\n    public minTime: Moment;\n    public maxTime: Moment;\n    public minGraphDate = new Date(\"1990-01-01\");\n    public maxGraphDate = new Date(\"2017-01-01\");\n    public validAt: Moment;\n    public dbAt: Moment;\n    private routeObservable: Observable<IRouteObservable>;\n\n    constructor(private is: IndividualService,\n                private route: ActivatedRoute) {\n        this.mapIndividual = new BehaviorSubject(undefined);\n        this.minTime = moment().year(1990).startOf(\"year\");\n        this.maxTime = moment().year(2016).endOf(\"year\");\n        const now = moment();\n        this.validAt = now;\n        this.dbAt = now;\n    }\n\n    public ngAfterViewInit(): void {\n        this.routeObservable = combineLatest([this.route.params, this.route.queryParams]).pipe(map((results) => {\n          return {\n            route: results[0],\n            query: results[1]\n          }\n        }));\n        this.routeObservable\n            .subscribe((combined) => {\n                console.debug(\"has params: %O %O\", combined.route, combined.query);\n                if (combined.query[\"root\"]) {\n                    this.loadIndividual(combined.query[\"root\"] + combined.route[\"id\"]);\n                } else {\n                    this.loadIndividual(combined.route[\"id\"]);\n                }\n            });\n    }\n\n    /**\n     * Display function to filter down individual IDs\n     * @param {string} name\n     * @returns {string}\n     */\n    public displayFn(name: string): string {\n        return TrestleIndividual.filterID(name);\n    }\n\n    /**\n     * Gets the IRI suffix, since we can't access static methods in the Angular template\n     * @param {string} object\n     * @returns {string}\n     */\n    public getSuffix(object: string): string {\n        return TrestleIndividual.extractSuffix(object);\n    }\n\n    /**\n     * Gets the IRI hostname, since we can't access static methods in the Angular template\n     * @param {string} object\n     * @returns {string}\n     */\n    public getPrefix(object: string): string {\n        return TrestleIndividual.extractPrefix(object);\n    }\n\n    private loadIndividual(value: string): void {\n        console.debug(\"Loading individual:\", value);\n        this.is.getTrestleIndividual(value)\n            .subscribe((results: TrestleIndividual) => {\n                console.debug(\"has selection\", results);\n                this.individual = results;\n\n                // Build fact history\n                this.individualFactHistory = {\n                    entities: results\n                        .getFacts()\n                        .filter((fact) => fact.getDatabaseTemporal().isContinuing())\n                        .map((fact) => {\n                            return {\n                                label: fact.getName(),\n                                start: fact.getValidTemporal().getFromAsDate(),\n                                end: fact.getValidTemporal().getToAsDate(),\n                                value: fact.getValue()\n                            };\n                        })\n                };\n                console.debug(\"Sending individual to map\");\n                this.mapIndividual.next({\n                    id: results.getID(),\n                    data: {\n                        type: \"Feature\",\n                        geometry: results.getSpatialValue(),\n                        id: results.getIDAsInteger().toString(),\n                        properties: results.getFactValues()\n                    }\n                });\n            });\n    }\n}\n",
            "properties": [
                {
                    "name": "query",
                    "type": "Params",
                    "optional": false,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "route",
                    "type": "Params",
                    "optional": false,
                    "description": "",
                    "line": 12
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ISpatialComparisonReport",
            "id": "interface-ISpatialComparisonReport-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "properties": [
                {
                    "name": "equality",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "objectAID",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "objectBID",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "relations",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "spatialOverlap",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "spatialOverlapPercentage",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 45
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITemporalEntity",
            "id": "interface-ITemporalEntity-caf45312bb04768d43ef7bd188e9014e",
            "file": "src/main/webapp/src/app/ui/history-graph/history-graph.component.ts",
            "type": "interface",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChange, ViewChild, ViewEncapsulation} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs';\nimport {BaseType, select, Selection} from 'd3-selection';\nimport {scaleBand, scaleOrdinal, ScaleTime, scaleTime} from 'd3-scale';\nimport {axisBottom, axisLeft} from 'd3-axis';\nimport {schemeCategory10} from 'd3';\nimport {ID3Margin} from '../common';\nimport moment from 'moment';\nimport Base = moment.unitOfTime.Base;\n\nexport interface ITemporalEntity {\n  label: string;\n  start: Date;\n  end?: Date;\n  value: any;\n}\n\nexport interface IIndividualHistory {\n  entities: ITemporalEntity[];\n}\n\n@Component({\n  selector: 'history-graph',\n  templateUrl: './history-graph.component.html',\n  styleUrls: ['./history-graph.component.scss'],\n    encapsulation: ViewEncapsulation.None,\n})\nexport class HistoryGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('graph') public element: ElementRef;\n  @Input() public data: IIndividualHistory;\n  @Input() public graphHeight: number;\n  @Input() public minTime: Date;\n  @Input() public maxTime: Date;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, ITemporalEntity, BaseType, ITemporalEntity>;\n  private svg: Selection<BaseType, ITemporalEntity, BaseType, ITemporalEntity>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private x: ScaleTime<number, number>;\n  private dataChanges: BehaviorSubject<IIndividualHistory | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.dataChanges\n      .subscribe((value) => {\n        console.debug('Updating plot with:', this.data);\n        if (value !== undefined) {\n          this.plotData();\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const dataChange = changes['data'];\n    if (dataChange != null && (dataChange.previousValue !== dataChange.currentValue)) {\n      this.dataChanges.next(dataChange.currentValue);\n    }\n  }\n\n  private plotData(): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n\n    //    Build the domain values\n    console.debug('Building with data:', this.data);\n    const entityNames = this.data.entities.map((d) => d.label);\n    console.debug('Names:', entityNames);\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    const y = scaleBand()\n      .range([this.height, 0])\n      .domain(entityNames);\n    console.debug('Y values', y.range());\n    console.debug('Y values', y.domain());\n\n    const z = scaleOrdinal(schemeCategory10)\n      .domain(entityNames);\n\n    // Build the lane lines\n    this.svg.selectAll('.laneLine')\n      .data(this.data.entities.map((entity) => entity.label))\n      .enter().append('line')\n      .attr('class', 'laneLine')\n      .attr('x1', 0)\n      .attr('y1', (d) => y(d) || 0)\n      .attr('x2', this.width)\n      .attr('y2', (d) => y(d) || 0);\n\n    //    Build the Y-Axis\n    const ySelection = this.svg.selectAll('g.y-axis');\n    if (ySelection.empty()) {\n      this.svg\n        .append('g')\n        .attr('class', 'axis y-axis')\n        .call(axisLeft(y));\n    } else {\n      ySelection\n        .call(axisLeft(y));\n    }\n\n    // And the X-Axis\n    this.svg.select('.x-axis')\n      .call(axisBottom(this.x));\n\n    //    Add the data\n    const mainItems = this.svg.selectAll<SVGRectElement, Base>('.fact')\n      .data(this.data.entities, (entity: ITemporalEntity) => entity.label);\n\n    mainItems\n      .enter()\n      .append('rect')\n      .attr('class', 'fact')\n      .attr('x', (d) => this.normalizeAxis('x', this.x(d.start)))\n      .attr('y', (d) => y(d.label) || 0)\n      .attr('width',\n        (d) => {\n          const end = this.normalizeAxis('x',\n            this.x(this.maybeDate(d.end)));\n          const start = this.normalizeAxis('x',\n            this.x(d.start));\n          return end - start;\n        })\n      .attr('height', () => y.bandwidth())\n      // .style(\"fill\", (d: TrestleFact) => z(d.getName()))\n      .style('fill', (d) => z(d.label))\n      .style('fill-opacity', 0.7)\n      .merge(mainItems);\n\n    // Labels\n    const mainLabels = this.svg.selectAll<SVGTextElement, BaseType>('.mainLabels')\n      .data(this.data.entities, (d: ITemporalEntity) => d.label);\n\n    mainLabels\n      .enter()\n      .append('text')\n      .text((d) => HistoryGraphComponent.parseValue(d.value))\n      .attr('class', 'mainLabels')\n      .attr('x', (d) => {\n        const end = d.end;\n        const start = d.start;\n        const width = this.x(this.maybeDate(end)) - this.x(start);\n        return this.x(start) + width / 2;\n      })\n      .attr('y', (d) => (y(d.label) || 0) + y.bandwidth() - 5)\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.1ex')\n      .merge(mainLabels);\n\n    mainItems.exit().remove();\n    mainLabels.exit().remove();\n  }\n\n  private maybeDate(date: string | Date | undefined): Date {\n    if (date instanceof Date) {\n      return date;\n    }\n    if (date === undefined) {\n      return this.minTime;\n    }\n    if (date === '') {\n      return this.maxTime;\n    }\n    return new Date(date);\n  }\n\n  private static parseValue(value: string | number): string {\n    if (typeof value === 'number') {\n      return value.toString();\n    }\n    if (value.length > 20) {\n      return value.substring(0, 20) + '...';\n    }\n    return value;\n  }\n\n  private normalizeAxis(axis: 'x' | 'y', value: number): number {\n    // Normalize X Axis\n    if (axis === 'x') {\n      if (value < 0) {\n        return 0;\n      }\n      if (value > this.width) {\n        return this.width;\n      }\n      return value;\n    } else {\n      if (value < 0) {\n        return 0;\n      }\n      if (value > this.height) {\n        return this.height;\n      }\n      return value;\n    }\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, ITemporalEntity>(this.htmlElement);\n    this.margin = {top: 20, right: 30, bottom: 20, left: 150};\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = this.graphHeight - this.margin.top - this.margin.bottom;\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n\n    console.debug('D3 Initialized');\n  }\n}\n",
            "properties": [
                {
                    "name": "end",
                    "type": "Date",
                    "optional": true,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "label",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "start",
                    "type": "Date",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "value",
                    "type": "any",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleEvent",
            "id": "interface-ITrestleEvent-285cc34959ea8f022ef4bed8514e842a",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-event.ts",
            "type": "interface",
            "sourceCode": "import { IInterfacable } from \"../../interfacable\";\nimport moment from \"moment\";\n\nexport interface ITrestleEvent {\n    individual: string;\n    type: string;\n    temporal: string;\n}\n\nexport enum TrestleEventType {\n    CREATED,\n    DESTROYED,\n    BECAME,\n    SPLIT,\n    MERGED\n}\n\nexport class TrestleEvent implements IInterfacable<ITrestleEvent> {\n    private individual: string;\n    private type: string;\n    private temporal: moment.Moment;\n\n    constructor(event: ITrestleEvent) {\n        this.individual = event.individual;\n        this.type = event.type;\n        this.temporal = moment(event.temporal, moment.ISO_8601);\n    }\n\n    public getIndividual() {\n        return this.individual;\n    }\n\n    public getType() {\n        return this.type;\n    }\n\n    public getTemporal() {\n        return this.temporal;\n    }\n\n    public asInterface() {\n        return {\n            individual: this.individual,\n            type: this.type,\n            temporal: this.temporal.toISOString()\n        };\n    }\n}\n",
            "properties": [
                {
                    "name": "individual",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "temporal",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "type",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 6
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleFact",
            "id": "interface-ITrestleFact-1063ee5415de3590c6cca9ee652ce334",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-fact.ts",
            "type": "interface",
            "sourceCode": "import { ITrestleTemporal, TrestleTemporal } from \"./trestle-temporal\";\nimport { IInterfacable } from \"../../interfacable\";\nimport * as moment from \"moment\";\n\nexport interface ITrestleFact {\n    identifier: string;\n    name: string;\n    type: string;\n    value: string;\n    databaseTemporal: ITrestleTemporal;\n    validTemporal: ITrestleTemporal;\n}\n\nexport class TrestleFact implements IInterfacable<ITrestleFact> {\n    private identifier: string;\n    private name: string;\n    private type: string;\n    private value: string;\n    private databaseTemporal: TrestleTemporal;\n    private validTemporal: TrestleTemporal;\n\n    constructor(fact: ITrestleFact) {\n        this.identifier = fact.identifier;\n        this.name = fact.name;\n        this.type = fact.type;\n        this.value = fact.value;\n        this.databaseTemporal = new TrestleTemporal(fact.databaseTemporal);\n        this.validTemporal = new TrestleTemporal(fact.validTemporal);\n    }\n\n    public getID(): string {\n        return this.identifier;\n    }\n\n    public getName(): string {\n        return this.name;\n    }\n\n    public getValue(): string {\n        return this.value;\n    }\n\n    public getType(): string {\n        return this.type;\n    }\n\n    public getValidTemporal(): TrestleTemporal {\n        return this.validTemporal;\n    }\n\n    public getDatabaseTemporal(): TrestleTemporal {\n        return this.databaseTemporal;\n    }\n\n    public isSpatial(): boolean {\n        return this.name === \"asWKT\";\n    }\n\n    /**\n     * Is this fact active at the specified valid/database intersection\n     * @param {moment.Moment} validAt\n     * @param {moment.Moment} dbAt\n     * @returns {boolean}\n     */\n    public isActive(validAt: moment.Moment, dbAt?: moment.Moment): boolean {\n        if (dbAt) {\n            return this.getValidTemporal().isActive(validAt) &&\n                this.getDatabaseTemporal().isActive(dbAt);\n        } else {\n            return this.getValidTemporal().isActive(validAt);\n        }\n    }\n\n    public asInterface(): ITrestleFact {\n        return {\n            identifier: this.identifier,\n            name: this.name,\n            type: this.type,\n            value: this.value,\n            databaseTemporal: this.databaseTemporal.asInterface(),\n            validTemporal: this.validTemporal.asInterface()\n        };\n    }\n}\n",
            "properties": [
                {
                    "name": "databaseTemporal",
                    "type": "ITrestleTemporal",
                    "optional": false,
                    "description": "",
                    "line": 10
                },
                {
                    "name": "identifier",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "name",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "type",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "validTemporal",
                    "type": "ITrestleTemporal",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "value",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 9
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleIndividual",
            "id": "interface-ITrestleIndividual-a085e9f4989203c659d28b5a171482dc",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-individual.ts",
            "type": "interface",
            "sourceCode": "import { ITrestleTemporal, TrestleTemporal } from \"./trestle-temporal\";\nimport { ITrestleFact, TrestleFact } from \"./trestle-fact\";\nimport { ITrestleRelation, TrestleRelation } from \"./trestle-relation\";\nimport { ITrestleEvent, TrestleEvent } from \"./trestle-event\";\nimport { GeometryObject } from \"geojson\";\nimport { IInterfacable } from \"../../interfacable\";\nimport { parse } from \"wellknown\";\nimport SortedArray from 'sorted-array';\n\nexport interface ITrestleIndividual {\n    individualID: string;\n    existsTemporal: ITrestleTemporal;\n    facts: ITrestleFact[];\n    relations: ITrestleRelation[];\n    events: ITrestleEvent[];\n}\n\nexport class TrestleIndividual implements IInterfacable<ITrestleIndividual> {\n\n    private static suffixRegex = /.*[\\/#]([^\\/#]*)$/g;\n    private static prefixRegex = /.*[\\/#]/g;\n    private static hostnameRegex = /\\w+:\\/\\/[^\\/]*/g;\n    private readonly id: string;\n    private filteredID?: string;\n    private facts: SortedArray<TrestleFact>;\n    private spatialFact?: TrestleFact;\n    private relations: TrestleRelation[] = [];\n    private events: TrestleEvent[] = [];\n    private readonly existsTemporal: TrestleTemporal;\n\n    constructor(individual: ITrestleIndividual) {\n        this.id = individual.individualID;\n        this.facts = new SortedArray<TrestleFact>([], TrestleIndividual.factSort);\n        this.existsTemporal = new TrestleTemporal(individual.existsTemporal);\n        individual.facts.forEach((fact) => {\n            const factClass = new TrestleFact(fact);\n            // Set as spatial fact, if that's the case\n            if (factClass.isSpatial()) {\n                this.spatialFact = factClass;\n            }\n            this.facts.insert(factClass);\n        });\n        individual.relations.forEach((relation) => {\n            this.relations.push(new TrestleRelation(relation));\n        });\n        individual.events.forEach((event) => this.events.push(new TrestleEvent(event)));\n    }\n\n    /**\n     * Get Individual ID\n     * @returns {string}\n     */\n    public getID(): string {\n        return this.id;\n    }\n\n    /**\n     * Get the individual ID, without the URI base or temporal range\n     * @returns {string}\n     */\n    public getFilteredID(): string {\n        if (this.filteredID) {\n            return this.filteredID;\n        }\n        this.filteredID = TrestleIndividual.filterID(this.id);\n        return this.filteredID;\n    }\n\n    /**\n     * Gets the URI base of the individual ID\n     * @returns {string}\n     */\n    public getHostname(): string {\n        return TrestleIndividual.extractHostname(this.id);\n    }\n\n    /**\n     * Get the individual ID, without the URI base\n     * @returns {string}\n     */\n    public withoutHostname(): string {\n        return TrestleIndividual.withoutHostname(this.id);\n    }\n\n    /**\n     * Return the filtered individual ID as a hashed numeric value\n     * Currently using the SBDM algorithm\n     * @returns {number}\n     */\n    public getIDAsInteger(): number {\n        return TrestleIndividual.hashID(this.getFilteredID());\n    }\n\n    /**\n     * Get the Existence temporal for the individual\n     * @returns {TrestleTemporal}\n     */\n    public getTemporal(): TrestleTemporal {\n        return this.existsTemporal;\n    }\n\n    /**\n     * Get the spatial fact for the individual, parsed as a {GeometryObject}\n     * @returns {GeometryObject}\n     */\n    public getSpatialValue(): GeometryObject {\n\n        if (this.spatialFact) {\n            const geojson = parse(this.spatialFact.getValue());\n            if (geojson !== null) {\n                return geojson;\n            }\n            console.error(\"Failed to parse:\", this.spatialFact.getValue());\n        }\n        throw new Error(\"Individual \" + this.getID() + \" is not spatial and should be\");\n    }\n\n    /**\n     * Get the sptial fact for the indivdual, as a WKT string\n     * @returns {string}\n     */\n    public getSpatialValueAsWKT(): string {\n        if (this.spatialFact) {\n            return this.spatialFact.getValue();\n        }\n        throw new Error(\"Individual \" + this.getID() + \" is not spatial and should be\");\n    }\n\n    /**\n     * Get an {Iterable} of {TrestleFact} of all facts for the individual\n     * @returns {TrestleFact[]}\n     */\n    public getFacts(): TrestleFact[] {\n        return this.facts.array;\n    }\n\n    /**\n     * Returns a collection of fact names and associated values\n     * @returns {{[p: string]: any}}\n     */\n    public getFactValues(): { [name: string]: any } {\n        const values: { [name: string]: any } = {};\n        this.facts.array.forEach((value) => {\n            values[value.getName()] = value.getValue();\n        });\n        return values;\n    }\n\n    /**\n     * Get all Individual relations\n     * @returns {TrestleRelation[]}\n     */\n    public getRelations(): TrestleRelation[] {\n        return this.relations;\n    }\n\n    /**\n     * Get all individual events\n     * @returns {TrestleEvent[]}\n     */\n    public getEvents(): TrestleEvent[] {\n        return this.events;\n    }\n\n    /**\n     * Gets the start event for the given selection.\n     * Returns a MERGED event, if one exists\n     * Otherwise, returns CREATED\n     * @returns {TrestleEvent}\n     */\n    public getStartEvent(): TrestleEvent {\n        const mergedEvent = this.getEvents()\n            .filter((event) => event.getType() === \"MERGED\");\n\n        if (mergedEvent.length > 0) {\n            return mergedEvent[0];\n        }\n        const createdEvent = this.getEvents()\n            .filter((event) => event.getType() === \"CREATED\");\n        if (createdEvent.length > 0) {\n            return createdEvent[0];\n        }\n        throw new Error(\"Individual: \" + this.getID() + \" does not have a CREATED/MERGED event\");\n    }\n\n    /**\n     * Returns the end event, if one exists\n     * If a SPLIT event exists, returns that\n     * Otherwise, returns DESTROYED\n     * Returns\n     * @returns {TrestleEvent}\n     */\n    public getEndEvent(): TrestleEvent | null {\n        const splitEvent = this.getEvents()\n            .filter((event) => event.getType() === \"SPLIT\");\n        if (splitEvent.length > 0) {\n            return splitEvent[0];\n        }\n\n        const destroyedEvent = this.getEvents()\n            .filter((event) => event.getType() === \"DESTROYED\");\n        if (destroyedEvent.length > 0) {\n            return destroyedEvent[0];\n        }\n\n        return null;\n    }\n\n    /**\n     * Is this individual a part of a spatial union?\n     * @returns {boolean}\n     */\n    public isUnion(): boolean {\n        return this.relations.some((relation) => relation.isUnionType());\n    }\n\n    /**\n     * Transform the individual back into its Interface type\n     * @returns {ITrestleIndividual}\n     */\n    public asInterface(): ITrestleIndividual {\n        const returnValue: ITrestleIndividual = {\n            individualID: this.id,\n            existsTemporal: this.existsTemporal.asInterface(),\n            facts: [],\n            relations: [],\n            events: []\n        };\n        this.facts.array.forEach((value) => {\n            returnValue.facts.push(value.asInterface());\n        });\n        this.relations.forEach((value) => {\n            returnValue.relations.push(value.asInterface());\n        });\n        this.events.forEach((event) => returnValue.events.push(event.asInterface()));\n        return returnValue;\n    }\n\n    /**\n     * Remove dates from ID\n     * @param {string} id\n     * @returns {string}\n     */\n    public static filterID(id: string): string {\n        const suffix = TrestleIndividual.extractSuffix(id);\n        const idStrings = suffix.split(\":\");\n        // return idStrings[0] + \":\" + idStrings[1];\n        return idStrings[0];\n    }\n\n    /**\n     * Filter ID string to remove hostname (authority)\n     * @param {string} id\n     * @returns {string}\n     */\n    public static withoutHostname(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.hostnameRegex.lastIndex = 0;\n        return id.replace(TrestleIndividual.hostnameRegex, \"\");\n    }\n\n    /**\n     * Get the URI hostname\n     * Returns an empty string if nothing matches\n     * @param {string} id\n     * @returns {string}\n     */\n    public static extractHostname(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.hostnameRegex.lastIndex = 0;\n        const matches = id.match(TrestleIndividual.hostnameRegex);\n        if (matches !== null) {\n            return matches[0];\n        }\n        return \"\";\n    }\n\n\n    /**\n     * Extracts the suffix from the individual, or returns an empty string\n     * @param {string} id\n     * @returns {string}\n     */\n    public static extractSuffix(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.suffixRegex.lastIndex = 0;\n        const matches = TrestleIndividual.suffixRegex.exec(id);\n        if (matches !== null) {\n            return matches[1];\n        }\n        return \"\";\n    }\n\n    /**\n     * Extracts the prefix from the individual, or returns an empty string\n     * @param {string} id\n     * @returns {string}\n     */\n    public static extractPrefix(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.prefixRegex.lastIndex = 0;\n        const matches = id.match(TrestleIndividual.prefixRegex);\n        if (matches !== null) {\n            return matches[0];\n        }\n        return \"\";\n    }\n\n    /**\n     * SDBM algorithm for generating a numeric value of a provided string\n     * @param {string} id\n     * @returns {number}\n     */\n    public static hashID(id: string): number {\n        let hash = 0;\n        for (let i = 0; i < id.length; i++) {\n            const char = id.charCodeAt(i);\n            // eslint-disable-next-line no-bitwise\n            hash = char + (hash << 6) + (hash << 16) - hash;\n        }\n        return hash;\n    }\n\n    /**\n     * Sorter for the Fact array which sorts by ID -> validFrom -> dbFrom\n     *\n     * @param {TrestleFact} a\n     * @param {TrestleFact} b\n     * @returns {number}\n     */\n    private static factSort(a: TrestleFact, b: TrestleFact): number {\n        const idCompare = a.getID().localeCompare(b.getID());\n        // If they're not equal, return\n        if (idCompare !== 0) {\n            return idCompare;\n        }\n        //    Next, compare on valid from\n        const vEqual = a.getValidTemporal().getFrom().isSame(b.getValidTemporal().getFrom());\n        // If they're not equal, is A before?\n        if (!vEqual) {\n            return a.getValidTemporal().getFrom().isBefore(b.getValidTemporal().getFrom()) ? -1 : 1;\n        }\n        //    Finally, db time\n        const dEqual = a.getDatabaseTemporal().getFrom().isSame(b.getDatabaseTemporal().getFrom());\n        if (!dEqual) {\n            return a.getDatabaseTemporal().getFrom().isBefore(b.getDatabaseTemporal().getFrom()) ? -1 : 1;\n        }\n        return 0;\n    }\n}\n",
            "properties": [
                {
                    "name": "events",
                    "type": "ITrestleEvent[]",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "existsTemporal",
                    "type": "ITrestleTemporal",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "facts",
                    "type": "ITrestleFact[]",
                    "optional": false,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "individualID",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "relations",
                    "type": "ITrestleRelation[]",
                    "optional": false,
                    "description": "",
                    "line": 14
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleMapLayers",
            "id": "interface-ITrestleMapLayers-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "fill",
                    "type": "IMapFillLayer",
                    "optional": true,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "hover",
                    "type": "IMapHoverLayer",
                    "optional": true,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "line",
                    "type": "IMapLineLayer",
                    "optional": true,
                    "description": "",
                    "line": 41
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleMapSource",
            "id": "interface-ITrestleMapSource-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "properties": [
                {
                    "name": "data",
                    "type": "FeatureCollection<GeometryObject> | Feature<GeometryObject>",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 46
                },
                {
                    "name": "idField",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "labelField",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "labelFunction",
                    "type": "function",
                    "optional": true,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "labelValue",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 52
                },
                {
                    "name": "layers",
                    "type": "ITrestleMapLayers",
                    "optional": true,
                    "description": "",
                    "line": 49
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleMetricsHeader",
            "id": "interface-ITrestleMetricsHeader-2df419d1f3a9f8f616352bc29217c0ea",
            "file": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {HttpClient, HttpHeaders} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {Observable, throwError} from 'rxjs';\nimport {catchError, map, tap} from 'rxjs/operators';\n\nexport interface ITrestleMetricsHeader {\n  upTime: number;\n  startTime: number;\n  meters: Map<string, string>;\n}\n\nexport interface IMetricsData {\n  metric: string;\n  values: IMetricsValue[];\n}\n\nexport interface IMetricsValue {\n  timestamp: Date;\n  value: number;\n}\n\n@Injectable()\nexport class MetricsService {\n\n  private readonly baseUrl: string;\n\n  constructor(private authHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get initial data about available metrics\n   * @returns {Observable<ITrestleMetricsHeader>}\n   */\n  public getMetrics(): Observable<ITrestleMetricsHeader> {\n    return this.authHttp.get<ITrestleMetricsHeader>(this.baseUrl + '/metrics')\n      .pipe(catchError((error: Error) => throwError(error || 'Server Error')));\n  }\n\n  /**\n   * Get values for a specified metric ID that falls within the given range\n   * @param {string} metricID to fetch\n   * @param {number} start of temporal period for metrics data\n   * @param {number} end of temporal period for metrics data\n   * @returns {Observable<IMetricsData>}\n   */\n  public getMetricValues(metricID: string, start: number, end: number): Observable<IMetricsData> {\n    console.debug('Retrieving values for metric: ' + metricID + ' from: ' + start + ' to: ' + end);\n    const params = new HttpHeaders();\n    params.append('start', start.toString());\n    params.append('end', end.toString());\n    return this.authHttp.get(this.baseUrl + '/metrics/metric/' + metricID, {\n      params: {\n        start: start.toString(),\n        end: end.toString()\n      }\n    })\n      .pipe(\n        tap(json => console.debug('Metric values:', json)),\n        map(json => {\n          const metricValues: IMetricsValue[] = [];\n          Object.keys(json).forEach((key) => {\n            const longKey = parseInt(key, 10);\n            if (longKey !== 0) {\n              metricValues.push({\n                timestamp: new Date(longKey),\n                value: json[longKey]\n              });\n            }\n          });\n          return {\n            metric: metricID,\n            values: metricValues.sort((a, b) => {\n              if (a.timestamp === b.timestamp) {\n                return 0;\n              }\n              if (a.timestamp < b.timestamp) {\n                return -1;\n              }\n              return 1;\n            })\n          };\n        }));\n  }\n\n  /**\n   * Export the given metric values as a CSV file\n   * @param {string[] | null} metrics to export\n   * @param {number} start of temporal period\n   * @param {number} end of temporal period\n   * @returns {Observable<Blob>}\n   */\n  public exportMetricValues(metrics: null | string[], start: number, end?: number): Observable<Blob> {\n    return this.authHttp.post(this.baseUrl + '/metrics/export', {\n        metrics,\n        start,\n        end\n      },\n      {\n        responseType: 'blob'\n      });\n  }\n}\n",
            "properties": [
                {
                    "name": "meters",
                    "type": "Map<string | string>",
                    "optional": false,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "startTime",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "upTime",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 11
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleRelation",
            "id": "interface-ITrestleRelation-f704aa8a4bbee67067723ca45bee3a1a",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-relation.ts",
            "type": "interface",
            "sourceCode": "import { IInterfacable } from \"../../interfacable\";\n\nexport interface ITrestleRelation {\n    subject: string;\n    object: string;\n    relation: string;\n}\n\nexport type TrestleRelationType =\n    \"CONTAINS\"\n    | \"COVERS\"\n    | \"DISJOINT\"\n    | \"EQUALS\"\n    | \"INSIDE\"\n    | \"MEETS\"\n    | \"SPATIAL_OVERLAPS\"\n    | \"AFTER\"\n    | \"BEFORE\"\n    | \"BEGINS\"\n    | \"DURING\"\n    | \"ENDS\"\n    | \"TEMPORAL_OVERLAPS\"\n    | \"SPLIT_INTO\"\n    | \"SPLIT_FROM\"\n    | \"MERGED_INTO\"\n    | \"MERGED_FROM\"\n    | \"COMPONENT_WITH\";\n\n// export enum TrestleRelationType {\n//     // Spatial\n//     CONTAINS,\n//     COVERS,\n//     DISJOINT,\n//     EQUALS,\n//     INSIDE,\n//     MEETS,\n//     SPATIAL_OVERLAPS,\n//     // Temporal\n//     AFTER,\n//     BEFORE,\n//     BEGINS,\n//     DURING,\n//     ENDS,\n//     TEMPORAL_OVERLAPS,\n//     SPLIT_INTO,\n//     SPLIT_FROM,\n//     MERGED_INTO,\n//     MERGED_FROM\n// }\n\nexport class TrestleRelation implements IInterfacable<ITrestleRelation> {\n    private subject: string;\n    private object: string;\n    private type: TrestleRelationType;\n\n    constructor(relation: ITrestleRelation) {\n        this.subject = relation.subject;\n        this.object = relation.object;\n        this.type = (relation.relation as TrestleRelationType);\n    }\n\n    public getSubject(): string {\n        return this.subject;\n    }\n\n    public getObject(): string {\n        return this.object;\n    }\n\n    public getType(): TrestleRelationType {\n        return this.type;\n    }\n\n    /**\n     * Is this relation part of a SpatialUnion?\n     * @returns {boolean}\n     */\n    public isUnionType(): boolean {\n        return (this.type === \"SPLIT_INTO\") ||\n            (this.type === \"SPLIT_FROM\") ||\n            (this.type === \"MERGED_INTO\") ||\n            (this.type === \"MERGED_FROM\") ||\n            (this.type === \"COMPONENT_WITH\");\n    }\n\n    public asInterface(): ITrestleRelation {\n        return {\n            subject: this.getSubject(),\n            object: this.getObject(),\n            relation: this.getType()\n        };\n    }\n}\n",
            "properties": [
                {
                    "name": "object",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "relation",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "subject",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 4
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleResult",
            "id": "interface-ITrestleResult-1b9faf03383110567576e673bda9c262",
            "file": "src/main/webapp/src/app/explore/query/query.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\n\nexport interface ITrestleResultSet {\n  rows: number;\n  bindingNames: Array<string>;\n  results: Array<ITrestleResult>;\n}\n\nexport interface ITrestleResult {\n  resultValues: Map<string, string>;\n}\n\n@Injectable()\nexport class QueryService {\n\n  private readonly baseUrl: string;\n\n  constructor(private trestleHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get currently registered prefixes from the database\n   * @returns {Observable<any>}\n   */\n  public getPrefixes(): Observable<any> {\n    return this.trestleHttp.get(this.baseUrl+ '/query');\n  }\n\n  /**\n   * Execute SPARQL query and return the results\n   * @param {string} queryString\n   * @returns {Observable<ITrestleResultSet>}\n   */\n  public executeQuery(queryString: string): Observable<ITrestleResultSet> {\n    console.debug('Query string:', queryString);\n    return this.trestleHttp.post<ITrestleResultSet>(this.baseUrl+ '/query', queryString);\n  }\n}\n",
            "properties": [
                {
                    "name": "resultValues",
                    "type": "Map<string | string>",
                    "optional": false,
                    "description": "",
                    "line": 16
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleResultSet",
            "id": "interface-ITrestleResultSet-1b9faf03383110567576e673bda9c262",
            "file": "src/main/webapp/src/app/explore/query/query.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\n\nexport interface ITrestleResultSet {\n  rows: number;\n  bindingNames: Array<string>;\n  results: Array<ITrestleResult>;\n}\n\nexport interface ITrestleResult {\n  resultValues: Map<string, string>;\n}\n\n@Injectable()\nexport class QueryService {\n\n  private readonly baseUrl: string;\n\n  constructor(private trestleHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get currently registered prefixes from the database\n   * @returns {Observable<any>}\n   */\n  public getPrefixes(): Observable<any> {\n    return this.trestleHttp.get(this.baseUrl+ '/query');\n  }\n\n  /**\n   * Execute SPARQL query and return the results\n   * @param {string} queryString\n   * @returns {Observable<ITrestleResultSet>}\n   */\n  public executeQuery(queryString: string): Observable<ITrestleResultSet> {\n    console.debug('Query string:', queryString);\n    return this.trestleHttp.post<ITrestleResultSet>(this.baseUrl+ '/query', queryString);\n  }\n}\n",
            "properties": [
                {
                    "name": "bindingNames",
                    "type": "Array<string>",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "results",
                    "type": "Array<ITrestleResult>",
                    "optional": false,
                    "description": "",
                    "line": 12
                },
                {
                    "name": "rows",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 10
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleRoute",
            "id": "interface-ITrestleRoute-34ee3146f607917b7feef53c74f6a6a8",
            "file": "src/main/webapp/src/app/navigation/navigation.module.ts",
            "type": "interface",
            "sourceCode": "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NavigationComponent } from './navigation/navigation.component';\nimport { LoginComponent } from './login/login.component';\nimport {MaterialModule} from \"../material/material.module\";\nimport {FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {Route, RouterModule} from '@angular/router';\nimport {Privileges} from '../user/trestle-user';\nimport { SidebarComponent } from './sidebar/sidebar.component';\nimport { TopNavComponent } from './top-nav/top-nav.component';\nimport {FontAwesomeModule} from '@fortawesome/angular-fontawesome';\nimport { UserIconComponent } from './user-icon/user-icon.component';\n\nexport interface ITrestleRoute extends Route {\n  data?: ITrestleRouteData\n}\n\nexport interface ITrestleRouteData {\n  roles: Privileges[];\n}\n\n@NgModule({\n  declarations: [NavigationComponent, LoginComponent, SidebarComponent, TopNavComponent, UserIconComponent],\n  imports: [\n    CommonModule,\n    MaterialModule,\n    FormsModule,\n    ReactiveFormsModule,\n    RouterModule,\n    FontAwesomeModule\n  ],\n  exports: [\n    NavigationComponent,\n    LoginComponent,\n    SidebarComponent,\n    TopNavComponent\n  ]\n})\nexport class NavigationModule { }\n",
            "properties": [
                {
                    "name": "data",
                    "type": "ITrestleRouteData",
                    "optional": true,
                    "description": "",
                    "line": 15
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": [],
            "extends": "Route"
        },
        {
            "name": "ITrestleRouteData",
            "id": "interface-ITrestleRouteData-34ee3146f607917b7feef53c74f6a6a8",
            "file": "src/main/webapp/src/app/navigation/navigation.module.ts",
            "type": "interface",
            "sourceCode": "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NavigationComponent } from './navigation/navigation.component';\nimport { LoginComponent } from './login/login.component';\nimport {MaterialModule} from \"../material/material.module\";\nimport {FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {Route, RouterModule} from '@angular/router';\nimport {Privileges} from '../user/trestle-user';\nimport { SidebarComponent } from './sidebar/sidebar.component';\nimport { TopNavComponent } from './top-nav/top-nav.component';\nimport {FontAwesomeModule} from '@fortawesome/angular-fontawesome';\nimport { UserIconComponent } from './user-icon/user-icon.component';\n\nexport interface ITrestleRoute extends Route {\n  data?: ITrestleRouteData\n}\n\nexport interface ITrestleRouteData {\n  roles: Privileges[];\n}\n\n@NgModule({\n  declarations: [NavigationComponent, LoginComponent, SidebarComponent, TopNavComponent, UserIconComponent],\n  imports: [\n    CommonModule,\n    MaterialModule,\n    FormsModule,\n    ReactiveFormsModule,\n    RouterModule,\n    FontAwesomeModule\n  ],\n  exports: [\n    NavigationComponent,\n    LoginComponent,\n    SidebarComponent,\n    TopNavComponent\n  ]\n})\nexport class NavigationModule { }\n",
            "properties": [
                {
                    "name": "roles",
                    "type": "Privileges[]",
                    "optional": false,
                    "description": "",
                    "line": 19
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleTemporal",
            "id": "interface-ITrestleTemporal-e4e58ce405c36ddd6b30dc18ac39be1d",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-temporal.ts",
            "type": "interface",
            "sourceCode": "import { IInterfacable } from \"../../interfacable\";\nimport moment from \"moment\";\n\nexport interface ITrestleTemporal {\n    ID: string;\n    From: Date;\n    To?: Date | string;\n}\n\nexport class TrestleTemporal implements IInterfacable<ITrestleTemporal> {\n    private id: string;\n    private from: moment.Moment;\n    private to?: moment.Moment;\n\n    constructor(temporal: ITrestleTemporal) {\n        this.id = temporal.ID;\n        this.from = moment(temporal.From, moment.ISO_8601);\n        // There's a problem with our serialization, which means these things might end up as strings, which is no good.\n        if (temporal.To !== null && temporal.To !== \"\") {\n            this.to = moment.utc(temporal.To, moment.ISO_8601);\n        }\n    }\n\n    public getID(): string {\n        return this.id;\n    }\n\n    public getFrom(): moment.Moment {\n        return this.from;\n    }\n\n    public getFromAsDate(): Date {\n        return this.from.toDate();\n    }\n\n    public getTo(): moment.Moment | undefined {\n        return this.to;\n    }\n\n    public getToAsDate(): Date | undefined {\n        if (this.to) {\n            return this.to.toDate();\n        }\n        return undefined;\n    }\n\n    public isContinuing(): boolean {\n        return this.to === undefined || !this.to.isValid();\n    }\n\n    /**\n     * Does the specified temporal fall within the interval of this TemporalObject?\n     * @param {moment.Moment} temporal\n     * @returns {boolean}\n     */\n    public isActive(temporal: moment.Moment): boolean {\n        if (this.to === undefined) {\n            return this.from.isSameOrBefore(temporal);\n        } else {\n            return this.from.isSameOrBefore(temporal) &&\n                this.to.isAfter(temporal);\n        }\n    }\n\n    public asInterface(): ITrestleTemporal {\n        const returnValue: ITrestleTemporal = {\n            ID: this.id,\n            From: this.from.toDate()\n        };\n        if (!this.isContinuing() && (this.to !== undefined)) {\n            returnValue.To = this.to.toDate();\n        }\n        return returnValue;\n    }\n}\n",
            "properties": [
                {
                    "name": "From",
                    "type": "Date",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "ID",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "To",
                    "type": "Date | string",
                    "optional": true,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "ITrestleUser",
            "id": "interface-ITrestleUser-d55204a2468f4b26ef24d320e0b84ac4",
            "file": "src/main/webapp/src/app/user/authentication.service.ts",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {Privileges, TrestleUser} from './trestle-user';\nimport {HttpClient} from '@angular/common/http';\nimport {JwtHelperService} from '@auth0/angular-jwt';\nimport {environment} from '../../environments/environment';\nimport {Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nconst _key: string = 'access_token';\n\nexport class TrestleToken {\n\n  private readonly exp: number;\n  private readonly iat: number;\n  private readonly user: ITrestleUser;\n\n  public constructor(token: any) {\n    this.exp = token['exp'];\n    this.iat = token['iat'];\n    this.user = JSON.parse(token['data4j']);\n  }\n\n  /**\n   * Get token expiration time (in ms from Unix epoch)\n   * @returns {number}\n   */\n  public getExpiration() {\n    return this.exp;\n  }\n\n  /**\n   * Get issuance time (in ms from Unix epoch)\n   * @returns {number}\n   */\n  public getIssue() {\n    return this.iat;\n  }\n\n  /**\n   * Get the user from the token\n   * @returns {ITrestleUser}\n   */\n  public getUser() {\n    return this.user;\n  }\n}\n\nexport interface ITrestleUser {\n  id?: number;\n  firstName: string;\n  lastName: string;\n  username: string;\n  email: string;\n  password: string;\n  privileges: number;\n}\n\n@Injectable()\nexport class AuthService {\n\n  private jwtHelper: JwtHelperService;\n  private readonly baseUrl;\n\n  constructor(private router: Router, private http: HttpClient) {\n    this.jwtHelper = new JwtHelperService();\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Attempt to login the given use\n   * @param {string} username\n   * @param {string} password\n   */\n  public login(username: string, password: string): Observable<{ user: TrestleUser, token: string }> {\n    return this.http.post(this.baseUrl + '/auth/login', {username, password: password}, {\n      responseType: 'text'\n    })\n      .pipe(map(token => {\n        const t = this.getToken2(token);\n        return {user: new TrestleUser(t.getUser()), token}\n      }));\n  }\n\n  /**\n   * Logout the user\n   */\n  public logout(): Observable<string> {\n    console.debug(\"Logging out\");\n    return this.http.post(this.baseUrl + '/auth/logout', null, {\n      responseType: 'text'\n    });\n  }\n\n  /**\n   * Is the user currently logged in?\n   * @returns {boolean}\n   */\n  public loggedIn(): boolean {\n    const token = localStorage.getItem(_key);\n    if (token) {\n      console.debug(\n        this.jwtHelper.decodeToken(token),\n        this.jwtHelper.getTokenExpirationDate(token),\n        this.jwtHelper.isTokenExpired(token)\n      );\n    }\n    return !this.jwtHelper.isTokenExpired(token);\n  }\n\n  /**\n   * Does the user have AT LEAST Admin permissions?\n   * @returns {boolean}\n   */\n  public isAdmin(): boolean {\n    if (this.loggedIn()) {\n      const token = this.getToken();\n      // eslint-disable-next-line no-bitwise\n      return (token !== null) && ((token.getUser().privileges & Privileges.ADMIN) > 0);\n    }\n    return false;\n  }\n\n  /**\n   * Get the user, if one exists\n   * @returns {TrestleUser | null}\n   */\n  public getUser(): TrestleUser | null {\n    if (this.loggedIn()) {\n      const token = this.getToken();\n      if (token) {\n        return new TrestleUser(token.getUser());\n      }\n    }\n    console.error('User is not logged in');\n    return null;\n  }\n\n  /**\n   * Determines if the logged-in user has the necessary roles to perform a certain function\n   * @param roles - Array of required Privileges\n   * @returns {boolean} - has all the required roles\n   */\n  public hasRequiredRoles(roles: Privileges[]): boolean {\n    const user = this.getUser();\n    if (user == null) {\n      return false;\n    }\n\n    return user.hasRequiredPrivileges(roles);\n  }\n\n  public getEncodedToken(): string | null {\n    return localStorage.getItem(_key);\n  }\n\n  private getToken(): TrestleToken | null {\n    const jwtToken = this.getEncodedToken();\n    if (jwtToken) {\n      return new TrestleToken(this.jwtHelper.decodeToken(jwtToken));\n    }\n    return null;\n  }\n\n  private getToken2 = (jwtToken: string): TrestleToken => {\n    return new TrestleToken(this.jwtHelper.decodeToken(jwtToken));\n  };\n}\n",
            "properties": [
                {
                    "name": "email",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 57
                },
                {
                    "name": "firstName",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "id",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "lastName",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "password",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "privileges",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "username",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 56
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IUserDialogResponse",
            "id": "interface-IUserDialogResponse-595593fc6ebf0bd9a187ba0022f5426c",
            "file": "src/main/webapp/src/app/admin/users/users.dialog.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AbstractControl, FormBuilder, FormGroup, ValidationErrors, Validators} from '@angular/forms';\nimport {ITrestleUser} from '../../user/authentication.service';\nimport {UserService} from '../../user/users.service';\nimport {MatDialogRef} from '@angular/material/dialog';\nimport {Observable, of, timer} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\nimport {Privileges} from '../../user/trestle-user';\n\nexport enum UserDialogResponseType {\n  ADD,\n  DELETE\n}\n\nexport interface IUserDialogResponse {\n  type: UserDialogResponseType;\n  user: ITrestleUser;\n}\n\n@Component({\n  selector: 'user-add-dialog',\n  templateUrl: './users.dialog.component.html',\n  styleUrls: ['./users.dialog.component.scss'],\n  providers: [UserService]\n})\nexport class UserDialogComponent implements OnInit {\n  public privileges: Map<string, number> = new Map();\n  public user: ITrestleUser;\n  public updateMode = true;\n  public registerForm: FormGroup;\n  public maxPasswordLength = 60;\n\n  constructor(public dialogRef: MatDialogRef<UserDialogComponent>,\n              private userService: UserService,\n              private formBuilder: FormBuilder) {\n//    Try to list all the enum keys\n    for (const priv in Privileges) {\n      if (parseInt(priv, 10) >= 0) {\n        console.debug('Privs:', priv, Privileges[priv]);\n        this.privileges.set(Privileges[priv], parseInt(priv, 10));\n      }\n    }\n  }\n\n  public ngOnInit(): void {\n    // Merge the user object (which might be null) with a blank default\n    const mergedUser = {\n      ...{\n        firstName: '',\n        lastName: '',\n        username: '',\n        password: '',\n        email: '',\n        privileges: 1\n      }, ...this.user\n    };\n\n    console.debug('Merged user:', mergedUser);\n    //    Create the form\n    this.registerForm = this.formBuilder.group({\n      firstName: mergedUser.firstName,\n      lastName: mergedUser.lastName,\n      username: [mergedUser.username, undefined, this.validateUser],\n      password: [mergedUser.password, this.validatePasswordLength],\n      email: [mergedUser.email, Validators.email]\n    });\n    if (this.user == undefined || this.user.id === undefined) {\n      this.updateMode = false;\n      console.debug('Passed null user, creating blank instance');\n      this.user = {\n        username: '',\n        password: '',\n        firstName: '',\n        lastName: '',\n        email: '',\n        privileges: 1\n      };\n    }\n  }\n\n  /**\n   * Are we currently set to update the user?\n   * @returns {boolean}\n   */\n  public isUpdate(): boolean {\n    return this.updateMode;\n  }\n\n  /**\n   * Save the new/updated user to the database\n   */\n  public save() {\n    if (this.registerForm.valid) {\n      // Construct a new user object\n      const mergedUser = {\n        ...this.user,\n        ...this.registerForm.value\n      };\n      this.userService.modifyUser(mergedUser).subscribe(data => {\n        console.debug('Response to add:', data);\n        const responseID = parseInt(data, 10);\n        if (!this.isUpdate()) {\n          mergedUser.id = responseID;\n        }\n        this.dialogRef.close({\n          type: UserDialogResponseType.ADD,\n          user: mergedUser\n        });\n      }, (err: Error) => console.error(err));\n    }\n  }\n\n  /**\n   * Delete the specified user from the database\n   */\n  public delete() {\n    if (this.user.id !== undefined) {\n      this.userService\n        .deleteUser(this.user.id)\n        .subscribe(() => this.dialogRef.close({\n            type: UserDialogResponseType.DELETE,\n            user: this.user\n          }),\n          (err: Error) => console.error(err));\n    } else {\n      console.error('Tried to save a user, but the ID was null');\n    }\n  }\n\n  /**\n   * Dismiss modal, without saving any changes\n   */\n  public dismiss() {\n    this.dialogRef.close(null);\n  }\n\n  /**\n   * Change permission level of the user to the given values\n   * @param {Privileges} level\n   */\n  public alterPermissionLevel(level: Privileges): void {\n    // eslint-disable-next-line no-bitwise\n    this.user.privileges = this.user.privileges ^ level;\n  }\n\n  /**\n   * Does the user currently have the given permission?\n   * @param {Privileges} privilage to check\n   * @returns {boolean}\n   */\n  public isSelected(privilage: Privileges): boolean {\n    // eslint-disable-next-line no-bitwise\n    return (this.user.privileges & privilage) > 0;\n  }\n\n  public getEmailErrorMessage(): string {\n    if (this.registerForm.controls['email'].hasError('required')) {\n      return 'Value is required';\n    }\n    if (this.registerForm.controls['email'].hasError('email')) {\n      return 'Not a valid email address';\n    }\n    return '';\n  }\n\n  public showLengthHint(value?: string): boolean {\n    if (value) {\n      if (this.isUpdate() && value.length === 60) {\n        return false;\n      }\n      // Warn at 70% length\n      if ((value.length / this.maxPasswordLength) > 0.7) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public getPasswordErrorMessage(): string {\n    if (this.registerForm.controls['password'].hasError('maxLength')) {\n      return 'Password too long';\n    }\n\n    if (this.registerForm.controls['password'].hasError('required')) {\n      return 'Value is required';\n    }\n\n    return '';\n  }\n\n  public getUsernameErrorMessage(): string {\n    if (this.registerForm.controls['username'].hasError('required')) {\n      return 'Value is required';\n    }\n    if (this.registerForm.controls['username'].hasError('userExists')) {\n      return 'Username taken';\n    }\n    return '';\n  }\n\n  public validateUser = (c: AbstractControl): Observable<ValidationErrors | null> => {\n    if (this.isUpdate() || c.value === null || c.value === '') {\n      console.debug('Returning');\n      return of(null);\n    }\n    return timer(500)\n      .pipe(\n        switchMap(() => {\n          return this.userService.userExists(c.value)\n            .pipe(\n              map((exists) => {\n                console.debug('User exists?', exists);\n                return exists ? ({\n                  userExists: {\n                    value: c.value\n                  }\n                } as ValidationErrors) : null;\n              }));\n        }));\n  };\n\n  public validatePasswordLength = (c: AbstractControl): null | ValidationErrors => {\n    if (c.value === null || c.value === '') {\n      return null;\n    }\n\n    // If we're update and the password length is max, that's fine\n    if (this.isUpdate() && c.value.length === this.maxPasswordLength) {\n      return null;\n    }\n\n    //    Finally, validate it\n    return c.value.length <= this.maxPasswordLength ? null : {\n      maxLength: {\n        value: true\n      }\n    };\n  };\n}\n",
            "properties": [
                {
                    "name": "type",
                    "type": "UserDialogResponseType",
                    "optional": false,
                    "description": "",
                    "line": 19
                },
                {
                    "name": "user",
                    "type": "ITrestleUser",
                    "optional": false,
                    "description": "",
                    "line": 20
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IUserLogin",
            "id": "interface-IUserLogin-b6a9028684b293f94093c8d322e3004a",
            "file": "src/main/webapp/src/app/navigation/login/login.component.ts",
            "type": "interface",
            "sourceCode": "import {Component, OnDestroy, OnInit} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {FormBuilder, FormGroup, Validators} from '@angular/forms';\nimport {animate, state, style, transition, trigger} from '@angular/animations';\nimport {AuthService} from '../../user/authentication.service';\nimport {selectErrorFromUser, State} from '../../reducers';\nimport {select, Store} from '@ngrx/store';\nimport {Subscription} from 'rxjs';\nimport {login} from '../../actions/auth.actions';\nimport {HttpErrorResponse} from '@angular/common/http';\n\ninterface IUserLogin {\n  username: string;\n  password: string;\n}\n\n@Component({\n  selector: 'login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.scss'],\n  animations: [\n    trigger('errorMessage', [\n      state('inactive', style({\n        backgroundColor: 'white'\n      })),\n      state('active', style({\n        backgroundColor: 'red'\n      })),\n      transition('inactive => active', animate('100ms ease-in')),\n      transition('active => inactive', animate('100ms ease-out'))\n    ])\n  ]\n})\n\nexport class LoginComponent implements OnInit, OnDestroy {\n  public loginForm: FormGroup;\n  public errorMessage: string;\n  public errorState: string;\n  private returnUrl: string;\n  private errorSubscription: Subscription;\n\n  constructor(private fb: FormBuilder, private authService: AuthService, private route: ActivatedRoute, private router: Router, private store: Store<State>) {\n    // Not used\n  }\n\n  public ngOnInit(): void {\n\n    this.errorSubscription = this.store\n      .pipe(select(selectErrorFromUser))\n        .subscribe((result) => {\n          if (result) {\n            this.errorState = 'active';\n            this.errorMessage = LoginComponent.parseErrorMessage(result);\n          } else {\n            this.errorState = 'inactive';\n            this.errorMessage = '';\n          }\n        });\n\n    this.authService.logout();\n    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';\n    this.loginForm = this.fb.group({\n      username: [null, Validators.required],\n      password: [null, Validators.required]\n    });\n    this.errorMessage = '';\n    this.errorState = 'inactive';\n  }\n\n  public ngOnDestroy(): void {\n    this.errorSubscription.unsubscribe();\n  }\n\n  /**\n   * Attempt to login the given user\n   * @param {IUserLogin} user\n   */\n  public login(user: IUserLogin) {\n    this.store.dispatch(login({username: user.username, password: user.password, returnUrl: this.returnUrl}));\n  }\n\n  private static parseErrorMessage(error: Error): string {\n    if (error instanceof HttpErrorResponse && error.status == 401) {\n      return \"Incorrect Username or Password\";\n    }\n    return error.message;\n  }\n}\n",
            "properties": [
                {
                    "name": "password",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "username",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 16
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "IUserTable",
            "id": "interface-IUserTable-8f405157dc9cae5d0d69669519868a86",
            "file": "src/test/e2e/page_objects/user.details.modal.ts",
            "type": "interface",
            "sourceCode": "import { browser, by, element, ElementFinder } from \"protractor\";\n\nexport interface IUserTable {\n    username?: string,\n    password?: string,\n    first_name?: string,\n    last_name?: string,\n    email?: string;\n}\n\nexport type UserType = \"user\" | \"admin\" | \"dba\";\n\nexport class UserDetailsModal {\n\n    private userNameInput: ElementFinder;\n    private passwordInput: ElementFinder;\n    private firstNameInput: ElementFinder;\n    private lastNameInput: ElementFinder;\n    private emailInput: ElementFinder;\n\n    public constructor() {\n        this.userNameInput = element(by.css(\"input[formcontrolname='username']\"));\n        this.passwordInput = element(by.css(\"input[formcontrolname='password']\"));\n        this.firstNameInput = element(by.css(\"input[formcontrolname='firstName']\"));\n        this.lastNameInput = element(by.css(\"input[formcontrolname='lastName']\"));\n        this.emailInput = element(by.css(\"input[formcontrolname='email']\"));\n    }\n\n    /**\n     * Create a new user of the given type with the provided data\n     * Assumes the modal is already open, but closes it in order to submit the data\n     *\n     * @param {UserType} userType - user type to add\n     * @param {IUserTable} user - User data\n     * @returns {Promise<any>} - Returns when the modal closes (waits 500ms)\n     */\n    public async createUser(userType: UserType, user: IUserTable) {\n        // Wait for the modal to load\n        await browser.sleep(500);\n        await this.userNameInput.sendKeys(user.username || \"\");\n        await this.passwordInput.sendKeys(user.password || \"\");\n        await this.firstNameInput.sendKeys(user.first_name || \"\");\n        await this.lastNameInput.sendKeys(user.last_name || \"\");\n        await this.emailInput.sendKeys(user.email || \"\");\n\n        //    Now the permissions, select everything lower\n        switch (userType) {\n            case \"dba\": {\n                await UserDetailsModal.selectUserPermission(\"dba\");\n                await UserDetailsModal.selectUserPermission(\"admin\");\n                break;\n            }\n            case \"admin\": {\n                await UserDetailsModal.selectUserPermission(\"admin\");\n                break;\n            }\n            case \"user\": {\n                break;\n            }\n        }\n        return Promise.resolve(undefined);\n    }\n\n    /**\n     * Update the given properties of the user\n     * Assumes the modal is already open, but closes it in order to submit the changes\n     *\n     * @param {IUserTable} user - User data to update\n     * @returns {Promise<any>} - returns when the modal is closed (waits 500ms)\n     */\n    public async editUser(user: IUserTable) {\n        // Wait for the modal to load\n        await browser.sleep(500);\n        // We have to clear the input fields before\n        if (user.username) {\n            await this.userNameInput.clear();\n            await this.userNameInput.sendKeys(user.username);\n        }\n\n        if (user.email) {\n            await this.emailInput.clear();\n            await this.emailInput.sendKeys(user.email);\n        }\n\n        if (user.password) {\n            await this.passwordInput.clear();\n            await this.passwordInput.sendKeys(user.password);\n        }\n\n        if (user.first_name) {\n            await this.firstNameInput.clear();\n            await this.firstNameInput.sendKeys(user.first_name);\n        }\n\n        if (user.last_name) {\n            await this.lastNameInput.clear();\n            await this.lastNameInput.sendKeys(user.last_name);\n        }\n\n        element(by.buttonText(\"Update User\")).click();\n        // Sleep for 500 ms to let the modal close\n        return browser.sleep(500);\n    }\n\n    /**\n     * Delete the given user\n     * Assumes the modal is already open, but closes it in order to submit the changes\n     *\n     * @returns {any} - Returns when the modal closes\n     */\n    public async deleteUser() {\n        // Wait for the modal to load\n        await browser.sleep(500);\n        return element(by.buttonText(\"Delete User\")).click();\n    }\n\n    public async submit() {\n        await element(by.buttonText(\"Add User\")).click();\n        // Sleep for 500 ms to let the modal close\n        return browser.sleep(500);\n    }\n\n    public async dismiss() {\n        await element(by.buttonText(\"Cancel\")).click();\n        return browser.sleep(500);\n    }\n\n    /**\n     * Selects the mat-button-toggle that corresponds to the given permission.\n     * Automatically uppercases the input\n     *\n     * @param {string} permission\n     * @returns {Promise<any>}\n     */\n    private static async selectUserPermission(permission: string) {\n        // We need to use contains, because the Text can have trailing whitespace\n        const xpathString = \"//mat-button-toggle[.//div[contains(text(), '\" + permission.toUpperCase() + \"')]]\";\n        return element(by.xpath(xpathString)).click();\n    }\n}\n",
            "properties": [
                {
                    "name": "email",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "first_name",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "last_name",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "password",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "username",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 4
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "State",
            "id": "interface-State-224a7273c57bfec8ff84984bf4b8486e",
            "file": "src/main/webapp/src/app/reducers/index.ts",
            "type": "interface",
            "sourceCode": "import {ActionReducerMap, createReducer, createSelector, MetaReducer, on} from '@ngrx/store';\nimport {TrestleUser} from '../user/trestle-user';\nimport {login, loginFailure, loginSuccess, logout} from '../actions/auth.actions';\nimport {storageMetaReducer} from './storage.metareducer';\n\nexport interface UserState {\n  user: TrestleUser;\n  userError: Error;\n  userToken: string;\n}\n\nconst initialUserState: UserState = {\n  user: null,\n  userError: null,\n  userToken: ''\n};\n\nexport interface State {\n  user: UserState;\n}\n\nconst _authReducer = createReducer(initialUserState, on(login, state => {\n    console.log('Trying to login');\n    return state;\n  }),\n  on(loginSuccess, (state, {user, token}) => ({\n    userError: null,\n    user,\n    userToken: token\n  })),\n  on(loginFailure, (state, {error}) => ({\n    user: null,\n    userError: error,\n    userToken: ''\n  })),\n  on(logout, (state) => ({\n    ...state,\n    user: null,\n    userToken: ''\n  })));\n\n\nexport function authReducer(state: UserState = initialUserState, action): UserState {\n  return _authReducer(state, action);\n}\n\nexport const reducers: ActionReducerMap<State> = {\n  user: authReducer\n};\n\n\nexport const metaReducers: MetaReducer<State>[] = [storageMetaReducer];\n\n\nexport const selectUserState = (state: State) => state.user;\nexport const selectUser = (state: UserState) => state.user;\n\n\nexport const selectUserFromUser = createSelector(\n  selectUserState,\n  selectUser);\n\nexport const selectErrorFromUser = createSelector(\n  selectUserState,\n  (state) => state.userError\n);\n\nexport const selectTokenFromUser = createSelector(\n  selectUserState,\n  (state) => state.userToken\n);\n",
            "properties": [
                {
                    "name": "user",
                    "type": "UserState",
                    "optional": false,
                    "description": "",
                    "line": 19
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        },
        {
            "name": "UserState",
            "id": "interface-UserState-224a7273c57bfec8ff84984bf4b8486e",
            "file": "src/main/webapp/src/app/reducers/index.ts",
            "type": "interface",
            "sourceCode": "import {ActionReducerMap, createReducer, createSelector, MetaReducer, on} from '@ngrx/store';\nimport {TrestleUser} from '../user/trestle-user';\nimport {login, loginFailure, loginSuccess, logout} from '../actions/auth.actions';\nimport {storageMetaReducer} from './storage.metareducer';\n\nexport interface UserState {\n  user: TrestleUser;\n  userError: Error;\n  userToken: string;\n}\n\nconst initialUserState: UserState = {\n  user: null,\n  userError: null,\n  userToken: ''\n};\n\nexport interface State {\n  user: UserState;\n}\n\nconst _authReducer = createReducer(initialUserState, on(login, state => {\n    console.log('Trying to login');\n    return state;\n  }),\n  on(loginSuccess, (state, {user, token}) => ({\n    userError: null,\n    user,\n    userToken: token\n  })),\n  on(loginFailure, (state, {error}) => ({\n    user: null,\n    userError: error,\n    userToken: ''\n  })),\n  on(logout, (state) => ({\n    ...state,\n    user: null,\n    userToken: ''\n  })));\n\n\nexport function authReducer(state: UserState = initialUserState, action): UserState {\n  return _authReducer(state, action);\n}\n\nexport const reducers: ActionReducerMap<State> = {\n  user: authReducer\n};\n\n\nexport const metaReducers: MetaReducer<State>[] = [storageMetaReducer];\n\n\nexport const selectUserState = (state: State) => state.user;\nexport const selectUser = (state: UserState) => state.user;\n\n\nexport const selectUserFromUser = createSelector(\n  selectUserState,\n  selectUser);\n\nexport const selectErrorFromUser = createSelector(\n  selectUserState,\n  (state) => state.userError\n);\n\nexport const selectTokenFromUser = createSelector(\n  selectUserState,\n  (state) => state.userToken\n);\n",
            "properties": [
                {
                    "name": "user",
                    "type": "TrestleUser",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "userError",
                    "type": "Error",
                    "optional": false,
                    "description": "",
                    "line": 8
                },
                {
                    "name": "userToken",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 9
                }
            ],
            "indexSignatures": [],
            "kind": 150,
            "methods": []
        }
    ],
    "injectables": [
        {
            "name": "AggregationService",
            "id": "injectable-AggregationService-fe54b2d3d679234cf105dcc8a39b1bdf",
            "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
            "properties": [
                {
                    "name": "baseURL",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "performAggregation",
                    "args": [
                        {
                            "name": "request",
                            "type": "IAggregationRequest"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<GeometryObject>",
                    "typeParameters": [
                        "T"
                    ],
                    "line": 36,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "request",
                            "type": "IAggregationRequest",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {GeometryObject} from 'geojson';\nimport {HttpClient} from '@angular/common/http';\nimport {Observable} from 'rxjs';\nimport {environment} from '../../../environments/environment';\n\nexport const BBOX_PROPERTY = 'BOUNDING_BOX';\nexport type AggregationOperation = 'EQ' | 'NEQ' | 'GT' | 'GTEQ' | 'LT' | 'LTEQ';\n\nexport interface IAggregationRestriction {\n  dataset: string;\n  property: string;\n  value: object;\n}\n\nexport interface IAggregationStrategy {\n  field: string;\n  operation: AggregationOperation;\n  value: object;\n}\n\nexport interface IAggregationRequest {\n  restriction: IAggregationRestriction;\n  strategy: IAggregationStrategy;\n}\n\n@Injectable()\nexport class AggregationService {\n\n  private readonly baseURL: string;\n\n  constructor(private http: HttpClient) {\n    this.baseURL = environment.baseUrl;\n  }\n\n  public performAggregation<T>(request: IAggregationRequest): Observable<GeometryObject> {\n    console.debug('Aggregating!', request);\n    return this.http.post<GeometryObject>(this.baseURL + '/aggregate', request)\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient"
                    }
                ],
                "line": 30,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "AuthEffects",
            "id": "injectable-AuthEffects-9d6f72d2fe8533fe1d4f9e38a1c85ce7",
            "file": "src/main/webapp/src/app/effects/auth.effects.ts",
            "properties": [
                {
                    "name": "login",
                    "defaultValue": "createEffect(() =>\n    this.actions$\n      .pipe(ofType(login), exhaustMap(action => {\n        return this.authService.login(action.username, action.password)\n          .pipe(\n            map(({user, token}) => {\n              return loginSuccess({user, returnUrl: action.returnUrl, token});\n            }),\n            catchError(error => {\n              return of(loginFailure({error}));\n            }));\n      }))\n  )",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                },
                {
                    "name": "loginSuccess",
                    "defaultValue": "createEffect(() =>\n      this.actions$\n        .pipe(ofType(loginSuccess), tap(action => {\n          return this.router.navigate([action.returnUrl]);\n        })), {\n      dispatch: false\n    }\n  )",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 32
                },
                {
                    "name": "logout",
                    "defaultValue": "createEffect(() =>\n    this.actions$\n      .pipe(ofType(logout), exhaustMap(() => {\n        return this.authService.logout().pipe(map(() => {\n          console.debug(\"Ready to logout\");\n          return this.router.navigate(['/']);\n        }));\n      })), {\n    dispatch: false\n  })",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                }
            ],
            "methods": [],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Actions, createEffect, ofType} from '@ngrx/effects';\nimport {AuthService} from '../user/authentication.service';\nimport {login, loginFailure, loginSuccess, logout} from '../actions/auth.actions';\nimport {catchError, exhaustMap, map, tap} from 'rxjs/operators';\nimport {of} from 'rxjs';\nimport {Router} from '@angular/router';\n\n\n@Injectable()\nexport class AuthEffects {\n\n  constructor(private actions$: Actions, private authService: AuthService, private router: Router) {\n    // Not used\n  }\n\n\n  login = createEffect(() =>\n    this.actions$\n      .pipe(ofType(login), exhaustMap(action => {\n        return this.authService.login(action.username, action.password)\n          .pipe(\n            map(({user, token}) => {\n              return loginSuccess({user, returnUrl: action.returnUrl, token});\n            }),\n            catchError(error => {\n              return of(loginFailure({error}));\n            }));\n      }))\n  );\n\n  loginSuccess = createEffect(() =>\n      this.actions$\n        .pipe(ofType(loginSuccess), tap(action => {\n          return this.router.navigate([action.returnUrl]);\n        })), {\n      dispatch: false\n    }\n  );\n\n  logout = createEffect(() =>\n    this.actions$\n      .pipe(ofType(logout), exhaustMap(() => {\n        return this.authService.logout().pipe(map(() => {\n          console.debug(\"Ready to logout\");\n          return this.router.navigate(['/']);\n        }));\n      })), {\n    dispatch: false\n  });\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "actions$",
                        "type": "Actions"
                    },
                    {
                        "name": "authService",
                        "type": "AuthService"
                    },
                    {
                        "name": "router",
                        "type": "Router"
                    }
                ],
                "line": 11,
                "jsdoctags": [
                    {
                        "name": "actions$",
                        "type": "Actions",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "AuthService",
            "id": "injectable-AuthService-d55204a2468f4b26ef24d320e0b84ac4",
            "file": "src/main/webapp/src/app/user/authentication.service.ts",
            "properties": [
                {
                    "name": "baseUrl",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 66,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "getToken2",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 168,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "jwtHelper",
                    "type": "JwtHelperService",
                    "optional": false,
                    "description": "",
                    "line": 65,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getEncodedToken",
                    "args": [],
                    "optional": false,
                    "returnType": "string | null",
                    "typeParameters": [],
                    "line": 156,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getToken",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleToken | null",
                    "typeParameters": [],
                    "line": 160,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "getUser",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleUser | null",
                    "typeParameters": [],
                    "line": 131,
                    "description": "<p>Get the user, if one exists</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 3040,
                                "end": 3047,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "hasRequiredRoles",
                    "args": [
                        {
                            "name": "roles",
                            "type": "Privileges[]"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 147,
                    "description": "<p>Determines if the logged-in user has the necessary roles to perform a certain function</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 3438,
                                "end": 3443,
                                "flags": 0,
                                "escapedText": "roles"
                            },
                            "type": "Privileges[]",
                            "tagName": {
                                "pos": 3432,
                                "end": 3437,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Array of required Privileges</li>\n</ul>\n"
                        },
                        {
                            "tagName": {
                                "pos": 3481,
                                "end": 3488,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>has all the required roles</li>\n</ul>\n",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "isAdmin",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 118,
                    "description": "<p>Does the user have AT LEAST Admin permissions?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2715,
                                "end": 2722,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "loggedIn",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 102,
                    "description": "<p>Is the user currently logged in?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2300,
                                "end": 2307,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "login",
                    "args": [
                        {
                            "name": "username",
                            "type": "string"
                        },
                        {
                            "name": "password",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<literal type>",
                    "typeParameters": [],
                    "line": 78,
                    "description": "<p>Attempt to login the given use</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1623,
                                "end": 1631,
                                "flags": 0,
                                "escapedText": "username"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1608,
                                "end": 1613,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1614,
                                "end": 1622,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1615,
                                    "end": 1621,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1653,
                                "end": 1661,
                                "flags": 0,
                                "escapedText": "password"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1638,
                                "end": 1643,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1644,
                                "end": 1652,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1645,
                                    "end": 1651,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "logout",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<string>",
                    "typeParameters": [],
                    "line": 91,
                    "description": "<p>Logout the user</p>\n",
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {Privileges, TrestleUser} from './trestle-user';\nimport {HttpClient} from '@angular/common/http';\nimport {JwtHelperService} from '@auth0/angular-jwt';\nimport {environment} from '../../environments/environment';\nimport {Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nconst _key: string = 'access_token';\n\nexport class TrestleToken {\n\n  private readonly exp: number;\n  private readonly iat: number;\n  private readonly user: ITrestleUser;\n\n  public constructor(token: any) {\n    this.exp = token['exp'];\n    this.iat = token['iat'];\n    this.user = JSON.parse(token['data4j']);\n  }\n\n  /**\n   * Get token expiration time (in ms from Unix epoch)\n   * @returns {number}\n   */\n  public getExpiration() {\n    return this.exp;\n  }\n\n  /**\n   * Get issuance time (in ms from Unix epoch)\n   * @returns {number}\n   */\n  public getIssue() {\n    return this.iat;\n  }\n\n  /**\n   * Get the user from the token\n   * @returns {ITrestleUser}\n   */\n  public getUser() {\n    return this.user;\n  }\n}\n\nexport interface ITrestleUser {\n  id?: number;\n  firstName: string;\n  lastName: string;\n  username: string;\n  email: string;\n  password: string;\n  privileges: number;\n}\n\n@Injectable()\nexport class AuthService {\n\n  private jwtHelper: JwtHelperService;\n  private readonly baseUrl;\n\n  constructor(private router: Router, private http: HttpClient) {\n    this.jwtHelper = new JwtHelperService();\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Attempt to login the given use\n   * @param {string} username\n   * @param {string} password\n   */\n  public login(username: string, password: string): Observable<{ user: TrestleUser, token: string }> {\n    return this.http.post(this.baseUrl + '/auth/login', {username, password: password}, {\n      responseType: 'text'\n    })\n      .pipe(map(token => {\n        const t = this.getToken2(token);\n        return {user: new TrestleUser(t.getUser()), token}\n      }));\n  }\n\n  /**\n   * Logout the user\n   */\n  public logout(): Observable<string> {\n    console.debug(\"Logging out\");\n    return this.http.post(this.baseUrl + '/auth/logout', null, {\n      responseType: 'text'\n    });\n  }\n\n  /**\n   * Is the user currently logged in?\n   * @returns {boolean}\n   */\n  public loggedIn(): boolean {\n    const token = localStorage.getItem(_key);\n    if (token) {\n      console.debug(\n        this.jwtHelper.decodeToken(token),\n        this.jwtHelper.getTokenExpirationDate(token),\n        this.jwtHelper.isTokenExpired(token)\n      );\n    }\n    return !this.jwtHelper.isTokenExpired(token);\n  }\n\n  /**\n   * Does the user have AT LEAST Admin permissions?\n   * @returns {boolean}\n   */\n  public isAdmin(): boolean {\n    if (this.loggedIn()) {\n      const token = this.getToken();\n      // eslint-disable-next-line no-bitwise\n      return (token !== null) && ((token.getUser().privileges & Privileges.ADMIN) > 0);\n    }\n    return false;\n  }\n\n  /**\n   * Get the user, if one exists\n   * @returns {TrestleUser | null}\n   */\n  public getUser(): TrestleUser | null {\n    if (this.loggedIn()) {\n      const token = this.getToken();\n      if (token) {\n        return new TrestleUser(token.getUser());\n      }\n    }\n    console.error('User is not logged in');\n    return null;\n  }\n\n  /**\n   * Determines if the logged-in user has the necessary roles to perform a certain function\n   * @param roles - Array of required Privileges\n   * @returns {boolean} - has all the required roles\n   */\n  public hasRequiredRoles(roles: Privileges[]): boolean {\n    const user = this.getUser();\n    if (user == null) {\n      return false;\n    }\n\n    return user.hasRequiredPrivileges(roles);\n  }\n\n  public getEncodedToken(): string | null {\n    return localStorage.getItem(_key);\n  }\n\n  private getToken(): TrestleToken | null {\n    const jwtToken = this.getEncodedToken();\n    if (jwtToken) {\n      return new TrestleToken(this.jwtHelper.decodeToken(jwtToken));\n    }\n    return null;\n  }\n\n  private getToken2 = (jwtToken: string): TrestleToken => {\n    return new TrestleToken(this.jwtHelper.decodeToken(jwtToken));\n  };\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "router",
                        "type": "Router"
                    },
                    {
                        "name": "http",
                        "type": "HttpClient"
                    }
                ],
                "line": 66,
                "jsdoctags": [
                    {
                        "name": "router",
                        "type": "Router",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "CacheService",
            "id": "injectable-CacheService-bf4fbdb451e06a9eca41b8003b5a878b",
            "file": "src/main/webapp/src/app/shared/cache/cache.service.ts",
            "properties": [
                {
                    "name": "cache",
                    "type": "Cache<K | V>",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "inFlightObservables",
                    "defaultValue": "new Map<K, Subject<V>>()",
                    "type": "Map<K | Subject<V>>",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "evictionHandler",
                    "args": [
                        {
                            "name": "key",
                            "type": "K"
                        },
                        {
                            "name": "_value",
                            "type": "V"
                        },
                        {
                            "name": "reason",
                            "type": "RemovalReason"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 76,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "K",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "_value",
                            "type": "V",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "reason",
                            "type": "RemovalReason",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "get",
                    "args": [
                        {
                            "name": "key",
                            "type": "K"
                        },
                        {
                            "name": "fallback",
                            "type": "Observable<V>",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable | Subject",
                    "typeParameters": [],
                    "line": 38,
                    "description": "<p>Attempt to get the individual from the Cache,\nif that fails, call the fallback value and return the result to both the subscriber and the cache</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1346,
                                "end": 1349,
                                "flags": 0,
                                "escapedText": "key"
                            },
                            "type": "K",
                            "tagName": {
                                "pos": 1336,
                                "end": 1341,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to attempt to fetch from the cache</p>\n",
                            "typeExpression": {
                                "pos": 1342,
                                "end": 1345,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1343,
                                    "end": 1344,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1343,
                                        "end": 1344,
                                        "flags": 2097152,
                                        "escapedText": "K"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1413,
                                "end": 1421,
                                "flags": 0,
                                "escapedText": "fallback"
                            },
                            "type": "Observable<V>",
                            "optional": true,
                            "tagName": {
                                "pos": 1391,
                                "end": 1396,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>function to call if key is missing</p>\n",
                            "typeExpression": {
                                "pos": 1397,
                                "end": 1412,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1398,
                                    "end": 1411,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1398,
                                        "end": 1408,
                                        "flags": 2097152,
                                        "escapedText": "Observable"
                                    },
                                    "typeArguments": [
                                        {
                                            "pos": 1409,
                                            "end": 1410,
                                            "flags": 2097152,
                                            "kind": 161,
                                            "typeName": {
                                                "pos": 1409,
                                                "end": 1410,
                                                "flags": 2097152,
                                                "escapedText": "V"
                                            }
                                        }
                                    ]
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1463,
                                "end": 1470,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<p>of result</p>\n",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "notifyInFlightObservers",
                    "args": [
                        {
                            "name": "key",
                            "type": "K"
                        },
                        {
                            "name": "value",
                            "type": "V"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 64,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "K",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "value",
                            "type": "V",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "set",
                    "args": [
                        {
                            "name": "key",
                            "type": "K"
                        },
                        {
                            "name": "value",
                            "type": "V"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 59,
                    "description": "<p>Add key/value pair to cache</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2130,
                                "end": 2133,
                                "flags": 0,
                                "escapedText": "key"
                            },
                            "type": "K",
                            "tagName": {
                                "pos": 2120,
                                "end": 2125,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2126,
                                "end": 2129,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2127,
                                    "end": 2128,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2127,
                                        "end": 2128,
                                        "flags": 2097152,
                                        "escapedText": "K"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2150,
                                "end": 2155,
                                "flags": 0,
                                "escapedText": "value"
                            },
                            "type": "V",
                            "tagName": {
                                "pos": 2140,
                                "end": 2145,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2146,
                                "end": 2149,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2147,
                                    "end": 2148,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2147,
                                        "end": 2148,
                                        "flags": 2097152,
                                        "escapedText": "V"
                                    }
                                }
                            }
                        }
                    ]
                }
            ],
            "description": "<p>HTTP cache based on:\n<a href=\"https://hackernoon.com/angular-simple-in-memory-cache-service-on-the-ui-with-rxjs-77f167387e39\">https://hackernoon.com/angular-simple-in-memory-cache-service-on-the-ui-with-rxjs-77f167387e39</a></p>\n",
            "sourceCode": "import {Inject, Injectable} from '@angular/core';\nimport {CACHE_SERVICE_CONFIG, ICacheServiceConfig} from './cache.service.config';\nimport { Observable, of, Subject, throwError} from 'rxjs';\nimport {Cache, KeyType, newCache, RemovalReason} from 'transitory';\nimport {tap} from 'rxjs/operators';\n\n/**\n * HTTP cache based on:\n * https://hackernoon.com/angular-simple-in-memory-cache-service-on-the-ui-with-rxjs-77f167387e39\n */\n@Injectable()\nexport class CacheService<K extends KeyType, V> {\n  private cache: Cache<K, V>;\n  private inFlightObservables: Map<K, Subject<V>> = new Map<K, Subject<V>>();\n\n  /**\n   * We only ever call this constructor manually, and provide it the cache specific config settings.\n   * If it does get called by the Angular DI, it'll get some default config properties\n   *\n   * @param {ICacheServiceConfig} config\n   */\n  public constructor(@Inject(CACHE_SERVICE_CONFIG) private config: ICacheServiceConfig) {\n    console.debug('Creating with config:', config);\n    this.cache = newCache<K, V>()\n      .expireAfterRead(this.config.maxAge)\n      .maxSize(this.config.maxSize)\n      .withRemovalListener(this.evictionHandler)\n      .build();\n  }\n\n  /**\n   * Attempt to get the individual from the Cache,\n   * if that fails, call the fallback value and return the result to both the subscriber and the cache\n   * @param {K} key to attempt to fetch from the cache\n   * @param {Observable<V>} fallback function to call if key is missing\n   * @returns {Observable<V> | Subject<V>} of result\n   */\n  public get(key: K, fallback?: Observable<V>): Observable<V> | Subject<V> {\n    const value = this.cache.getIfPresent(key);\n    if (value) {\n      return of(value);\n    }\n\n    if (this.inFlightObservables.has(key)) {\n      return (this.inFlightObservables.get(key) as Subject<V>);\n    } else if (fallback && fallback instanceof Observable) {\n      this.inFlightObservables.set(key, new Subject());\n      return fallback.pipe(tap((oValue) => this.set(key, oValue)));\n    } else {\n      return throwError('Requested key is not available in Cache');\n    }\n  }\n\n  /**\n   * Add key/value pair to cache\n   * @param {K} key\n   * @param {V} value\n   */\n  public set(key: K, value: V): void {\n    this.cache.set(key, value);\n    this.notifyInFlightObservers(key, value);\n  }\n\n  private notifyInFlightObservers(key: K, value: V): void {\n    if (this.inFlightObservables.has(key)) {\n      const inFlight = (this.inFlightObservables.get(key) as Subject<V>);\n      const observersCount = inFlight.observers.length;\n      if (observersCount) {\n        inFlight.next(value);\n      }\n      inFlight.complete();\n      this.inFlightObservables.delete(key);\n    }\n  }\n\n  private evictionHandler(key: K, _value: V, reason: RemovalReason): void {\n    switch (reason) {\n      case RemovalReason.EXPIRED: {\n        console.log('Key %s expire:', key);\n        break;\n      }\n      case RemovalReason.EXPLICIT: {\n        console.log('Key %s was removed', key);\n        break;\n      }\n    }\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "<p>We only ever call this constructor manually, and provide it the cache specific config settings.\nIf it does get called by the Angular DI, it&#39;ll get some default config properties</p>\n",
                "args": [
                    {
                        "name": "config",
                        "type": "ICacheServiceConfig"
                    }
                ],
                "line": 14,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": {
                            "pos": 832,
                            "end": 838,
                            "flags": 0,
                            "escapedText": "config"
                        },
                        "type": "ICacheServiceConfig",
                        "tagName": {
                            "pos": 804,
                            "end": 809,
                            "flags": 0,
                            "escapedText": "param"
                        },
                        "comment": "",
                        "typeExpression": {
                            "pos": 810,
                            "end": 831,
                            "flags": 0,
                            "kind": 277,
                            "type": {
                                "pos": 811,
                                "end": 830,
                                "flags": 2097152,
                                "kind": 161,
                                "typeName": {
                                    "pos": 811,
                                    "end": 830,
                                    "flags": 2097152,
                                    "escapedText": "ICacheServiceConfig"
                                }
                            }
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "ColorService",
            "id": "injectable-ColorService-07a9158d01f5a297745f221d9929ddd7",
            "file": "src/main/webapp/src/app/shared/color/color.service.ts",
            "properties": [
                {
                    "name": "availableColors",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 9,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "colorScale",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getColor",
                    "args": [
                        {
                            "name": "layer",
                            "type": "number"
                        },
                        {
                            "name": "fallbackColor",
                            "type": "string",
                            "defaultValue": "\"white\""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 24,
                    "description": "<p>Get a color from the color scale, if one is available\nIf not, return white</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 653,
                                "end": 658,
                                "flags": 0,
                                "escapedText": "layer"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 638,
                                "end": 643,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>number to use when getting color</p>\n",
                            "typeExpression": {
                                "pos": 644,
                                "end": 652,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 645,
                                    "end": 651,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 715,
                                "end": 728,
                                "flags": 0,
                                "escapedText": "fallbackColor"
                            },
                            "type": "string",
                            "defaultValue": "\"white\"",
                            "tagName": {
                                "pos": 700,
                                "end": 705,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to use if none are avilable</p>\n",
                            "typeExpression": {
                                "pos": 706,
                                "end": 714,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 707,
                                    "end": 713,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 765,
                                "end": 772,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "initializeColorScale",
                    "args": [],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 53,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "reset",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 48,
                    "description": "<p>Reset everything</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "returnColor",
                    "args": [
                        {
                            "name": "color",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "description": "<p>Return a color so that it&#39;s available for the next layer</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1288,
                                "end": 1293,
                                "flags": 0,
                                "escapedText": "color"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1273,
                                "end": 1278,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1279,
                                "end": 1287,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1280,
                                    "end": 1286,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import { Inject, Injectable } from \"@angular/core\";\nimport { COLOR_SCHEME, COLOR_SERVICE_CONFIG, IColorServiceConfig } from \"./color-service.config\";\nimport { schemeCategory10, schemeSet1, schemeSet2, schemeSet3 } from \"d3\";\n\n\n@Injectable()\nexport class ColorService {\n\n    private availableColors: string[];\n    private colorScale: string[];\n\n    public constructor(@Inject(COLOR_SERVICE_CONFIG) private config: IColorServiceConfig) {\n        this.availableColors = [];\n        this.colorScale = this.initializeColorScale();\n    }\n\n    /**\n     * Get a color from the color scale, if one is available\n     * If not, return white\n     * @param {number} layer number to use when getting color\n     * @param {string} fallbackColor to use if none are avilable\n     * @returns {string}\n     */\n    public getColor(layer: number, fallbackColor = \"white\"): string {\n        // See if we have a color available\n        const aColor = this.availableColors.pop();\n        if (aColor === undefined) {\n            const color = this.colorScale[layer];\n            if (color === null) {\n                return fallbackColor;\n            }\n            return color;\n        }\n        return aColor;\n    }\n\n    /**\n     * Return a color so that it's available for the next layer\n     * @param {string} color\n     */\n    public returnColor(color: string): void {\n        this.availableColors.push(color);\n    }\n\n    /**\n     * Reset everything\n     */\n    public reset(): void {\n        this.availableColors = [];\n        this.colorScale = this.initializeColorScale();\n    }\n\n    private initializeColorScale(): string[] {\n        switch (this.config.colorType) {\n            case COLOR_SCHEME.CATEGORY_20B: {\n                // @ts-ignore\n              return schemeSet2;\n            }\n            case COLOR_SCHEME.CATEGORY_20C: {\n                // @ts-ignore\n              return schemeSet3;\n            }\n            case COLOR_SCHEME.CATEGORY_20: {\n                // @ts-ignore\n              return schemeSet1;\n            }\n            case COLOR_SCHEME.CATEGORY_10: {\n                // @ts-ignore\n              return schemeCategory10;\n            }\n        }\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "config",
                        "type": "IColorServiceConfig"
                    }
                ],
                "line": 10,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "config",
                        "type": "IColorServiceConfig",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "DatasetService",
            "id": "injectable-DatasetService-5296a87ae7e103d5afdca853217e9c29",
            "file": "src/main/webapp/src/app/shared/dataset/dataset.service.ts",
            "properties": [
                {
                    "name": "baseUrl",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "dsAPICall",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 63,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "errorHandler",
                    "args": [
                        {
                            "name": "error",
                            "type": "any"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Error>",
                    "typeParameters": [],
                    "line": 71,
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "error",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "filterPropertyNames",
                    "args": [
                        {
                            "name": "properties",
                            "type": "string[]"
                        }
                    ],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 75,
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "properties",
                            "type": "string[]",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getAvailableDatasets",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 25,
                    "description": "<p>Returns the list of currently registered datasets from the database</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 845,
                                "end": 852,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getDatasetFactValues",
                    "args": [
                        {
                            "name": "dataset",
                            "type": "string"
                        },
                        {
                            "name": "fact",
                            "type": "string"
                        },
                        {
                            "name": "limit",
                            "type": "number",
                            "defaultValue": "100"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 50,
                    "description": "<p>Get a sampling of unique values for the given dataset property\nDefaults to 100 values if no limit is provided.</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1667,
                                "end": 1674,
                                "flags": 0,
                                "escapedText": "dataset"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1652,
                                "end": 1657,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Dataset to query</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1658,
                                "end": 1666,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1659,
                                    "end": 1665,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1715,
                                "end": 1719,
                                "flags": 0,
                                "escapedText": "fact"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1700,
                                "end": 1705,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Property to get values for</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1706,
                                "end": 1714,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1707,
                                    "end": 1713,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1770,
                                "end": 1775,
                                "flags": 0,
                                "escapedText": "limit"
                            },
                            "type": "number",
                            "defaultValue": "100",
                            "tagName": {
                                "pos": 1755,
                                "end": 1760,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Optional limit of values to return (defaults to 100)</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1761,
                                "end": 1769,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1762,
                                    "end": 1768,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1837,
                                "end": 1844,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>List of property values</li>\n</ul>\n",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getDatasetProperties",
                    "args": [
                        {
                            "name": "dataset",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 36,
                    "description": "<p>Get all the data properties for the given dataset, returns them as a list with everything but the property name removed.</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1204,
                                "end": 1211,
                                "flags": 0,
                                "escapedText": "dataset"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1189,
                                "end": 1194,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Dataset to query</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1195,
                                "end": 1203,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1196,
                                    "end": 1202,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1237,
                                "end": 1244,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>Filtered list of registered data properties</li>\n</ul>\n",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Inject, Injectable, InjectionToken} from '@angular/core';\nimport {TrestleIndividual} from '../individual/TrestleIndividual/trestle-individual';\nimport {HttpClient, HttpParams} from '@angular/common/http';\nimport {Observable, throwError} from 'rxjs';\nimport {environment} from '../../../environments/environment';\nimport {CacheService} from '../cache/cache.service';\nimport {map, tap} from 'rxjs/operators';\n\nexport const DATASET_CACHE = new InjectionToken<CacheService<string, string[]>>('dataset.cache');\n\n@Injectable()\nexport class DatasetService {\n\n  private readonly baseUrl;\n\n  constructor(private http: HttpClient,\n              @Inject(DATASET_CACHE) private cache: CacheService<string, string[]>) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Returns the list of currently registered datasets from the database\n   * @returns {Observable<string[]>}\n   */\n  public getAvailableDatasets(): Observable<string[]> {\n    // Try from cache first, then hit the API\n    return this.cache.get('datasets', this.dsAPICall());\n  }\n\n  /**\n   * Get all the data properties for the given dataset, returns them as a list with everything but the property name removed.\n   *\n   * @param {string} dataset - Dataset to query\n   * @returns {Observable<string[]>} - Filtered list of registered data properties\n   */\n  public getDatasetProperties(dataset: string): Observable<string[]> {\n    return this.http.get(this.baseUrl + '/datasets/' + dataset)\n      .pipe(map(DatasetService.filterPropertyNames));\n  }\n\n  /**\n   * Get a sampling of unique values for the given dataset property\n   * Defaults to 100 values if no limit is provided.\n   *\n   * @param {string} dataset - Dataset to query\n   * @param {string} fact - Property to get values for\n   * @param {number} limit - Optional limit of values to return (defaults to 100)\n   * @returns {Observable<string[]>} - List of property values\n   */\n  public getDatasetFactValues(dataset: string, fact: string, limit = 100): Observable<string[]> {\n\n    const datsetURL = this.baseUrl + '/datasets/' + dataset + '/' + fact + '/values';\n\n    const params = new HttpParams();\n    params.append('limit', limit.toString());\n\n    return this.http.get<string[]>(datsetURL, {\n      params\n    });\n    // .catch(DatasetService.errorHandler);\n  }\n\n  private dsAPICall(): Observable<string[]> {\n    return this.http.get<string[]>(this.baseUrl + '/datasets')\n      .pipe(tap((res) => console.debug('Available datasets:', res)));\n\n    // .map((res: Response) => res.json())\n    // .catch(DatasetService.errorHandler);\n  }\n\n  public static errorHandler(error: any): Observable<Error> {\n    return throwError(error || 'Server Error');\n  }\n\n  public static filterPropertyNames(properties: string[]): string[] {\n    return properties\n      .map((property) => {\n        return TrestleIndividual.extractSuffix(property);\n      });\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient"
                    },
                    {
                        "name": "cache",
                        "type": "CacheService<string | string[]>"
                    }
                ],
                "line": 14,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "cache",
                        "type": "CacheService<string | string[]>",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "ExporterService",
            "id": "injectable-ExporterService-b921c60b5c0562fa659d144dfa66aafb",
            "file": "src/main/webapp/src/app/explore/exporter/exporter.service.ts",
            "properties": [],
            "methods": [
                {
                    "name": "exportIndividuals",
                    "args": [
                        {
                            "name": "request",
                            "type": "IExportRequest"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Blob>",
                    "typeParameters": [],
                    "line": 23,
                    "description": "<p>Export indivduals and return the built result from the database</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 436,
                                "end": 443,
                                "flags": 0,
                                "escapedText": "request"
                            },
                            "type": "IExportRequest",
                            "tagName": {
                                "pos": 413,
                                "end": 418,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 419,
                                "end": 435,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 420,
                                    "end": 434,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 420,
                                        "end": 434,
                                        "flags": 2097152,
                                        "escapedText": "IExportRequest"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 452,
                                "end": 459,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from \"@angular/core\";\nimport {Observable} from 'rxjs';\nimport {HttpClient} from '@angular/common/http';\n\nexport interface IExportRequest {\n    dataset: string;\n    individuals: string[];\n    type: string;\n}\n\n@Injectable()\nexport class ExporterService {\n\n    constructor(private http: HttpClient) {\n\n    }\n\n    /**\n     * Export indivduals and return the built result from the database\n     * @param {IExportRequest} request\n     * @returns {Observable<Blob>}\n     */\n    public exportIndividuals(request: IExportRequest): Observable<Blob> {\n        return this.http.post(\"/export\", request, {\n            responseType: 'blob'\n        });\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient"
                    }
                ],
                "line": 12,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "IndexService",
            "id": "injectable-IndexService-2af1f1b55678fcfc2e51e62f69864cba",
            "file": "src/main/webapp/src/app/admin/indicies/index.service.ts",
            "properties": [
                {
                    "name": "baseUrl",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getIndexStatistics",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<ICacheStatistics>",
                    "typeParameters": [],
                    "line": 39,
                    "description": "<p>Get statistics for both caches</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 851,
                                "end": 858,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "purgeCache",
                    "args": [
                        {
                            "name": "cache",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<void>",
                    "typeParameters": [],
                    "line": 59,
                    "description": "<p>Purge the specified index</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1378,
                                "end": 1383,
                                "flags": 0,
                                "escapedText": "cache"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1363,
                                "end": 1368,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to purge</p>\n",
                            "typeExpression": {
                                "pos": 1369,
                                "end": 1377,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1370,
                                    "end": 1376,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1399,
                                "end": 1406,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "rebuildIndex",
                    "args": [
                        {
                            "name": "index",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<void>",
                    "typeParameters": [],
                    "line": 49,
                    "description": "<p>Rebuild specified index</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1101,
                                "end": 1106,
                                "flags": 0,
                                "escapedText": "index"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1086,
                                "end": 1091,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to rebuild</p>\n",
                            "typeExpression": {
                                "pos": 1092,
                                "end": 1100,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1093,
                                    "end": 1099,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1124,
                                "end": 1131,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {Observable} from 'rxjs';\n\nexport interface IIndexLeafStatistics {\n  binaryID: string;\n  type: string;\n  coordinates: number[];\n  leafID: number;\n  direction: number;\n  records: number;\n}\n\nexport interface ICacheStatistics {\n  offsetValue: number;\n  maxValue: number;\n  dbIndexFragmentation: number;\n  dbIndexSize: number;\n  dbLeafStats: IIndexLeafStatistics[];\n  validIndexFragmentation: number;\n  validIndexSize: number;\n  validLeafStats: IIndexLeafStatistics[];\n}\n\n@Injectable()\nexport class IndexService {\n\n  private readonly baseUrl: string;\n\n  public constructor(private http: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get statistics for both caches\n   * @returns {Observable<ICacheStatistics>}\n   */\n  public getIndexStatistics(): Observable<ICacheStatistics> {\n    return this.http\n      .get<ICacheStatistics>(this.baseUrl + '/cache/index');\n  }\n\n  /**\n   * Rebuild specified index\n   * @param {string} index to rebuild\n   * @returns {Observable<void>}\n   */\n  public rebuildIndex(index: string): Observable<void> {\n    return this.http\n      .get<void>(this.baseUrl + '/cache/rebuild/' + index.toLocaleLowerCase());\n  }\n\n  /**\n   * Purge the specified index\n   * @param {string} cache to purge\n   * @returns {Observable<void>}\n   */\n  public purgeCache(cache: string): Observable<void> {\n    return this.http\n      .get<void>(this.baseUrl + '/cache/purge/' + cache.toLocaleLowerCase());\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient"
                    }
                ],
                "line": 29,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "IndividualService",
            "id": "injectable-IndividualService-3543348f84d211f4fc3d573ed2faf896",
            "file": "src/main/webapp/src/app/shared/individual/individual.service.ts",
            "properties": [
                {
                    "name": "baseURL",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getIndividualAPI",
                    "args": [
                        {
                            "name": "name",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<TrestleIndividual>",
                    "typeParameters": [],
                    "line": 53,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "name",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getTrestleIndividual",
                    "args": [
                        {
                            "name": "name",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<TrestleIndividual>",
                    "typeParameters": [],
                    "line": 49,
                    "description": "<p>Return a {TrestleIndividual} from the API\nUses the cache if possible</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1639,
                                "end": 1643,
                                "flags": 0,
                                "escapedText": "name"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1624,
                                "end": 1629,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Individual IRI string</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1630,
                                "end": 1638,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1631,
                                    "end": 1637,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1674,
                                "end": 1681,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "searchForIndividual",
                    "args": [
                        {
                            "name": "name",
                            "type": "string"
                        },
                        {
                            "name": "dataset",
                            "type": "string",
                            "defaultValue": "''"
                        },
                        {
                            "name": "limit",
                            "type": "number",
                            "defaultValue": "10"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 31,
                    "description": "<p>Search for an individual in the database</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 906,
                                "end": 910,
                                "flags": 0,
                                "escapedText": "name"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 891,
                                "end": 896,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of the individual to search for (partial value)</p>\n",
                            "typeExpression": {
                                "pos": 897,
                                "end": 905,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 898,
                                    "end": 904,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 980,
                                "end": 987,
                                "flags": 0,
                                "escapedText": "dataset"
                            },
                            "type": "string",
                            "defaultValue": "''",
                            "tagName": {
                                "pos": 965,
                                "end": 970,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to restrict queries to</p>\n",
                            "typeExpression": {
                                "pos": 971,
                                "end": 979,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 972,
                                    "end": 978,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1032,
                                "end": 1037,
                                "flags": 0,
                                "escapedText": "limit"
                            },
                            "type": "number",
                            "defaultValue": "10",
                            "tagName": {
                                "pos": 1017,
                                "end": 1022,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>number of return values</p>\n",
                            "typeExpression": {
                                "pos": 1023,
                                "end": 1031,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1024,
                                    "end": 1030,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1068,
                                "end": 1075,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Inject, Injectable, InjectionToken} from '@angular/core';\nimport {ITrestleIndividual, TrestleIndividual} from './TrestleIndividual/trestle-individual';\nimport {CacheService} from '../cache/cache.service';\nimport {HttpClient} from '@angular/common/http';\nimport {Observable} from 'rxjs';\nimport {environment} from '../../../environments/environment';\nimport {map, tap} from 'rxjs/operators';\n\nexport const INDIVIDUAL_CACHE = new InjectionToken<CacheService<string, TrestleIndividual>>('individual.cache');\n\n@Injectable()\nexport class IndividualService {\n\n  private readonly baseURL;\n\n  constructor(private trestleHttp: HttpClient,\n              @Inject(INDIVIDUAL_CACHE) private individualCache: CacheService<string, TrestleIndividual>) {\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Search for an individual in the database\n   * @param {string} name of the individual to search for (partial value)\n   * @param {string} dataset to restrict queries to\n   * @param {number} limit number of return values\n   * @returns {Observable<string[]>}\n   */\n  public searchForIndividual(name: string, dataset = '', limit = 10): Observable<string[]> {\n    return this.trestleHttp.get<string[]>(this.baseURL + '/visualize/search', {\n      params: {\n        name: name,\n        dataset: dataset,\n        limit: limit.toString()\n      }\n    })\n      .pipe(tap(res => console.debug('Search response:', res)));\n    // .catch((error: Error) => Observable.throw(error || \"Server Error\"));\n  }\n\n  /**\n   * Return a {TrestleIndividual} from the API\n   * Uses the cache if possible\n   * @param {string} name - Individual IRI string\n   * @returns {Observable<TrestleIndividual>}\n   */\n  public getTrestleIndividual(name: string): Observable<TrestleIndividual> {\n    return this.individualCache.get(name, this.getIndividualAPI(name));\n  }\n\n  private getIndividualAPI(name: string): Observable<TrestleIndividual> {\n    return this.trestleHttp.get<ITrestleIndividual>(this.baseURL + '/individual/retrieve', {\n      params: {\n        name\n      }\n    })\n      .pipe(map(response => {\n        console.debug('Has response, building object', response);\n        return new TrestleIndividual(response);\n      }));\n    // .catch((error: Error) => Observable.throw(error || \"Server Error\"));\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "trestleHttp",
                        "type": "HttpClient"
                    },
                    {
                        "name": "individualCache",
                        "type": "CacheService<string | TrestleIndividual>"
                    }
                ],
                "line": 17,
                "jsdoctags": [
                    {
                        "name": "trestleHttp",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "individualCache",
                        "type": "CacheService<string | TrestleIndividual>",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "LoadingSpinnerService",
            "id": "injectable-LoadingSpinnerService-4d09ed62dbd07e89e2a1787bb455252d",
            "file": "src/main/webapp/src/app/ui/loading-spinner/loading-spinner.service.ts",
            "properties": [
                {
                    "name": "bodyPortalHost",
                    "type": "DomPortalOutlet",
                    "optional": false,
                    "description": "",
                    "line": 9,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "domElement",
                    "type": "HTMLElement",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "loadingSpinnerPortal",
                    "type": "ComponentPortal<LoadingSpinnerComponent>",
                    "optional": false,
                    "description": "",
                    "line": 8,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "hide",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 49,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "reveal",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "setViewContainerRef",
                    "args": [
                        {
                            "name": "ref",
                            "type": "ViewContainerRef | HTMLElement"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 19,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "ref",
                            "type": "ViewContainerRef | HTMLElement",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {ApplicationRef, ComponentFactoryResolver, Injectable, Injector, ViewContainerRef} from \"@angular/core\";\nimport {ComponentPortal, DomPortalOutlet} from \"@angular/cdk/portal\";\nimport {LoadingSpinnerComponent} from \"./loading-spinner.component\";\n\n@Injectable()\nexport class LoadingSpinnerService {\n\n    private loadingSpinnerPortal: ComponentPortal<LoadingSpinnerComponent>;\n    private bodyPortalHost: DomPortalOutlet;\n    private domElement: HTMLElement;\n\n    public constructor(private componentFactoryResolver: ComponentFactoryResolver,\n                       private appRef: ApplicationRef,\n                       private injector: Injector) {\n\n        this.loadingSpinnerPortal = new ComponentPortal(LoadingSpinnerComponent);\n    }\n\n    public setViewContainerRef(ref: ViewContainerRef | HTMLElement): void {\n        // const factory = this.componentFactoryResolver\n        //     .resolveComponentFactory(LoadingSpinnerComponent);\n\n        // const component = factory.create(ref.parentInjector);\n\n        if (ref instanceof ViewContainerRef) {\n            this.domElement = ref.element.nativeElement;\n        } else {\n            this.domElement = ref;\n        }\n\n        console.debug(\"Setting view ref to:\", this.domElement);\n\n        this.bodyPortalHost = new DomPortalOutlet(\n            this.domElement,\n            this.componentFactoryResolver,\n            this.appRef,\n            this.injector\n        );\n    }\n\n    public reveal(): void {\n        if (this.bodyPortalHost == null) {\n            throw new Error(\"Host is empty, cannot add!\");\n        }\n        console.debug(\"Adding spinner\");\n        this.bodyPortalHost.attach(this.loadingSpinnerPortal);\n    }\n\n    public hide(): void {\n        if (this.bodyPortalHost == null) {\n            throw new Error(\"Host is empty, cannot remove!\");\n        }\n        console.debug(\"Removing spinner\");\n        this.bodyPortalHost.detach();\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "componentFactoryResolver",
                        "type": "ComponentFactoryResolver"
                    },
                    {
                        "name": "appRef",
                        "type": "ApplicationRef"
                    },
                    {
                        "name": "injector",
                        "type": "Injector"
                    }
                ],
                "line": 10,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "componentFactoryResolver",
                        "type": "ComponentFactoryResolver",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "appRef",
                        "type": "ApplicationRef",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "injector",
                        "type": "Injector",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "MapService",
            "id": "injectable-MapService-0993ca09b2f7160db877645603e55ca1",
            "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
            "properties": [
                {
                    "name": "baseURL",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 76,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "parseToGeoJSONWorker",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "<p>Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff</p>\n",
                    "line": 166,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "pos": 5070,
                            "end": 5101,
                            "flags": 0,
                            "kind": 292,
                            "atToken": {
                                "pos": 5070,
                                "end": 5071,
                                "flags": 0,
                                "kind": 57
                            },
                            "tagName": {
                                "pos": 5071,
                                "end": 5076,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "typeExpression": {
                                "pos": 5077,
                                "end": 5087,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 5078,
                                    "end": 5086,
                                    "flags": 2097152,
                                    "kind": 166,
                                    "elementType": {
                                        "pos": 5078,
                                        "end": 5084,
                                        "flags": 2097152,
                                        "kind": 135
                                    }
                                }
                            },
                            "name": {
                                "pos": 5088,
                                "end": 5095,
                                "flags": 0,
                                "escapedText": "objects"
                            },
                            "isNameFirst": false,
                            "isBracketed": false,
                            "comment": ""
                        },
                        {
                            "pos": 5101,
                            "end": 5157,
                            "flags": 0,
                            "kind": 293,
                            "atToken": {
                                "pos": 5101,
                                "end": 5102,
                                "flags": 0,
                                "kind": 57
                            },
                            "tagName": {
                                "pos": 5102,
                                "end": 5109,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "typeExpression": {
                                "pos": 5110,
                                "end": 5157,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 5111,
                                    "end": 5156,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 5111,
                                        "end": 5121,
                                        "flags": 2097152,
                                        "escapedText": "Observable"
                                    },
                                    "typeArguments": [
                                        {
                                            "pos": 5122,
                                            "end": 5155,
                                            "flags": 2097152,
                                            "kind": 161,
                                            "typeName": {
                                                "pos": 5122,
                                                "end": 5139,
                                                "flags": 2097152,
                                                "escapedText": "FeatureCollection"
                                            },
                                            "typeArguments": [
                                                {
                                                    "pos": 5140,
                                                    "end": 5154,
                                                    "flags": 2097152,
                                                    "kind": 161,
                                                    "typeName": {
                                                        "pos": 5140,
                                                        "end": 5154,
                                                        "flags": 2097152,
                                                        "escapedText": "GeometryObject"
                                                    }
                                                }
                                            ]
                                        }
                                    ]
                                }
                            },
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "worker",
                    "type": "Worker",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "workerStream",
                    "type": "Observable<IMapWorkerResponse>",
                    "optional": false,
                    "description": "",
                    "line": 75,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "compareIndividuals",
                    "args": [
                        {
                            "name": "request",
                            "type": "ICompareBody"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<IComparisonReport>",
                    "typeParameters": [],
                    "line": 157,
                    "description": "<p>Perform a spatio-temporal comparison between the input object and the given set of comparison objects</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 4714,
                                "end": 4721,
                                "flags": 0,
                                "escapedText": "request"
                            },
                            "type": "ICompareBody",
                            "tagName": {
                                "pos": 4693,
                                "end": 4698,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 4699,
                                "end": 4713,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 4700,
                                    "end": 4712,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 4700,
                                        "end": 4712,
                                        "flags": 2097152,
                                        "escapedText": "ICompareBody"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 4728,
                                "end": 4735,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "isGeometryObject",
                    "args": [
                        {
                            "name": "x",
                            "type": "any"
                        }
                    ],
                    "optional": false,
                    "returnType": "GeometryObject",
                    "typeParameters": [],
                    "line": 218,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "x",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "normalizeToGeoJSON",
                    "args": [
                        {
                            "name": "geom",
                            "type": "wktValue"
                        }
                    ],
                    "optional": false,
                    "returnType": "Polygon | MultiPolygon",
                    "typeParameters": [],
                    "line": 189,
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "geom",
                            "type": "wktValue",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "parseResponseToIndividuals",
                    "args": [
                        {
                            "name": "res",
                            "type": "ITrestleIndividual[]"
                        }
                    ],
                    "optional": false,
                    "returnType": "TrestleIndividual[]",
                    "typeParameters": [],
                    "line": 212,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "res",
                            "type": "ITrestleIndividual[]",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "stIntersect",
                    "args": [
                        {
                            "name": "dataset",
                            "type": "string"
                        },
                        {
                            "name": "wkt",
                            "type": "wktValue"
                        },
                        {
                            "name": "validTime",
                            "type": "Moment"
                        },
                        {
                            "name": "dbTime",
                            "type": "Moment",
                            "optional": true
                        },
                        {
                            "name": "buffer",
                            "type": "number",
                            "defaultValue": "0"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<FeatureCollection<GeometryObject>>",
                    "typeParameters": [],
                    "line": 95,
                    "description": "<p>Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2287,
                                "end": 2294,
                                "flags": 0,
                                "escapedText": "dataset"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 2272,
                                "end": 2277,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to use</p>\n",
                            "typeExpression": {
                                "pos": 2278,
                                "end": 2286,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2279,
                                    "end": 2285,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2325,
                                "end": 2328,
                                "flags": 0,
                                "escapedText": "wkt"
                            },
                            "type": "wktValue",
                            "tagName": {
                                "pos": 2308,
                                "end": 2313,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>boundary</p>\n",
                            "typeExpression": {
                                "pos": 2314,
                                "end": 2324,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2315,
                                    "end": 2323,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2315,
                                        "end": 2323,
                                        "flags": 2097152,
                                        "escapedText": "wktValue"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2366,
                                "end": 2375,
                                "flags": 0,
                                "escapedText": "validTime"
                            },
                            "type": "Moment",
                            "tagName": {
                                "pos": 2344,
                                "end": 2349,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of intersection</p>\n",
                            "typeExpression": {
                                "pos": 2350,
                                "end": 2365,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2351,
                                    "end": 2364,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2351,
                                        "end": 2364,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 2351,
                                            "end": 2357,
                                            "flags": 2097152,
                                            "escapedText": "moment"
                                        },
                                        "right": {
                                            "pos": 2358,
                                            "end": 2364,
                                            "flags": 2097152,
                                            "escapedText": "Moment"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2420,
                                "end": 2426,
                                "flags": 0,
                                "escapedText": "dbTime"
                            },
                            "type": "Moment",
                            "optional": true,
                            "tagName": {
                                "pos": 2398,
                                "end": 2403,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of intersection</p>\n",
                            "typeExpression": {
                                "pos": 2404,
                                "end": 2419,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2405,
                                    "end": 2418,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2405,
                                        "end": 2418,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 2405,
                                            "end": 2411,
                                            "flags": 2097152,
                                            "escapedText": "moment"
                                        },
                                        "right": {
                                            "pos": 2412,
                                            "end": 2418,
                                            "flags": 2097152,
                                            "escapedText": "Moment"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2464,
                                "end": 2470,
                                "flags": 0,
                                "escapedText": "buffer"
                            },
                            "type": "number",
                            "defaultValue": "0",
                            "tagName": {
                                "pos": 2449,
                                "end": 2454,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>(in meters) around boundary</p>\n",
                            "typeExpression": {
                                "pos": 2455,
                                "end": 2463,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2456,
                                    "end": 2462,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2505,
                                "end": 2512,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "stIntersectIndividual",
                    "args": [
                        {
                            "name": "dataset",
                            "type": "string"
                        },
                        {
                            "name": "wkt",
                            "type": "wktValue"
                        },
                        {
                            "name": "validTime",
                            "type": "Moment",
                            "optional": true
                        },
                        {
                            "name": "dbTime",
                            "type": "Moment",
                            "optional": true
                        },
                        {
                            "name": "buffer",
                            "type": "number",
                            "defaultValue": "0"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<TrestleIndividual[]>",
                    "typeParameters": [],
                    "line": 127,
                    "description": "<p>Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 3534,
                                "end": 3541,
                                "flags": 0,
                                "escapedText": "dataset"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 3519,
                                "end": 3524,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to use</p>\n",
                            "typeExpression": {
                                "pos": 3525,
                                "end": 3533,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 3526,
                                    "end": 3532,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 3572,
                                "end": 3575,
                                "flags": 0,
                                "escapedText": "wkt"
                            },
                            "type": "wktValue",
                            "tagName": {
                                "pos": 3555,
                                "end": 3560,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>boundary</p>\n",
                            "typeExpression": {
                                "pos": 3561,
                                "end": 3571,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 3562,
                                    "end": 3570,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 3562,
                                        "end": 3570,
                                        "flags": 2097152,
                                        "escapedText": "wktValue"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 3613,
                                "end": 3622,
                                "flags": 0,
                                "escapedText": "validTime"
                            },
                            "type": "Moment",
                            "optional": true,
                            "tagName": {
                                "pos": 3591,
                                "end": 3596,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of intersection</p>\n",
                            "typeExpression": {
                                "pos": 3597,
                                "end": 3612,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 3598,
                                    "end": 3611,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 3598,
                                        "end": 3611,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 3598,
                                            "end": 3604,
                                            "flags": 2097152,
                                            "escapedText": "moment"
                                        },
                                        "right": {
                                            "pos": 3605,
                                            "end": 3611,
                                            "flags": 2097152,
                                            "escapedText": "Moment"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 3667,
                                "end": 3673,
                                "flags": 0,
                                "escapedText": "dbTime"
                            },
                            "type": "Moment",
                            "optional": true,
                            "tagName": {
                                "pos": 3645,
                                "end": 3650,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of intersection</p>\n",
                            "typeExpression": {
                                "pos": 3651,
                                "end": 3666,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 3652,
                                    "end": 3665,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 3652,
                                        "end": 3665,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 3652,
                                            "end": 3658,
                                            "flags": 2097152,
                                            "escapedText": "moment"
                                        },
                                        "right": {
                                            "pos": 3659,
                                            "end": 3665,
                                            "flags": 2097152,
                                            "escapedText": "Moment"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 3711,
                                "end": 3717,
                                "flags": 0,
                                "escapedText": "buffer"
                            },
                            "type": "number",
                            "defaultValue": "0",
                            "tagName": {
                                "pos": 3696,
                                "end": 3701,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>(in meters) around boundary</p>\n",
                            "typeExpression": {
                                "pos": 3702,
                                "end": 3710,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 3703,
                                    "end": 3709,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 3752,
                                "end": 3759,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {FeatureCollection, GeometryObject, MultiPolygon, Polygon} from 'geojson';\nimport {Moment} from 'moment';\nimport {fromEvent, Observable, Subscriber, throwError} from 'rxjs';\nimport {filter, flatMap, map} from 'rxjs/operators';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {ITrestleIndividual, TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\nexport type wktType = 'POINT' |\n  'MULTIPOINT' |\n  'LINESTRING' |\n  'MULTILINESTRING' |\n  'POLYGON' |\n  'MULTIPOLYGON';\n\nexport type wktValue = LngLatBounds | GeometryObject;\n\nexport interface IContributionReport {\n  object: any;\n  area: number;\n  contributingParts: IContributionPart[];\n}\n\nexport interface IComparisonReport {\n  union: IContributionReport | null;\n  reports: ISpatialComparisonReport[];\n}\n\nexport interface IContributionPart {\n  object: any;\n  contribution: number;\n}\n\nexport interface ISpatialComparisonReport {\n  objectAID: string;\n  objectBID: string;\n  relations: string[];\n  equality?: number;\n  spatialOverlap?: string;\n  spatialOverlapPercentage?: number;\n}\n\ninterface IIntersectionBody {\n  dataset: string;\n  geojson: Polygon | MultiPolygon;\n  buffer: number;\n  validAt?: string;\n  databaseAt?: string;\n}\n\ninterface ICompareBody {\n  compare: string;\n  compareAgainst: string[];\n}\n\nexport interface IMapWorkerRequest {\n  id: number;\n  response: object[];\n}\n\nexport interface IMapWorkerResponse {\n  id: number;\n  geom: FeatureCollection<GeometryObject>;\n}\n\n\n@Injectable()\nexport class MapService {\n  private worker: Worker;\n  private workerStream: Observable<IMapWorkerResponse>;\n  private readonly baseURL;\n\n  constructor(private http: HttpClient) {\n    //    Create the worker and register a stream for the results\n    this.worker = new Worker(\"/projector\");\n    this.workerStream = fromEvent(this.worker, 'message')\n      .pipe(map((m: MessageEvent) => (m.data as IMapWorkerResponse)));\n    this.baseURL = environment.baseUrl;\n  }\n\n  /**\n   * Before a spatio-temporal interesction for the given WKT bounding box, returning a GeoJSON Feature Collection\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  public stIntersect(dataset: string,\n                     wkt: wktValue,\n                     validTime: Moment,\n                     dbTime?: Moment,\n                     buffer: number = 0): Observable<FeatureCollection<GeometryObject>> {\n    console.debug('Intersecting at:', wkt, validTime.toISOString());\n\n    if (wkt === null || wkt === undefined) {\n      return throwError('Intersection boundary cannot be empty');\n    }\n\n    const postBody: IIntersectionBody = {\n      dataset,\n      validAt: validTime.toISOString(),\n      databaseAt: new Date().toISOString(),\n      geojson: MapService.normalizeToGeoJSON(wkt),\n      buffer\n    };\n    console.debug('Post body', postBody);\n    return this.http.post(this.baseURL + '/visualize/intersect', postBody)\n      .pipe(flatMap(this.parseToGeoJSONWorker))\n  }\n\n  /**\n   * Performa a spatio-temporal intersection for the given WKT boundary, returning the results as a list of {TrestleIndividual}\n   * @param {string} dataset to use\n   * @param {wktValue} wkt boundary\n   * @param {moment.Moment} validTime of intersection\n   * @param {moment.Moment} dbTime of intersection\n   * @param {number} buffer (in meters) around boundary\n   * @returns {Observable<TrestleIndividual[]>}\n   */\n  public stIntersectIndividual(dataset: string,\n                               wkt: wktValue,\n                               validTime?: Moment,\n                               dbTime?: Moment,\n                               buffer: number = 0): Observable<TrestleIndividual[]> {\n    const postBody: IIntersectionBody = {\n      dataset,\n      buffer,\n      geojson: MapService.normalizeToGeoJSON(wkt)\n    };\n\n    if (validTime) {\n      postBody.validAt = validTime.toISOString();\n    }\n\n    if (dbTime) {\n      postBody.databaseAt = dbTime.toISOString();\n    }\n\n    console.debug('Intersecting individuals with', postBody);\n\n    return this.http.post(this.baseURL + '/individual/intersect-individuals', postBody)\n      .pipe(map(MapService.parseResponseToIndividuals));\n  }\n\n  /**\n   * Perform a spatio-temporal comparison between the input object and the given set of comparison objects\n   * @param {ICompareBody} request\n   * @returns {Observable<IComparisonReport>}\n   */\n  public compareIndividuals(request: ICompareBody): Observable<IComparisonReport> {\n    return this.http.post<IComparisonReport>(this.baseURL+ '/visualize/compare', request);\n  }\n\n  /**\n   * Parses an input set of generic objects, by sending them to a web worker to do the interesting stuff\n   * @param {object[]} objects\n   * @returns {Observable<FeatureCollection<GeometryObject>>}\n   */\n  private parseToGeoJSONWorker = (objects: object[]): Observable<FeatureCollection<GeometryObject>> => {\n    console.debug('Sending to worker');\n    const id = new Date().getTime();\n    const workerRequest: IMapWorkerRequest = {\n      id,\n      response: objects\n    };\n\n    //    Dispatch the event\n    this.worker.postMessage(workerRequest);\n\n    //    Subscribe to the event stream\n    return new Observable((observer: Subscriber<FeatureCollection<GeometryObject>>) => {\n      this.workerStream\n        .pipe(filter(m => m.id === id))\n        .subscribe((msg) => {\n          console.debug('Has from worker:', msg);\n          observer.next(msg.geom);\n          observer.complete();\n        });\n    });\n  };\n\n  public static normalizeToGeoJSON(geom: wktValue): Polygon | MultiPolygon {\n    if (MapService.isGeometryObject(geom)) {\n      if (geom.type === 'Polygon') {\n        return (geom as Polygon);\n      } else if (geom.type === 'MultiPolygon') {\n        return (geom as MultiPolygon);\n      } else {\n        console.error('Not correct geom', geom);\n        throw new Error('Not correct geometry');\n      }\n    }\n    return {\n      type: 'Polygon',\n      // need to return and array of bounds as an array of SW -> NW -> NE -> SE -> SW\n      coordinates: [[geom.getSouthWest().toArray(),\n        geom.getNorthWest().toArray(),\n        geom.getNorthEast().toArray(),\n        geom.getSouthEast().toArray(),\n        geom.getSouthWest().toArray()]]\n      // crs: {type: \"name\", properties: {name: \"EPSG:4326\"}}\n    };\n  }\n\n  private static parseResponseToIndividuals(res: ITrestleIndividual[]): TrestleIndividual[] {\n    console.debug('Intersected result from server:', res);\n    return res\n      .map((individual: ITrestleIndividual) => new TrestleIndividual(individual));\n  }\n\n  private static isGeometryObject(x: any): x is GeometryObject {\n    return (x as GeometryObject).type !== undefined;\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient"
                    }
                ],
                "line": 76,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "MetricsService",
            "id": "injectable-MetricsService-2df419d1f3a9f8f616352bc29217c0ea",
            "file": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
            "properties": [
                {
                    "name": "baseUrl",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "exportMetricValues",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "null | string[]"
                        },
                        {
                            "name": "start",
                            "type": "number"
                        },
                        {
                            "name": "end",
                            "type": "number",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Blob>",
                    "typeParameters": [],
                    "line": 97,
                    "description": "<p>Export the given metric values as a CSV file</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2738,
                                "end": 2745,
                                "flags": 0,
                                "escapedText": "metrics"
                            },
                            "type": "null | string[]",
                            "tagName": {
                                "pos": 2714,
                                "end": 2719,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to export</p>\n",
                            "typeExpression": {
                                "pos": 2720,
                                "end": 2737,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2721,
                                    "end": 2736,
                                    "flags": 2097152,
                                    "kind": 168,
                                    "types": [
                                        {
                                            "pos": 2721,
                                            "end": 2729,
                                            "flags": 2097152,
                                            "kind": 166,
                                            "elementType": {
                                                "pos": 2721,
                                                "end": 2727,
                                                "flags": 2097152,
                                                "kind": 137
                                            }
                                        },
                                        {
                                            "pos": 2731,
                                            "end": 2736,
                                            "flags": 2097152,
                                            "kind": 95
                                        }
                                    ]
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2777,
                                "end": 2782,
                                "flags": 0,
                                "escapedText": "start"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 2762,
                                "end": 2767,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of temporal period</p>\n",
                            "typeExpression": {
                                "pos": 2768,
                                "end": 2776,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2769,
                                    "end": 2775,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2823,
                                "end": 2826,
                                "flags": 0,
                                "escapedText": "end"
                            },
                            "type": "number",
                            "optional": true,
                            "tagName": {
                                "pos": 2808,
                                "end": 2813,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of temporal period</p>\n",
                            "typeExpression": {
                                "pos": 2814,
                                "end": 2822,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2815,
                                    "end": 2821,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2852,
                                "end": 2859,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getMetrics",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<ITrestleMetricsHeader>",
                    "typeParameters": [],
                    "line": 39,
                    "description": "<p>Get initial data about available metrics</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 806,
                                "end": 813,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getMetricValues",
                    "args": [
                        {
                            "name": "metricID",
                            "type": "string"
                        },
                        {
                            "name": "start",
                            "type": "number"
                        },
                        {
                            "name": "end",
                            "type": "number"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<IMetricsData>",
                    "typeParameters": [],
                    "line": 51,
                    "description": "<p>Get values for a specified metric ID that falls within the given range</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1182,
                                "end": 1190,
                                "flags": 0,
                                "escapedText": "metricID"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1167,
                                "end": 1172,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to fetch</p>\n",
                            "typeExpression": {
                                "pos": 1173,
                                "end": 1181,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1174,
                                    "end": 1180,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1221,
                                "end": 1226,
                                "flags": 0,
                                "escapedText": "start"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 1206,
                                "end": 1211,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of temporal period for metrics data</p>\n",
                            "typeExpression": {
                                "pos": 1212,
                                "end": 1220,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1213,
                                    "end": 1219,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1284,
                                "end": 1287,
                                "flags": 0,
                                "escapedText": "end"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 1269,
                                "end": 1274,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>of temporal period for metrics data</p>\n",
                            "typeExpression": {
                                "pos": 1275,
                                "end": 1283,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1276,
                                    "end": 1282,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1330,
                                "end": 1337,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {HttpClient, HttpHeaders} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\nimport {Observable, throwError} from 'rxjs';\nimport {catchError, map, tap} from 'rxjs/operators';\n\nexport interface ITrestleMetricsHeader {\n  upTime: number;\n  startTime: number;\n  meters: Map<string, string>;\n}\n\nexport interface IMetricsData {\n  metric: string;\n  values: IMetricsValue[];\n}\n\nexport interface IMetricsValue {\n  timestamp: Date;\n  value: number;\n}\n\n@Injectable()\nexport class MetricsService {\n\n  private readonly baseUrl: string;\n\n  constructor(private authHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get initial data about available metrics\n   * @returns {Observable<ITrestleMetricsHeader>}\n   */\n  public getMetrics(): Observable<ITrestleMetricsHeader> {\n    return this.authHttp.get<ITrestleMetricsHeader>(this.baseUrl + '/metrics')\n      .pipe(catchError((error: Error) => throwError(error || 'Server Error')));\n  }\n\n  /**\n   * Get values for a specified metric ID that falls within the given range\n   * @param {string} metricID to fetch\n   * @param {number} start of temporal period for metrics data\n   * @param {number} end of temporal period for metrics data\n   * @returns {Observable<IMetricsData>}\n   */\n  public getMetricValues(metricID: string, start: number, end: number): Observable<IMetricsData> {\n    console.debug('Retrieving values for metric: ' + metricID + ' from: ' + start + ' to: ' + end);\n    const params = new HttpHeaders();\n    params.append('start', start.toString());\n    params.append('end', end.toString());\n    return this.authHttp.get(this.baseUrl + '/metrics/metric/' + metricID, {\n      params: {\n        start: start.toString(),\n        end: end.toString()\n      }\n    })\n      .pipe(\n        tap(json => console.debug('Metric values:', json)),\n        map(json => {\n          const metricValues: IMetricsValue[] = [];\n          Object.keys(json).forEach((key) => {\n            const longKey = parseInt(key, 10);\n            if (longKey !== 0) {\n              metricValues.push({\n                timestamp: new Date(longKey),\n                value: json[longKey]\n              });\n            }\n          });\n          return {\n            metric: metricID,\n            values: metricValues.sort((a, b) => {\n              if (a.timestamp === b.timestamp) {\n                return 0;\n              }\n              if (a.timestamp < b.timestamp) {\n                return -1;\n              }\n              return 1;\n            })\n          };\n        }));\n  }\n\n  /**\n   * Export the given metric values as a CSV file\n   * @param {string[] | null} metrics to export\n   * @param {number} start of temporal period\n   * @param {number} end of temporal period\n   * @returns {Observable<Blob>}\n   */\n  public exportMetricValues(metrics: null | string[], start: number, end?: number): Observable<Blob> {\n    return this.authHttp.post(this.baseUrl + '/metrics/export', {\n        metrics,\n        start,\n        end\n      },\n      {\n        responseType: 'blob'\n      });\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "authHttp",
                        "type": "HttpClient"
                    }
                ],
                "line": 29,
                "jsdoctags": [
                    {
                        "name": "authHttp",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "QueryService",
            "id": "injectable-QueryService-1b9faf03383110567576e673bda9c262",
            "file": "src/main/webapp/src/app/explore/query/query.service.ts",
            "properties": [
                {
                    "name": "baseUrl",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "executeQuery",
                    "args": [
                        {
                            "name": "queryString",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ITrestleResultSet>",
                    "typeParameters": [],
                    "line": 41,
                    "description": "<p>Execute SPARQL query and return the results</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 881,
                                "end": 892,
                                "flags": 0,
                                "escapedText": "queryString"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 866,
                                "end": 871,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 872,
                                "end": 880,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 873,
                                    "end": 879,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 899,
                                "end": 906,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getPrefixes",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<any>",
                    "typeParameters": [],
                    "line": 32,
                    "description": "<p>Get currently registered prefixes from the database</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 669,
                                "end": 676,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../../environments/environment';\n\nexport interface ITrestleResultSet {\n  rows: number;\n  bindingNames: Array<string>;\n  results: Array<ITrestleResult>;\n}\n\nexport interface ITrestleResult {\n  resultValues: Map<string, string>;\n}\n\n@Injectable()\nexport class QueryService {\n\n  private readonly baseUrl: string;\n\n  constructor(private trestleHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get currently registered prefixes from the database\n   * @returns {Observable<any>}\n   */\n  public getPrefixes(): Observable<any> {\n    return this.trestleHttp.get(this.baseUrl+ '/query');\n  }\n\n  /**\n   * Execute SPARQL query and return the results\n   * @param {string} queryString\n   * @returns {Observable<ITrestleResultSet>}\n   */\n  public executeQuery(queryString: string): Observable<ITrestleResultSet> {\n    console.debug('Query string:', queryString);\n    return this.trestleHttp.post<ITrestleResultSet>(this.baseUrl+ '/query', queryString);\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "trestleHttp",
                        "type": "HttpClient"
                    }
                ],
                "line": 22,
                "jsdoctags": [
                    {
                        "name": "trestleHttp",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "UserService",
            "id": "injectable-UserService-aa598638ec7da9fb3f566bb4ba20d368",
            "file": "src/main/webapp/src/app/user/users.service.ts",
            "properties": [
                {
                    "name": "baseUrl",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "deleteUser",
                    "args": [
                        {
                            "name": "id",
                            "type": "number"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<any>",
                    "typeParameters": [],
                    "line": 50,
                    "description": "<p>Delete user from database</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1269,
                                "end": 1271,
                                "flags": 0,
                                "escapedText": "id"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 1263,
                                "end": 1268,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>ID of user to delete</li>\n</ul>\n"
                        },
                        {
                            "tagName": {
                                "pos": 1301,
                                "end": 1308,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getUsers",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<ITrestleUser[]>",
                    "typeParameters": [],
                    "line": 26,
                    "description": "<p>Get a list of all registered users\nRequires ADMIN permissions</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 581,
                                "end": 588,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "modifyUser",
                    "args": [
                        {
                            "name": "user",
                            "type": "ITrestleUser"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string>",
                    "typeParameters": [],
                    "line": 39,
                    "description": "<p>Sends an {@link ITrestleUser} object to the server\nEither creates the new user or modifies an existing one</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 982,
                                "end": 986,
                                "flags": 0,
                                "escapedText": "user"
                            },
                            "type": "ITrestleUser",
                            "tagName": {
                                "pos": 976,
                                "end": 981,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>User to create/modify</li>\n</ul>\n"
                        },
                        {
                            "tagName": {
                                "pos": 1017,
                                "end": 1024,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "userExists",
                    "args": [
                        {
                            "name": "username",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<boolean>",
                    "typeParameters": [],
                    "line": 60,
                    "description": "<p>Determines whether or not a given username exists in the application</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1562,
                                "end": 1570,
                                "flags": 0,
                                "escapedText": "username"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1547,
                                "end": 1552,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1553,
                                "end": 1561,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1554,
                                    "end": 1560,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1577,
                                "end": 1584,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "description": "",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {ITrestleUser} from './authentication.service';\nimport {HttpClient} from '@angular/common/http';\nimport {environment} from '../../environments/environment';\nimport {tap} from 'rxjs/operators';\n\n@Injectable()\nexport class UserService {\n\n  private readonly baseUrl: string;\n\n  constructor(private trestleHttp: HttpClient) {\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Get a list of all registered users\n   * Requires ADMIN permissions\n   *\n   * @returns {Observable<ITrestleUser[]>}\n   */\n  public getUsers(): Observable<ITrestleUser[]> {\n    console.debug(\"Getting users?\");\n    return this.trestleHttp.get<ITrestleUser[]>(this.baseUrl + '/users')\n      .pipe(tap(l => console.debug(\"Logging:\", l)));\n  }\n\n  /**\n   * Sends an {@link ITrestleUser} object to the server\n   * Either creates the new user or modifies an existing one\n   *\n   * @param user - User to create/modify\n   * @returns {Observable<string>}\n   */\n  public modifyUser(user: ITrestleUser): Observable<string> {\n    return this.trestleHttp.post(this.baseUrl + '/users', user, {\n      responseType: 'text'\n    });\n  }\n\n  /**\n   * Delete user from database\n   * @param id - ID of user to delete\n   * @returns {Observable<any>}\n   */\n  public deleteUser(id: number): Observable<any> {\n    return this.trestleHttp.delete(this.baseUrl + '/users/' + id);\n  }\n\n  /**\n   * Determines whether or not a given username exists in the application\n   *\n   * @param {string} username\n   * @returns {Observable<boolean>}\n   */\n  public userExists(username: string): Observable<boolean> {\n    console.debug('Checking username:', username);\n    return this.trestleHttp.get<boolean>(this.baseUrl + '/users/exists/' + username);\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "trestleHttp",
                        "type": "HttpClient"
                    }
                ],
                "line": 14,
                "jsdoctags": [
                    {
                        "name": "trestleHttp",
                        "type": "HttpClient",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        }
    ],
    "classes": [
        {
            "name": "DashboardPageObject",
            "id": "class-DashboardPageObject-b5c5db99b98a9e7a78ec6e78127c8604",
            "file": "src/test/e2e/page_objects/main.page.ts",
            "type": "class",
            "sourceCode": "import { browser, by, element } from \"protractor\";\n\nexport type PageActionType = \"admin\" | \"dba\";\n\nexport class DashboardPageObject {\n\n    constructor() {\n    }\n\n    public async goToLoginPage() {\n        return browser.get(\"/login/\");\n    }\n\n    public async navigateToPage(page: string) {\n        return element(by.css(\"a[id='\" + page + \"']\")).click();\n    }\n\n    public async clickButton(button: string) {\n        return element(by.id(button)).click();\n    }\n\n    public async getPageActions(optionType: PageActionType): Promise<number> {\n        return element(by.id(optionType + \"-actions\")).all(by.tagName(\"a\")).count();\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 8
            },
            "properties": [],
            "methods": [
                {
                    "name": "clickButton",
                    "args": [
                        {
                            "name": "button",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 21,
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "button",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getPageActions",
                    "args": [
                        {
                            "name": "optionType",
                            "type": "PageActionType"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<number>",
                    "typeParameters": [],
                    "line": 25,
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "optionType",
                            "type": "PageActionType",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "goToLoginPage",
                    "args": [],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 13,
                    "modifierKind": [
                        114,
                        120
                    ]
                },
                {
                    "name": "navigateToPage",
                    "args": [
                        {
                            "name": "page",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 17,
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "LoginPageObject",
            "id": "class-LoginPageObject-8352da2a772259933e3862e2b4dd6a6b",
            "file": "src/test/e2e/page_objects/login.page.ts",
            "type": "class",
            "sourceCode": "import {browser, by, element, ElementFinder, Locator} from 'protractor';\nimport {promise} from 'selenium-webdriver';\n\nexport class LoginPageObject {\n\n  private header: ElementFinder;\n  private usernameField: ElementFinder;\n  private passwordField: ElementFinder;\n\n  constructor() {\n    this.header = element(by.css('mat-card-header'));\n    this.usernameField = element(by.css('input[formcontrolname=\"username\"]'));\n    this.passwordField = element(by.css('input[formcontrolname=\\'password\\']'));\n  }\n\n  public async getTitle() {\n    return this.header.getText();\n  }\n\n  /**\n   * Fill in user login details, and optionally submit them\n   * @param {string} username - Username to fill in\n   * @param {string} password - Password to fill in\n   * @param {boolean} login - Should we login the user?\n   * @returns {Promise<void>}\n   */\n  public async loginUser(username: string, password: string, login?: boolean): Promise<void> {\n    // Try to click the login button, if it doesn't exist, click logout\n    const loginButton = element(by.css('[routerLink=\\'/login\\']'));\n    const isPresent = await loginButton.isPresent();\n    if (isPresent) {\n      await loginButton.click();\n    } else {\n      // Logout and log in again\n      await element(by.id('logout')).click();\n      await browser.sleep(1000);\n      await loginButton.click();\n    }\n    await this.usernameField.clear();\n    await this.usernameField.sendKeys(username);\n    await this.passwordField.clear();\n    await this.passwordField.sendKeys(password);\n\n    if (login) {\n      element(by.buttonText('Submit')).click();\n    }\n\n    return browser.sleep(1000);\n  }\n\n  /**\n   * Determines if the form matches the given valid state\n   *\n   * @param {boolean} valid - Should the form be value?\n   * @returns {Promise<boolean>} - The form matches the given valid state\n   */\n  public async formValidState(valid: boolean): Promise<boolean> {\n    const formSelector = by.css('form');\n    if (valid) {\n      return this.elementHasClass(formSelector, 'ng-valid');\n    }\n    return this.elementHasClass(formSelector, 'ng-invalid');\n  }\n\n  /**\n   * Returns the text for the given element\n   * @param {Locator} selector - Selector to use\n   * @returns {Promise<string>} - Element text\n   */\n  public async getElementText(selector: Locator): promise.Promise<string> {\n    return element(selector).getText();\n  }\n\n  /**\n   * * Determines if the element for the given selector contains the specified class\n   * @param {Locator} selector - selector to use\n   * @param {string} clazz - String class name\n   * @returns {Promise<boolean>} - The element contains the specified class\n   */\n  private async elementHasClass(selector: Locator, clazz: string): Promise<boolean> {\n    return element(selector).getAttribute('class')\n      .then((classes) => {\n        return classes.split(' ').indexOf(clazz) !== -1;\n      });\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 11
            },
            "properties": [
                {
                    "name": "header",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 9,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "passwordField",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "usernameField",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "elementHasClass",
                    "args": [
                        {
                            "name": "selector",
                            "type": "Locator"
                        },
                        {
                            "name": "clazz",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<boolean>",
                    "typeParameters": [],
                    "line": 83,
                    "description": "<ul>\n<li>Determines if the element for the given selector contains the specified class</li>\n</ul>\n",
                    "modifierKind": [
                        112,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2511,
                                "end": 2519,
                                "flags": 0,
                                "escapedText": "selector"
                            },
                            "type": "Locator",
                            "tagName": {
                                "pos": 2495,
                                "end": 2500,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>selector to use</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 2501,
                                "end": 2510,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2502,
                                    "end": 2509,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2502,
                                        "end": 2509,
                                        "flags": 2097152,
                                        "escapedText": "Locator"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2559,
                                "end": 2564,
                                "flags": 0,
                                "escapedText": "clazz"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 2544,
                                "end": 2549,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>String class name</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 2550,
                                "end": 2558,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2551,
                                    "end": 2557,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2591,
                                "end": 2598,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>The element contains the specified class</li>\n</ul>\n",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "formValidState",
                    "args": [
                        {
                            "name": "valid",
                            "type": "boolean"
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<boolean>",
                    "typeParameters": [],
                    "line": 60,
                    "description": "<p>Determines if the form matches the given valid state</p>\n",
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1754,
                                "end": 1759,
                                "flags": 0,
                                "escapedText": "valid"
                            },
                            "type": "boolean",
                            "tagName": {
                                "pos": 1738,
                                "end": 1743,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Should the form be value?</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1744,
                                "end": 1753,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1745,
                                    "end": 1752,
                                    "flags": 2097152,
                                    "kind": 122
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1794,
                                "end": 1801,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>The form matches the given valid state</li>\n</ul>\n",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getElementText",
                    "args": [
                        {
                            "name": "selector",
                            "type": "Locator"
                        }
                    ],
                    "optional": false,
                    "returnType": "promise.Promise<string>",
                    "typeParameters": [],
                    "line": 73,
                    "description": "<p>Returns the text for the given element</p>\n",
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2197,
                                "end": 2205,
                                "flags": 0,
                                "escapedText": "selector"
                            },
                            "type": "Locator",
                            "tagName": {
                                "pos": 2181,
                                "end": 2186,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Selector to use</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 2187,
                                "end": 2196,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2188,
                                    "end": 2195,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2188,
                                        "end": 2195,
                                        "flags": 2097152,
                                        "escapedText": "Locator"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2230,
                                "end": 2237,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>Element text</li>\n</ul>\n",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getTitle",
                    "args": [],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 19,
                    "modifierKind": [
                        114,
                        120
                    ]
                },
                {
                    "name": "loginUser",
                    "args": [
                        {
                            "name": "username",
                            "type": "string"
                        },
                        {
                            "name": "password",
                            "type": "string"
                        },
                        {
                            "name": "login",
                            "type": "boolean",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<void>",
                    "typeParameters": [],
                    "line": 30,
                    "description": "<p>Fill in user login details, and optionally submit them</p>\n",
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 698,
                                "end": 706,
                                "flags": 0,
                                "escapedText": "username"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 683,
                                "end": 688,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Username to fill in</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 689,
                                "end": 697,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 690,
                                    "end": 696,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 750,
                                "end": 758,
                                "flags": 0,
                                "escapedText": "password"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 735,
                                "end": 740,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Password to fill in</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 741,
                                "end": 749,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 742,
                                    "end": 748,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 803,
                                "end": 808,
                                "flags": 0,
                                "escapedText": "login"
                            },
                            "type": "boolean",
                            "optional": true,
                            "tagName": {
                                "pos": 787,
                                "end": 792,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Should we login the user?</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 793,
                                "end": 802,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 794,
                                    "end": 801,
                                    "flags": 2097152,
                                    "kind": 122
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 843,
                                "end": 850,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "TrestleEvent",
            "id": "class-TrestleEvent-285cc34959ea8f022ef4bed8514e842a",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-event.ts",
            "type": "class",
            "sourceCode": "import { IInterfacable } from \"../../interfacable\";\nimport moment from \"moment\";\n\nexport interface ITrestleEvent {\n    individual: string;\n    type: string;\n    temporal: string;\n}\n\nexport enum TrestleEventType {\n    CREATED,\n    DESTROYED,\n    BECAME,\n    SPLIT,\n    MERGED\n}\n\nexport class TrestleEvent implements IInterfacable<ITrestleEvent> {\n    private individual: string;\n    private type: string;\n    private temporal: moment.Moment;\n\n    constructor(event: ITrestleEvent) {\n        this.individual = event.individual;\n        this.type = event.type;\n        this.temporal = moment(event.temporal, moment.ISO_8601);\n    }\n\n    public getIndividual() {\n        return this.individual;\n    }\n\n    public getType() {\n        return this.type;\n    }\n\n    public getTemporal() {\n        return this.temporal;\n    }\n\n    public asInterface() {\n        return {\n            individual: this.individual,\n            type: this.type,\n            temporal: this.temporal.toISOString()\n        };\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "event",
                        "type": "ITrestleEvent"
                    }
                ],
                "line": 21,
                "jsdoctags": [
                    {
                        "name": "event",
                        "type": "ITrestleEvent",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "individual",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "temporal",
                    "type": "moment.Moment",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "type",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "asInterface",
                    "args": [],
                    "optional": false,
                    "returnType": "{ individual: string; type: string; temporal: any; }",
                    "typeParameters": [],
                    "line": 41,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getIndividual",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 29,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getTemporal",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 37,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getType",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 33,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IInterfacable"
            ]
        },
        {
            "name": "TrestleFact",
            "id": "class-TrestleFact-1063ee5415de3590c6cca9ee652ce334",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-fact.ts",
            "type": "class",
            "sourceCode": "import { ITrestleTemporal, TrestleTemporal } from \"./trestle-temporal\";\nimport { IInterfacable } from \"../../interfacable\";\nimport * as moment from \"moment\";\n\nexport interface ITrestleFact {\n    identifier: string;\n    name: string;\n    type: string;\n    value: string;\n    databaseTemporal: ITrestleTemporal;\n    validTemporal: ITrestleTemporal;\n}\n\nexport class TrestleFact implements IInterfacable<ITrestleFact> {\n    private identifier: string;\n    private name: string;\n    private type: string;\n    private value: string;\n    private databaseTemporal: TrestleTemporal;\n    private validTemporal: TrestleTemporal;\n\n    constructor(fact: ITrestleFact) {\n        this.identifier = fact.identifier;\n        this.name = fact.name;\n        this.type = fact.type;\n        this.value = fact.value;\n        this.databaseTemporal = new TrestleTemporal(fact.databaseTemporal);\n        this.validTemporal = new TrestleTemporal(fact.validTemporal);\n    }\n\n    public getID(): string {\n        return this.identifier;\n    }\n\n    public getName(): string {\n        return this.name;\n    }\n\n    public getValue(): string {\n        return this.value;\n    }\n\n    public getType(): string {\n        return this.type;\n    }\n\n    public getValidTemporal(): TrestleTemporal {\n        return this.validTemporal;\n    }\n\n    public getDatabaseTemporal(): TrestleTemporal {\n        return this.databaseTemporal;\n    }\n\n    public isSpatial(): boolean {\n        return this.name === \"asWKT\";\n    }\n\n    /**\n     * Is this fact active at the specified valid/database intersection\n     * @param {moment.Moment} validAt\n     * @param {moment.Moment} dbAt\n     * @returns {boolean}\n     */\n    public isActive(validAt: moment.Moment, dbAt?: moment.Moment): boolean {\n        if (dbAt) {\n            return this.getValidTemporal().isActive(validAt) &&\n                this.getDatabaseTemporal().isActive(dbAt);\n        } else {\n            return this.getValidTemporal().isActive(validAt);\n        }\n    }\n\n    public asInterface(): ITrestleFact {\n        return {\n            identifier: this.identifier,\n            name: this.name,\n            type: this.type,\n            value: this.value,\n            databaseTemporal: this.databaseTemporal.asInterface(),\n            validTemporal: this.validTemporal.asInterface()\n        };\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "fact",
                        "type": "ITrestleFact"
                    }
                ],
                "line": 20,
                "jsdoctags": [
                    {
                        "name": "fact",
                        "type": "ITrestleFact",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "databaseTemporal",
                    "type": "TrestleTemporal",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "identifier",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "name",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "type",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "validTemporal",
                    "type": "TrestleTemporal",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "value",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "asInterface",
                    "args": [],
                    "optional": false,
                    "returnType": "ITrestleFact",
                    "typeParameters": [],
                    "line": 74,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getDatabaseTemporal",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleTemporal",
                    "typeParameters": [],
                    "line": 51,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getID",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 31,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getName",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 35,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getType",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 43,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getValidTemporal",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleTemporal",
                    "typeParameters": [],
                    "line": 47,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getValue",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 39,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "isActive",
                    "args": [
                        {
                            "name": "validAt",
                            "type": "moment.Moment"
                        },
                        {
                            "name": "dbAt",
                            "type": "moment.Moment",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 65,
                    "description": "<p>Is this fact active at the specified valid/database intersection</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1587,
                                "end": 1594,
                                "flags": 0,
                                "escapedText": "validAt"
                            },
                            "type": "moment.Moment",
                            "tagName": {
                                "pos": 1565,
                                "end": 1570,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1571,
                                "end": 1586,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1572,
                                    "end": 1585,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1572,
                                        "end": 1585,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 1572,
                                            "end": 1578,
                                            "flags": 2097152,
                                            "escapedText": "moment"
                                        },
                                        "right": {
                                            "pos": 1579,
                                            "end": 1585,
                                            "flags": 2097152,
                                            "escapedText": "Moment"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1625,
                                "end": 1629,
                                "flags": 0,
                                "escapedText": "dbAt"
                            },
                            "type": "moment.Moment",
                            "optional": true,
                            "tagName": {
                                "pos": 1603,
                                "end": 1608,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1609,
                                "end": 1624,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1610,
                                    "end": 1623,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1610,
                                        "end": 1623,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 1610,
                                            "end": 1616,
                                            "flags": 2097152,
                                            "escapedText": "moment"
                                        },
                                        "right": {
                                            "pos": 1617,
                                            "end": 1623,
                                            "flags": 2097152,
                                            "escapedText": "Moment"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1638,
                                "end": 1645,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "isSpatial",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 55,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IInterfacable"
            ]
        },
        {
            "name": "TrestleIndividual",
            "id": "class-TrestleIndividual-a085e9f4989203c659d28b5a171482dc",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-individual.ts",
            "type": "class",
            "sourceCode": "import { ITrestleTemporal, TrestleTemporal } from \"./trestle-temporal\";\nimport { ITrestleFact, TrestleFact } from \"./trestle-fact\";\nimport { ITrestleRelation, TrestleRelation } from \"./trestle-relation\";\nimport { ITrestleEvent, TrestleEvent } from \"./trestle-event\";\nimport { GeometryObject } from \"geojson\";\nimport { IInterfacable } from \"../../interfacable\";\nimport { parse } from \"wellknown\";\nimport SortedArray from 'sorted-array';\n\nexport interface ITrestleIndividual {\n    individualID: string;\n    existsTemporal: ITrestleTemporal;\n    facts: ITrestleFact[];\n    relations: ITrestleRelation[];\n    events: ITrestleEvent[];\n}\n\nexport class TrestleIndividual implements IInterfacable<ITrestleIndividual> {\n\n    private static suffixRegex = /.*[\\/#]([^\\/#]*)$/g;\n    private static prefixRegex = /.*[\\/#]/g;\n    private static hostnameRegex = /\\w+:\\/\\/[^\\/]*/g;\n    private readonly id: string;\n    private filteredID?: string;\n    private facts: SortedArray<TrestleFact>;\n    private spatialFact?: TrestleFact;\n    private relations: TrestleRelation[] = [];\n    private events: TrestleEvent[] = [];\n    private readonly existsTemporal: TrestleTemporal;\n\n    constructor(individual: ITrestleIndividual) {\n        this.id = individual.individualID;\n        this.facts = new SortedArray<TrestleFact>([], TrestleIndividual.factSort);\n        this.existsTemporal = new TrestleTemporal(individual.existsTemporal);\n        individual.facts.forEach((fact) => {\n            const factClass = new TrestleFact(fact);\n            // Set as spatial fact, if that's the case\n            if (factClass.isSpatial()) {\n                this.spatialFact = factClass;\n            }\n            this.facts.insert(factClass);\n        });\n        individual.relations.forEach((relation) => {\n            this.relations.push(new TrestleRelation(relation));\n        });\n        individual.events.forEach((event) => this.events.push(new TrestleEvent(event)));\n    }\n\n    /**\n     * Get Individual ID\n     * @returns {string}\n     */\n    public getID(): string {\n        return this.id;\n    }\n\n    /**\n     * Get the individual ID, without the URI base or temporal range\n     * @returns {string}\n     */\n    public getFilteredID(): string {\n        if (this.filteredID) {\n            return this.filteredID;\n        }\n        this.filteredID = TrestleIndividual.filterID(this.id);\n        return this.filteredID;\n    }\n\n    /**\n     * Gets the URI base of the individual ID\n     * @returns {string}\n     */\n    public getHostname(): string {\n        return TrestleIndividual.extractHostname(this.id);\n    }\n\n    /**\n     * Get the individual ID, without the URI base\n     * @returns {string}\n     */\n    public withoutHostname(): string {\n        return TrestleIndividual.withoutHostname(this.id);\n    }\n\n    /**\n     * Return the filtered individual ID as a hashed numeric value\n     * Currently using the SBDM algorithm\n     * @returns {number}\n     */\n    public getIDAsInteger(): number {\n        return TrestleIndividual.hashID(this.getFilteredID());\n    }\n\n    /**\n     * Get the Existence temporal for the individual\n     * @returns {TrestleTemporal}\n     */\n    public getTemporal(): TrestleTemporal {\n        return this.existsTemporal;\n    }\n\n    /**\n     * Get the spatial fact for the individual, parsed as a {GeometryObject}\n     * @returns {GeometryObject}\n     */\n    public getSpatialValue(): GeometryObject {\n\n        if (this.spatialFact) {\n            const geojson = parse(this.spatialFact.getValue());\n            if (geojson !== null) {\n                return geojson;\n            }\n            console.error(\"Failed to parse:\", this.spatialFact.getValue());\n        }\n        throw new Error(\"Individual \" + this.getID() + \" is not spatial and should be\");\n    }\n\n    /**\n     * Get the sptial fact for the indivdual, as a WKT string\n     * @returns {string}\n     */\n    public getSpatialValueAsWKT(): string {\n        if (this.spatialFact) {\n            return this.spatialFact.getValue();\n        }\n        throw new Error(\"Individual \" + this.getID() + \" is not spatial and should be\");\n    }\n\n    /**\n     * Get an {Iterable} of {TrestleFact} of all facts for the individual\n     * @returns {TrestleFact[]}\n     */\n    public getFacts(): TrestleFact[] {\n        return this.facts.array;\n    }\n\n    /**\n     * Returns a collection of fact names and associated values\n     * @returns {{[p: string]: any}}\n     */\n    public getFactValues(): { [name: string]: any } {\n        const values: { [name: string]: any } = {};\n        this.facts.array.forEach((value) => {\n            values[value.getName()] = value.getValue();\n        });\n        return values;\n    }\n\n    /**\n     * Get all Individual relations\n     * @returns {TrestleRelation[]}\n     */\n    public getRelations(): TrestleRelation[] {\n        return this.relations;\n    }\n\n    /**\n     * Get all individual events\n     * @returns {TrestleEvent[]}\n     */\n    public getEvents(): TrestleEvent[] {\n        return this.events;\n    }\n\n    /**\n     * Gets the start event for the given selection.\n     * Returns a MERGED event, if one exists\n     * Otherwise, returns CREATED\n     * @returns {TrestleEvent}\n     */\n    public getStartEvent(): TrestleEvent {\n        const mergedEvent = this.getEvents()\n            .filter((event) => event.getType() === \"MERGED\");\n\n        if (mergedEvent.length > 0) {\n            return mergedEvent[0];\n        }\n        const createdEvent = this.getEvents()\n            .filter((event) => event.getType() === \"CREATED\");\n        if (createdEvent.length > 0) {\n            return createdEvent[0];\n        }\n        throw new Error(\"Individual: \" + this.getID() + \" does not have a CREATED/MERGED event\");\n    }\n\n    /**\n     * Returns the end event, if one exists\n     * If a SPLIT event exists, returns that\n     * Otherwise, returns DESTROYED\n     * Returns\n     * @returns {TrestleEvent}\n     */\n    public getEndEvent(): TrestleEvent | null {\n        const splitEvent = this.getEvents()\n            .filter((event) => event.getType() === \"SPLIT\");\n        if (splitEvent.length > 0) {\n            return splitEvent[0];\n        }\n\n        const destroyedEvent = this.getEvents()\n            .filter((event) => event.getType() === \"DESTROYED\");\n        if (destroyedEvent.length > 0) {\n            return destroyedEvent[0];\n        }\n\n        return null;\n    }\n\n    /**\n     * Is this individual a part of a spatial union?\n     * @returns {boolean}\n     */\n    public isUnion(): boolean {\n        return this.relations.some((relation) => relation.isUnionType());\n    }\n\n    /**\n     * Transform the individual back into its Interface type\n     * @returns {ITrestleIndividual}\n     */\n    public asInterface(): ITrestleIndividual {\n        const returnValue: ITrestleIndividual = {\n            individualID: this.id,\n            existsTemporal: this.existsTemporal.asInterface(),\n            facts: [],\n            relations: [],\n            events: []\n        };\n        this.facts.array.forEach((value) => {\n            returnValue.facts.push(value.asInterface());\n        });\n        this.relations.forEach((value) => {\n            returnValue.relations.push(value.asInterface());\n        });\n        this.events.forEach((event) => returnValue.events.push(event.asInterface()));\n        return returnValue;\n    }\n\n    /**\n     * Remove dates from ID\n     * @param {string} id\n     * @returns {string}\n     */\n    public static filterID(id: string): string {\n        const suffix = TrestleIndividual.extractSuffix(id);\n        const idStrings = suffix.split(\":\");\n        // return idStrings[0] + \":\" + idStrings[1];\n        return idStrings[0];\n    }\n\n    /**\n     * Filter ID string to remove hostname (authority)\n     * @param {string} id\n     * @returns {string}\n     */\n    public static withoutHostname(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.hostnameRegex.lastIndex = 0;\n        return id.replace(TrestleIndividual.hostnameRegex, \"\");\n    }\n\n    /**\n     * Get the URI hostname\n     * Returns an empty string if nothing matches\n     * @param {string} id\n     * @returns {string}\n     */\n    public static extractHostname(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.hostnameRegex.lastIndex = 0;\n        const matches = id.match(TrestleIndividual.hostnameRegex);\n        if (matches !== null) {\n            return matches[0];\n        }\n        return \"\";\n    }\n\n\n    /**\n     * Extracts the suffix from the individual, or returns an empty string\n     * @param {string} id\n     * @returns {string}\n     */\n    public static extractSuffix(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.suffixRegex.lastIndex = 0;\n        const matches = TrestleIndividual.suffixRegex.exec(id);\n        if (matches !== null) {\n            return matches[1];\n        }\n        return \"\";\n    }\n\n    /**\n     * Extracts the prefix from the individual, or returns an empty string\n     * @param {string} id\n     * @returns {string}\n     */\n    public static extractPrefix(id: string): string {\n        // Manually reset regex match, because Javascript\n        TrestleIndividual.prefixRegex.lastIndex = 0;\n        const matches = id.match(TrestleIndividual.prefixRegex);\n        if (matches !== null) {\n            return matches[0];\n        }\n        return \"\";\n    }\n\n    /**\n     * SDBM algorithm for generating a numeric value of a provided string\n     * @param {string} id\n     * @returns {number}\n     */\n    public static hashID(id: string): number {\n        let hash = 0;\n        for (let i = 0; i < id.length; i++) {\n            const char = id.charCodeAt(i);\n            // eslint-disable-next-line no-bitwise\n            hash = char + (hash << 6) + (hash << 16) - hash;\n        }\n        return hash;\n    }\n\n    /**\n     * Sorter for the Fact array which sorts by ID -> validFrom -> dbFrom\n     *\n     * @param {TrestleFact} a\n     * @param {TrestleFact} b\n     * @returns {number}\n     */\n    private static factSort(a: TrestleFact, b: TrestleFact): number {\n        const idCompare = a.getID().localeCompare(b.getID());\n        // If they're not equal, return\n        if (idCompare !== 0) {\n            return idCompare;\n        }\n        //    Next, compare on valid from\n        const vEqual = a.getValidTemporal().getFrom().isSame(b.getValidTemporal().getFrom());\n        // If they're not equal, is A before?\n        if (!vEqual) {\n            return a.getValidTemporal().getFrom().isBefore(b.getValidTemporal().getFrom()) ? -1 : 1;\n        }\n        //    Finally, db time\n        const dEqual = a.getDatabaseTemporal().getFrom().isSame(b.getDatabaseTemporal().getFrom());\n        if (!dEqual) {\n            return a.getDatabaseTemporal().getFrom().isBefore(b.getDatabaseTemporal().getFrom()) ? -1 : 1;\n        }\n        return 0;\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "individual",
                        "type": "ITrestleIndividual"
                    }
                ],
                "line": 29,
                "jsdoctags": [
                    {
                        "name": "individual",
                        "type": "ITrestleIndividual",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "events",
                    "defaultValue": "[]",
                    "type": "TrestleEvent[]",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "existsTemporal",
                    "type": "TrestleTemporal",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "facts",
                    "type": "SortedArray<TrestleFact>",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "filteredID",
                    "type": "string",
                    "optional": true,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "hostnameRegex",
                    "defaultValue": "/\\w+:\\/\\/[^\\/]*/g",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        112,
                        115
                    ]
                },
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "prefixRegex",
                    "defaultValue": "/.*[\\/#]/g",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        112,
                        115
                    ]
                },
                {
                    "name": "relations",
                    "defaultValue": "[]",
                    "type": "TrestleRelation[]",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "spatialFact",
                    "type": "TrestleFact",
                    "optional": true,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "suffixRegex",
                    "defaultValue": "/.*[\\/#]([^\\/#]*)$/g",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        112,
                        115
                    ]
                }
            ],
            "methods": [
                {
                    "name": "asInterface",
                    "args": [],
                    "optional": false,
                    "returnType": "ITrestleIndividual",
                    "typeParameters": [],
                    "line": 221,
                    "description": "<p>Transform the individual back into its Interface type</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 6647,
                                "end": 6654,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "extractHostname",
                    "args": [
                        {
                            "name": "id",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 268,
                    "description": "<p>Get the URI hostname\nReturns an empty string if nothing matches</p>\n",
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 8125,
                                "end": 8127,
                                "flags": 0,
                                "escapedText": "id"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 8110,
                                "end": 8115,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 8116,
                                "end": 8124,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 8117,
                                    "end": 8123,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 8136,
                                "end": 8143,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "extractPrefix",
                    "args": [
                        {
                            "name": "id",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 299,
                    "description": "<p>Extracts the prefix from the individual, or returns an empty string</p>\n",
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 9073,
                                "end": 9075,
                                "flags": 0,
                                "escapedText": "id"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 9058,
                                "end": 9063,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9064,
                                "end": 9072,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9065,
                                    "end": 9071,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 9084,
                                "end": 9091,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "extractSuffix",
                    "args": [
                        {
                            "name": "id",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 284,
                    "description": "<p>Extracts the suffix from the individual, or returns an empty string</p>\n",
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 8603,
                                "end": 8605,
                                "flags": 0,
                                "escapedText": "id"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 8588,
                                "end": 8593,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 8594,
                                "end": 8602,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 8595,
                                    "end": 8601,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 8614,
                                "end": 8621,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "factSort",
                    "args": [
                        {
                            "name": "a",
                            "type": "TrestleFact"
                        },
                        {
                            "name": "b",
                            "type": "TrestleFact"
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 331,
                    "description": "<p>Sorter for the Fact array which sorts by ID -&gt; validFrom -&gt; dbFrom</p>\n",
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 10004,
                                "end": 10005,
                                "flags": 0,
                                "escapedText": "a"
                            },
                            "type": "TrestleFact",
                            "tagName": {
                                "pos": 9984,
                                "end": 9989,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9990,
                                "end": 10003,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9991,
                                    "end": 10002,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 9991,
                                        "end": 10002,
                                        "flags": 2097152,
                                        "escapedText": "TrestleFact"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 10034,
                                "end": 10035,
                                "flags": 0,
                                "escapedText": "b"
                            },
                            "type": "TrestleFact",
                            "tagName": {
                                "pos": 10014,
                                "end": 10019,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 10020,
                                "end": 10033,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 10021,
                                    "end": 10032,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 10021,
                                        "end": 10032,
                                        "flags": 2097152,
                                        "escapedText": "TrestleFact"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 10044,
                                "end": 10051,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "number"
                        }
                    ]
                },
                {
                    "name": "filterID",
                    "args": [
                        {
                            "name": "id",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 244,
                    "description": "<p>Remove dates from ID</p>\n",
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 7375,
                                "end": 7377,
                                "flags": 0,
                                "escapedText": "id"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 7360,
                                "end": 7365,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 7366,
                                "end": 7374,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7367,
                                    "end": 7373,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 7386,
                                "end": 7393,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "getEndEvent",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleEvent | null",
                    "typeParameters": [],
                    "line": 193,
                    "description": "<p>Returns the end event, if one exists\nIf a SPLIT event exists, returns that\nOtherwise, returns DESTROYED\nReturns</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 5865,
                                "end": 5872,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getEvents",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleEvent[]",
                    "typeParameters": [],
                    "line": 161,
                    "description": "<p>Get all individual events</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 4888,
                                "end": 4895,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "[]"
                        }
                    ]
                },
                {
                    "name": "getFacts",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleFact[]",
                    "typeParameters": [],
                    "line": 133,
                    "description": "<p>Get an {Iterable} of {TrestleFact} of all facts for the individual</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 4188,
                                "end": 4195,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "[]"
                        }
                    ]
                },
                {
                    "name": "getFactValues",
                    "args": [],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 141,
                    "description": "<p>Returns a collection of fact names and associated values</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 4379,
                                "end": 4386,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "literal type"
                        }
                    ]
                },
                {
                    "name": "getFilteredID",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 61,
                    "description": "<p>Get the individual ID, without the URI base or temporal range</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2157,
                                "end": 2164,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "getHostname",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 73,
                    "description": "<p>Gets the URI base of the individual ID</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2460,
                                "end": 2467,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "getID",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 53,
                    "description": "<p>Get Individual ID</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1987,
                                "end": 1994,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "getIDAsInteger",
                    "args": [],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 90,
                    "description": "<p>Return the filtered individual ID as a hashed numeric value\nCurrently using the SBDM algorithm</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2908,
                                "end": 2915,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "number"
                        }
                    ]
                },
                {
                    "name": "getRelations",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleRelation[]",
                    "typeParameters": [],
                    "line": 153,
                    "description": "<p>Get all Individual relations</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 4718,
                                "end": 4725,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "[]"
                        }
                    ]
                },
                {
                    "name": "getSpatialValue",
                    "args": [],
                    "optional": false,
                    "returnType": "GeometryObject",
                    "typeParameters": [],
                    "line": 106,
                    "description": "<p>Get the spatial fact for the individual, parsed as a {GeometryObject}</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 3324,
                                "end": 3331,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getSpatialValueAsWKT",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 122,
                    "description": "<p>Get the sptial fact for the indivdual, as a WKT string</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 3843,
                                "end": 3850,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "getStartEvent",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleEvent",
                    "typeParameters": [],
                    "line": 171,
                    "description": "<p>Gets the start event for the given selection.\nReturns a MERGED event, if one exists\nOtherwise, returns CREATED</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 5145,
                                "end": 5152,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "getTemporal",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleTemporal",
                    "typeParameters": [],
                    "line": 98,
                    "description": "<p>Get the Existence temporal for the individual</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 3110,
                                "end": 3117,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "hashID",
                    "args": [
                        {
                            "name": "id",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 314,
                    "description": "<p>SDBM algorithm for generating a numeric value of a provided string</p>\n",
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 9543,
                                "end": 9545,
                                "flags": 0,
                                "escapedText": "id"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 9528,
                                "end": 9533,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9534,
                                "end": 9542,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9535,
                                    "end": 9541,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 9554,
                                "end": 9561,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "number"
                        }
                    ]
                },
                {
                    "name": "isUnion",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 213,
                    "description": "<p>Is this individual a part of a spatial union?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 6431,
                                "end": 6438,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "withoutHostname",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 81,
                    "description": "<p>Get the individual ID, without the URI base</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2653,
                                "end": 2660,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "withoutHostname",
                    "args": [
                        {
                            "name": "id",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 256,
                    "description": "<p>Filter ID string to remove hostname (authority)</p>\n",
                    "modifierKind": [
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 7740,
                                "end": 7742,
                                "flags": 0,
                                "escapedText": "id"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 7725,
                                "end": 7730,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 7731,
                                "end": 7739,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7732,
                                    "end": 7738,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 7751,
                                "end": 7758,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IInterfacable"
            ]
        },
        {
            "name": "TrestleRelation",
            "id": "class-TrestleRelation-f704aa8a4bbee67067723ca45bee3a1a",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-relation.ts",
            "type": "class",
            "sourceCode": "import { IInterfacable } from \"../../interfacable\";\n\nexport interface ITrestleRelation {\n    subject: string;\n    object: string;\n    relation: string;\n}\n\nexport type TrestleRelationType =\n    \"CONTAINS\"\n    | \"COVERS\"\n    | \"DISJOINT\"\n    | \"EQUALS\"\n    | \"INSIDE\"\n    | \"MEETS\"\n    | \"SPATIAL_OVERLAPS\"\n    | \"AFTER\"\n    | \"BEFORE\"\n    | \"BEGINS\"\n    | \"DURING\"\n    | \"ENDS\"\n    | \"TEMPORAL_OVERLAPS\"\n    | \"SPLIT_INTO\"\n    | \"SPLIT_FROM\"\n    | \"MERGED_INTO\"\n    | \"MERGED_FROM\"\n    | \"COMPONENT_WITH\";\n\n// export enum TrestleRelationType {\n//     // Spatial\n//     CONTAINS,\n//     COVERS,\n//     DISJOINT,\n//     EQUALS,\n//     INSIDE,\n//     MEETS,\n//     SPATIAL_OVERLAPS,\n//     // Temporal\n//     AFTER,\n//     BEFORE,\n//     BEGINS,\n//     DURING,\n//     ENDS,\n//     TEMPORAL_OVERLAPS,\n//     SPLIT_INTO,\n//     SPLIT_FROM,\n//     MERGED_INTO,\n//     MERGED_FROM\n// }\n\nexport class TrestleRelation implements IInterfacable<ITrestleRelation> {\n    private subject: string;\n    private object: string;\n    private type: TrestleRelationType;\n\n    constructor(relation: ITrestleRelation) {\n        this.subject = relation.subject;\n        this.object = relation.object;\n        this.type = (relation.relation as TrestleRelationType);\n    }\n\n    public getSubject(): string {\n        return this.subject;\n    }\n\n    public getObject(): string {\n        return this.object;\n    }\n\n    public getType(): TrestleRelationType {\n        return this.type;\n    }\n\n    /**\n     * Is this relation part of a SpatialUnion?\n     * @returns {boolean}\n     */\n    public isUnionType(): boolean {\n        return (this.type === \"SPLIT_INTO\") ||\n            (this.type === \"SPLIT_FROM\") ||\n            (this.type === \"MERGED_INTO\") ||\n            (this.type === \"MERGED_FROM\") ||\n            (this.type === \"COMPONENT_WITH\");\n    }\n\n    public asInterface(): ITrestleRelation {\n        return {\n            subject: this.getSubject(),\n            object: this.getObject(),\n            relation: this.getType()\n        };\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "relation",
                        "type": "ITrestleRelation"
                    }
                ],
                "line": 54,
                "jsdoctags": [
                    {
                        "name": "relation",
                        "type": "ITrestleRelation",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "object",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "subject",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "type",
                    "type": "TrestleRelationType",
                    "optional": false,
                    "description": "",
                    "line": 54,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "asInterface",
                    "args": [],
                    "optional": false,
                    "returnType": "ITrestleRelation",
                    "typeParameters": [],
                    "line": 86,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getObject",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 66,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getSubject",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 62,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getType",
                    "args": [],
                    "optional": false,
                    "returnType": "TrestleRelationType",
                    "typeParameters": [],
                    "line": 70,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "isUnionType",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 78,
                    "description": "<p>Is this relation part of a SpatialUnion?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1526,
                                "end": 1533,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IInterfacable"
            ]
        },
        {
            "name": "TrestleTemporal",
            "id": "class-TrestleTemporal-e4e58ce405c36ddd6b30dc18ac39be1d",
            "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-temporal.ts",
            "type": "class",
            "sourceCode": "import { IInterfacable } from \"../../interfacable\";\nimport moment from \"moment\";\n\nexport interface ITrestleTemporal {\n    ID: string;\n    From: Date;\n    To?: Date | string;\n}\n\nexport class TrestleTemporal implements IInterfacable<ITrestleTemporal> {\n    private id: string;\n    private from: moment.Moment;\n    private to?: moment.Moment;\n\n    constructor(temporal: ITrestleTemporal) {\n        this.id = temporal.ID;\n        this.from = moment(temporal.From, moment.ISO_8601);\n        // There's a problem with our serialization, which means these things might end up as strings, which is no good.\n        if (temporal.To !== null && temporal.To !== \"\") {\n            this.to = moment.utc(temporal.To, moment.ISO_8601);\n        }\n    }\n\n    public getID(): string {\n        return this.id;\n    }\n\n    public getFrom(): moment.Moment {\n        return this.from;\n    }\n\n    public getFromAsDate(): Date {\n        return this.from.toDate();\n    }\n\n    public getTo(): moment.Moment | undefined {\n        return this.to;\n    }\n\n    public getToAsDate(): Date | undefined {\n        if (this.to) {\n            return this.to.toDate();\n        }\n        return undefined;\n    }\n\n    public isContinuing(): boolean {\n        return this.to === undefined || !this.to.isValid();\n    }\n\n    /**\n     * Does the specified temporal fall within the interval of this TemporalObject?\n     * @param {moment.Moment} temporal\n     * @returns {boolean}\n     */\n    public isActive(temporal: moment.Moment): boolean {\n        if (this.to === undefined) {\n            return this.from.isSameOrBefore(temporal);\n        } else {\n            return this.from.isSameOrBefore(temporal) &&\n                this.to.isAfter(temporal);\n        }\n    }\n\n    public asInterface(): ITrestleTemporal {\n        const returnValue: ITrestleTemporal = {\n            ID: this.id,\n            From: this.from.toDate()\n        };\n        if (!this.isContinuing() && (this.to !== undefined)) {\n            returnValue.To = this.to.toDate();\n        }\n        return returnValue;\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "temporal",
                        "type": "ITrestleTemporal"
                    }
                ],
                "line": 13,
                "jsdoctags": [
                    {
                        "name": "temporal",
                        "type": "ITrestleTemporal",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "from",
                    "type": "moment.Moment",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "to",
                    "type": "moment.Moment",
                    "optional": true,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "asInterface",
                    "args": [],
                    "optional": false,
                    "returnType": "ITrestleTemporal",
                    "typeParameters": [],
                    "line": 65,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getFrom",
                    "args": [],
                    "optional": false,
                    "returnType": "moment.Moment",
                    "typeParameters": [],
                    "line": 28,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getFromAsDate",
                    "args": [],
                    "optional": false,
                    "returnType": "Date",
                    "typeParameters": [],
                    "line": 32,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getID",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 24,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getTo",
                    "args": [],
                    "optional": false,
                    "returnType": "moment.Moment | undefined",
                    "typeParameters": [],
                    "line": 36,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getToAsDate",
                    "args": [],
                    "optional": false,
                    "returnType": "Date | undefined",
                    "typeParameters": [],
                    "line": 40,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "isActive",
                    "args": [
                        {
                            "name": "temporal",
                            "type": "moment.Moment"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 56,
                    "description": "<p>Does the specified temporal fall within the interval of this TemporalObject?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1399,
                                "end": 1407,
                                "flags": 0,
                                "escapedText": "temporal"
                            },
                            "type": "moment.Moment",
                            "tagName": {
                                "pos": 1377,
                                "end": 1382,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1383,
                                "end": 1398,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1384,
                                    "end": 1397,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1384,
                                        "end": 1397,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 1384,
                                            "end": 1390,
                                            "flags": 2097152,
                                            "escapedText": "moment"
                                        },
                                        "right": {
                                            "pos": 1391,
                                            "end": 1397,
                                            "flags": 2097152,
                                            "escapedText": "Moment"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1416,
                                "end": 1423,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "isContinuing",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 47,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IInterfacable"
            ]
        },
        {
            "name": "TrestleToken",
            "id": "class-TrestleToken-d55204a2468f4b26ef24d320e0b84ac4",
            "file": "src/main/webapp/src/app/user/authentication.service.ts",
            "type": "class",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {Privileges, TrestleUser} from './trestle-user';\nimport {HttpClient} from '@angular/common/http';\nimport {JwtHelperService} from '@auth0/angular-jwt';\nimport {environment} from '../../environments/environment';\nimport {Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nconst _key: string = 'access_token';\n\nexport class TrestleToken {\n\n  private readonly exp: number;\n  private readonly iat: number;\n  private readonly user: ITrestleUser;\n\n  public constructor(token: any) {\n    this.exp = token['exp'];\n    this.iat = token['iat'];\n    this.user = JSON.parse(token['data4j']);\n  }\n\n  /**\n   * Get token expiration time (in ms from Unix epoch)\n   * @returns {number}\n   */\n  public getExpiration() {\n    return this.exp;\n  }\n\n  /**\n   * Get issuance time (in ms from Unix epoch)\n   * @returns {number}\n   */\n  public getIssue() {\n    return this.iat;\n  }\n\n  /**\n   * Get the user from the token\n   * @returns {ITrestleUser}\n   */\n  public getUser() {\n    return this.user;\n  }\n}\n\nexport interface ITrestleUser {\n  id?: number;\n  firstName: string;\n  lastName: string;\n  username: string;\n  email: string;\n  password: string;\n  privileges: number;\n}\n\n@Injectable()\nexport class AuthService {\n\n  private jwtHelper: JwtHelperService;\n  private readonly baseUrl;\n\n  constructor(private router: Router, private http: HttpClient) {\n    this.jwtHelper = new JwtHelperService();\n    this.baseUrl = environment.baseUrl;\n  }\n\n  /**\n   * Attempt to login the given use\n   * @param {string} username\n   * @param {string} password\n   */\n  public login(username: string, password: string): Observable<{ user: TrestleUser, token: string }> {\n    return this.http.post(this.baseUrl + '/auth/login', {username, password: password}, {\n      responseType: 'text'\n    })\n      .pipe(map(token => {\n        const t = this.getToken2(token);\n        return {user: new TrestleUser(t.getUser()), token}\n      }));\n  }\n\n  /**\n   * Logout the user\n   */\n  public logout(): Observable<string> {\n    console.debug(\"Logging out\");\n    return this.http.post(this.baseUrl + '/auth/logout', null, {\n      responseType: 'text'\n    });\n  }\n\n  /**\n   * Is the user currently logged in?\n   * @returns {boolean}\n   */\n  public loggedIn(): boolean {\n    const token = localStorage.getItem(_key);\n    if (token) {\n      console.debug(\n        this.jwtHelper.decodeToken(token),\n        this.jwtHelper.getTokenExpirationDate(token),\n        this.jwtHelper.isTokenExpired(token)\n      );\n    }\n    return !this.jwtHelper.isTokenExpired(token);\n  }\n\n  /**\n   * Does the user have AT LEAST Admin permissions?\n   * @returns {boolean}\n   */\n  public isAdmin(): boolean {\n    if (this.loggedIn()) {\n      const token = this.getToken();\n      // eslint-disable-next-line no-bitwise\n      return (token !== null) && ((token.getUser().privileges & Privileges.ADMIN) > 0);\n    }\n    return false;\n  }\n\n  /**\n   * Get the user, if one exists\n   * @returns {TrestleUser | null}\n   */\n  public getUser(): TrestleUser | null {\n    if (this.loggedIn()) {\n      const token = this.getToken();\n      if (token) {\n        return new TrestleUser(token.getUser());\n      }\n    }\n    console.error('User is not logged in');\n    return null;\n  }\n\n  /**\n   * Determines if the logged-in user has the necessary roles to perform a certain function\n   * @param roles - Array of required Privileges\n   * @returns {boolean} - has all the required roles\n   */\n  public hasRequiredRoles(roles: Privileges[]): boolean {\n    const user = this.getUser();\n    if (user == null) {\n      return false;\n    }\n\n    return user.hasRequiredPrivileges(roles);\n  }\n\n  public getEncodedToken(): string | null {\n    return localStorage.getItem(_key);\n  }\n\n  private getToken(): TrestleToken | null {\n    const jwtToken = this.getEncodedToken();\n    if (jwtToken) {\n      return new TrestleToken(this.jwtHelper.decodeToken(jwtToken));\n    }\n    return null;\n  }\n\n  private getToken2 = (jwtToken: string): TrestleToken => {\n    return new TrestleToken(this.jwtHelper.decodeToken(jwtToken));\n  };\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "token",
                        "type": "any"
                    }
                ],
                "line": 19,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "token",
                        "type": "any",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "exp",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "iat",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "user",
                    "type": "ITrestleUser",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getExpiration",
                    "args": [],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 31,
                    "description": "<p>Get token expiration time (in ms from Unix epoch)</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 794,
                                "end": 801,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "number"
                        }
                    ]
                },
                {
                    "name": "getIssue",
                    "args": [],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 39,
                    "description": "<p>Get issuance time (in ms from Unix epoch)</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 929,
                                "end": 936,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "number"
                        }
                    ]
                },
                {
                    "name": "getUser",
                    "args": [],
                    "optional": false,
                    "returnType": "ITrestleUser",
                    "typeParameters": [],
                    "line": 47,
                    "description": "<p>Get the user from the token</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1045,
                                "end": 1052,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "TrestleUser",
            "id": "class-TrestleUser-f0768bf4520876fb8a7356b35b18973c",
            "file": "src/main/webapp/src/app/user/trestle-user.ts",
            "type": "class",
            "sourceCode": "import {ITrestleUser} from './authentication.service';\n\nexport enum Privileges {\n  USER = 1,\n  ADMIN = 2,\n  DBA = 4\n}\n\nexport class TrestleUser {\n    private readonly _id: number | undefined;\n    private readonly _firstName: string;\n    private readonly _lastName: string;\n    private _username: string;\n    private readonly _email: string;\n    private readonly _password: string;\n    private readonly _privileges: number;\n\n    public constructor(userInterface: ITrestleUser) {\n        this._id = userInterface.id;\n        this._email = userInterface.email;\n        this._firstName = userInterface.firstName;\n        this._lastName = userInterface.lastName;\n        this._email = userInterface.email;\n        this._password = userInterface.password;\n        this._privileges = userInterface.privileges;\n    }\n\n\n    get id(): number | undefined {\n        return this._id;\n    }\n\n    get firstName(): string {\n        return this._firstName;\n    }\n\n    get lastName(): string {\n        return this._lastName;\n    }\n\n    get username(): string {\n        return this._username;\n    }\n\n    get email(): string {\n        return this._email;\n    }\n\n    get password(): string {\n        return this._password;\n    }\n\n    get privileges(): number {\n        return this._privileges;\n    }\n\n    /**\n     * Does the user have admin privileges?\n     * This will return true for any permission level equal to or higher than admin (e.g. dba)\n     * @returns {boolean} - Has admin or higher permissions?\n     */\n    public isAdmin(): boolean {\n        // eslint-disable-next-line no-bitwise\n        return (this._privileges & Privileges.ADMIN) > 0;\n    }\n\n    public hasRequiredPrivileges(roles: Privileges[]): boolean {\n        // eslint-disable-next-line no-bitwise\n        return (this._privileges & TrestleUser.buildRoleValue(roles)) > 0;\n    }\n\n    public serialize(): ITrestleUser {\n      return {\n        email: this._email,\n        firstName: this._firstName,\n        id: this._id,\n        lastName: this._lastName,\n        password: this._password,\n        privileges: this._privileges,\n        username: this._username\n      }\n    }\n\n    /**\n     * Convert an array of privileges into a single value\n     * @param {Privileges[]} roles\n     * @returns {number}\n     */\n    private static buildRoleValue(roles: Privileges[]): number {\n        let roleValue = 0;\n        roles.forEach((role) => {\n            // eslint-disable-next-line no-bitwise\n            roleValue = roleValue | role;\n        });\n        return roleValue;\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "userInterface",
                        "type": "ITrestleUser"
                    }
                ],
                "line": 16,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "userInterface",
                        "type": "ITrestleUser",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "_email",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "_firstName",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "_id",
                    "type": "number | undefined",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "_lastName",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "_password",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "_privileges",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "_username",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "buildRoleValue",
                    "args": [
                        {
                            "name": "roles",
                            "type": "Privileges[]"
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 89,
                    "description": "<p>Convert an array of privileges into a single value</p>\n",
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2223,
                                "end": 2228,
                                "flags": 0,
                                "escapedText": "roles"
                            },
                            "type": "Privileges[]",
                            "tagName": {
                                "pos": 2202,
                                "end": 2207,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2208,
                                "end": 2222,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2209,
                                    "end": 2221,
                                    "flags": 2097152,
                                    "kind": 166,
                                    "elementType": {
                                        "pos": 2209,
                                        "end": 2219,
                                        "flags": 2097152,
                                        "kind": 161,
                                        "typeName": {
                                            "pos": 2209,
                                            "end": 2219,
                                            "flags": 2097152,
                                            "escapedText": "Privileges"
                                        }
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2237,
                                "end": 2244,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "number"
                        }
                    ]
                },
                {
                    "name": "hasRequiredPrivileges",
                    "args": [
                        {
                            "name": "roles",
                            "type": "Privileges[]"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 67,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "roles",
                            "type": "Privileges[]",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isAdmin",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 62,
                    "description": "<p>Does the user have admin privileges?\nThis will return true for any permission level equal to or higher than admin (e.g. dba)</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1435,
                                "end": 1442,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>Has admin or higher permissions?</li>\n</ul>\n",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "serialize",
                    "args": [],
                    "optional": false,
                    "returnType": "ITrestleUser",
                    "typeParameters": [],
                    "line": 72,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "indexSignatures": [],
            "accessors": {
                "id": {
                    "name": "id",
                    "getSignature": {
                        "name": "id",
                        "type": "",
                        "returnType": "number | undefined",
                        "line": 29
                    }
                },
                "firstName": {
                    "name": "firstName",
                    "getSignature": {
                        "name": "firstName",
                        "type": "string",
                        "returnType": "string",
                        "line": 33
                    }
                },
                "lastName": {
                    "name": "lastName",
                    "getSignature": {
                        "name": "lastName",
                        "type": "string",
                        "returnType": "string",
                        "line": 37
                    }
                },
                "username": {
                    "name": "username",
                    "getSignature": {
                        "name": "username",
                        "type": "string",
                        "returnType": "string",
                        "line": 41
                    }
                },
                "email": {
                    "name": "email",
                    "getSignature": {
                        "name": "email",
                        "type": "string",
                        "returnType": "string",
                        "line": 45
                    }
                },
                "password": {
                    "name": "password",
                    "getSignature": {
                        "name": "password",
                        "type": "string",
                        "returnType": "string",
                        "line": 49
                    }
                },
                "privileges": {
                    "name": "privileges",
                    "getSignature": {
                        "name": "privileges",
                        "type": "number",
                        "returnType": "number",
                        "line": 53
                    }
                }
            },
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "UserDetailsModal",
            "id": "class-UserDetailsModal-8f405157dc9cae5d0d69669519868a86",
            "file": "src/test/e2e/page_objects/user.details.modal.ts",
            "type": "class",
            "sourceCode": "import { browser, by, element, ElementFinder } from \"protractor\";\n\nexport interface IUserTable {\n    username?: string,\n    password?: string,\n    first_name?: string,\n    last_name?: string,\n    email?: string;\n}\n\nexport type UserType = \"user\" | \"admin\" | \"dba\";\n\nexport class UserDetailsModal {\n\n    private userNameInput: ElementFinder;\n    private passwordInput: ElementFinder;\n    private firstNameInput: ElementFinder;\n    private lastNameInput: ElementFinder;\n    private emailInput: ElementFinder;\n\n    public constructor() {\n        this.userNameInput = element(by.css(\"input[formcontrolname='username']\"));\n        this.passwordInput = element(by.css(\"input[formcontrolname='password']\"));\n        this.firstNameInput = element(by.css(\"input[formcontrolname='firstName']\"));\n        this.lastNameInput = element(by.css(\"input[formcontrolname='lastName']\"));\n        this.emailInput = element(by.css(\"input[formcontrolname='email']\"));\n    }\n\n    /**\n     * Create a new user of the given type with the provided data\n     * Assumes the modal is already open, but closes it in order to submit the data\n     *\n     * @param {UserType} userType - user type to add\n     * @param {IUserTable} user - User data\n     * @returns {Promise<any>} - Returns when the modal closes (waits 500ms)\n     */\n    public async createUser(userType: UserType, user: IUserTable) {\n        // Wait for the modal to load\n        await browser.sleep(500);\n        await this.userNameInput.sendKeys(user.username || \"\");\n        await this.passwordInput.sendKeys(user.password || \"\");\n        await this.firstNameInput.sendKeys(user.first_name || \"\");\n        await this.lastNameInput.sendKeys(user.last_name || \"\");\n        await this.emailInput.sendKeys(user.email || \"\");\n\n        //    Now the permissions, select everything lower\n        switch (userType) {\n            case \"dba\": {\n                await UserDetailsModal.selectUserPermission(\"dba\");\n                await UserDetailsModal.selectUserPermission(\"admin\");\n                break;\n            }\n            case \"admin\": {\n                await UserDetailsModal.selectUserPermission(\"admin\");\n                break;\n            }\n            case \"user\": {\n                break;\n            }\n        }\n        return Promise.resolve(undefined);\n    }\n\n    /**\n     * Update the given properties of the user\n     * Assumes the modal is already open, but closes it in order to submit the changes\n     *\n     * @param {IUserTable} user - User data to update\n     * @returns {Promise<any>} - returns when the modal is closed (waits 500ms)\n     */\n    public async editUser(user: IUserTable) {\n        // Wait for the modal to load\n        await browser.sleep(500);\n        // We have to clear the input fields before\n        if (user.username) {\n            await this.userNameInput.clear();\n            await this.userNameInput.sendKeys(user.username);\n        }\n\n        if (user.email) {\n            await this.emailInput.clear();\n            await this.emailInput.sendKeys(user.email);\n        }\n\n        if (user.password) {\n            await this.passwordInput.clear();\n            await this.passwordInput.sendKeys(user.password);\n        }\n\n        if (user.first_name) {\n            await this.firstNameInput.clear();\n            await this.firstNameInput.sendKeys(user.first_name);\n        }\n\n        if (user.last_name) {\n            await this.lastNameInput.clear();\n            await this.lastNameInput.sendKeys(user.last_name);\n        }\n\n        element(by.buttonText(\"Update User\")).click();\n        // Sleep for 500 ms to let the modal close\n        return browser.sleep(500);\n    }\n\n    /**\n     * Delete the given user\n     * Assumes the modal is already open, but closes it in order to submit the changes\n     *\n     * @returns {any} - Returns when the modal closes\n     */\n    public async deleteUser() {\n        // Wait for the modal to load\n        await browser.sleep(500);\n        return element(by.buttonText(\"Delete User\")).click();\n    }\n\n    public async submit() {\n        await element(by.buttonText(\"Add User\")).click();\n        // Sleep for 500 ms to let the modal close\n        return browser.sleep(500);\n    }\n\n    public async dismiss() {\n        await element(by.buttonText(\"Cancel\")).click();\n        return browser.sleep(500);\n    }\n\n    /**\n     * Selects the mat-button-toggle that corresponds to the given permission.\n     * Automatically uppercases the input\n     *\n     * @param {string} permission\n     * @returns {Promise<any>}\n     */\n    private static async selectUserPermission(permission: string) {\n        // We need to use contains, because the Text can have trailing whitespace\n        const xpathString = \"//mat-button-toggle[.//div[contains(text(), '\" + permission.toUpperCase() + \"')]]\";\n        return element(by.xpath(xpathString)).click();\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 19,
                "modifierKind": [
                    114
                ]
            },
            "properties": [
                {
                    "name": "emailInput",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "firstNameInput",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "lastNameInput",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "passwordInput",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "userNameInput",
                    "type": "ElementFinder",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "createUser",
                    "args": [
                        {
                            "name": "userType",
                            "type": "UserType"
                        },
                        {
                            "name": "user",
                            "type": "IUserTable"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 37,
                    "description": "<p>Create a new user of the given type with the provided data\nAssumes the modal is already open, but closes it in order to submit the data</p>\n",
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1142,
                                "end": 1150,
                                "flags": 0,
                                "escapedText": "userType"
                            },
                            "type": "UserType",
                            "tagName": {
                                "pos": 1125,
                                "end": 1130,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>user type to add</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1131,
                                "end": 1141,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1132,
                                    "end": 1140,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1132,
                                        "end": 1140,
                                        "flags": 2097152,
                                        "escapedText": "UserType"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1197,
                                "end": 1201,
                                "flags": 0,
                                "escapedText": "user"
                            },
                            "type": "IUserTable",
                            "tagName": {
                                "pos": 1178,
                                "end": 1183,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>User data</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 1184,
                                "end": 1196,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1185,
                                    "end": 1195,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1185,
                                        "end": 1195,
                                        "flags": 2097152,
                                        "escapedText": "IUserTable"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1222,
                                "end": 1229,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>Returns when the modal closes (waits 500ms)</li>\n</ul>\n",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "deleteUser",
                    "args": [],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 111,
                    "description": "<p>Delete the given user\nAssumes the modal is already open, but closes it in order to submit the changes</p>\n",
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 3789,
                                "end": 3796,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>Returns when the modal closes</li>\n</ul>\n",
                            "returnType": "any"
                        }
                    ]
                },
                {
                    "name": "dismiss",
                    "args": [],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 123,
                    "modifierKind": [
                        114,
                        120
                    ]
                },
                {
                    "name": "editUser",
                    "args": [
                        {
                            "name": "user",
                            "type": "IUserTable"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 71,
                    "description": "<p>Update the given properties of the user\nAssumes the modal is already open, but closes it in order to submit the changes</p>\n",
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2481,
                                "end": 2485,
                                "flags": 0,
                                "escapedText": "user"
                            },
                            "type": "IUserTable",
                            "tagName": {
                                "pos": 2462,
                                "end": 2467,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>User data to update</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 2468,
                                "end": 2480,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2469,
                                    "end": 2479,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2469,
                                        "end": 2479,
                                        "flags": 2097152,
                                        "escapedText": "IUserTable"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2516,
                                "end": 2523,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<ul>\n<li>returns when the modal is closed (waits 500ms)</li>\n</ul>\n",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "selectUserPermission",
                    "args": [
                        {
                            "name": "permission",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 135,
                    "description": "<p>Selects the mat-button-toggle that corresponds to the given permission.\nAutomatically uppercases the input</p>\n",
                    "modifierKind": [
                        112,
                        115,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 4481,
                                "end": 4491,
                                "flags": 0,
                                "escapedText": "permission"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 4466,
                                "end": 4471,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 4472,
                                "end": 4480,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 4473,
                                    "end": 4479,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 4500,
                                "end": 4507,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "submit",
                    "args": [],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 117,
                    "modifierKind": [
                        114,
                        120
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "UsersPage",
            "id": "class-UsersPage-d2534d01b39ead35e0354f363aede1dd",
            "file": "src/test/e2e/page_objects/users.page.ts",
            "type": "class",
            "sourceCode": "import {browser, by, element} from 'protractor';\nimport {IUserTable, UserDetailsModal, UserType} from './user.details.modal';\n\nexport class UsersPage {\n\n  private userModal = new UserDetailsModal();\n\n  public async fillUserForm(userType: UserType, user: IUserTable) {\n    //    Click the button\n    await element(by.id('add-user')).click();\n    return this.userModal.createUser(userType, user);\n  }\n\n  public async editUser(username: string, userData: IUserTable) {\n    await UsersPage.selectUserRow(username);\n    return this.userModal.editUser(userData);\n  }\n\n  public async countUsers(): Promise<number> {\n    await browser.sleep(1000);\n    return element(by.id('users-table'))\n      .all(by.css('tbody tr')).count();\n  }\n\n  public async deleteUser(username: string) {\n    await UsersPage.selectUserRow(username);\n    return this.userModal.deleteUser();\n  }\n\n  public async submitModal() {\n    return this.userModal.submit();\n  }\n\n  public dismissModal() {\n    return this.userModal.dismiss();\n  }\n\n  public async getFieldMessage(field: string) {\n    await browser.sleep(500);\n    const xpathString = '//form//mat-form-field[.//input[@formcontrolname=\\'' + field + '\\']]//mat-error';\n    const matField = element(by.xpath(xpathString));\n    return matField.getText();\n  }\n\n  private static async selectUserRow(username: string) {\n    const xpathString = '//table[@id=\\'users-table\\']/tbody/tr[td//text()[contains(.,\\''\n      + username\n      + '\\')]]';\n    const rowElement = element(by.xpath(xpathString));\n    // We need to use the JS click method, otherwise Firefox complains it can't scroll to the table row\n    await browser.executeScript('arguments[0].click()', rowElement);\n    // Wait 500ms for the modal to open\n    return browser.sleep(500);\n  }\n}\n",
            "properties": [
                {
                    "name": "userModal",
                    "defaultValue": "new UserDetailsModal()",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 6,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methods": [
                {
                    "name": "countUsers",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<number>",
                    "typeParameters": [],
                    "line": 19,
                    "modifierKind": [
                        114,
                        120
                    ]
                },
                {
                    "name": "deleteUser",
                    "args": [
                        {
                            "name": "username",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 25,
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "username",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "dismissModal",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 34,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "editUser",
                    "args": [
                        {
                            "name": "username",
                            "type": "string"
                        },
                        {
                            "name": "userData",
                            "type": "IUserTable"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 14,
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "username",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "userData",
                            "type": "IUserTable",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "fillUserForm",
                    "args": [
                        {
                            "name": "userType",
                            "type": "UserType"
                        },
                        {
                            "name": "user",
                            "type": "IUserTable"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 8,
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "userType",
                            "type": "UserType",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "user",
                            "type": "IUserTable",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFieldMessage",
                    "args": [
                        {
                            "name": "field",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 38,
                    "modifierKind": [
                        114,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "selectUserRow",
                    "args": [
                        {
                            "name": "username",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 45,
                    "modifierKind": [
                        112,
                        115,
                        120
                    ],
                    "jsdoctags": [
                        {
                            "name": "username",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "submitModal",
                    "args": [],
                    "optional": false,
                    "returnType": "{}",
                    "typeParameters": [],
                    "line": 30,
                    "modifierKind": [
                        114,
                        120
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "Worker",
            "id": "class-Worker-21b94b5333b98624b1c3da41f95b7111",
            "file": "jest/jest.stubs.ts",
            "type": "class",
            "sourceCode": "if (typeof window.URL.createObjectURL === 'undefined') {\n  window.URL.createObjectURL = (): string => {\n    // Do nothing\n    // Mock this function for mapbox-gl to work\n    return \"\";\n  };\n}\n\nif (window.document) {\n  window.document.createRange = () => ({\n    setStart: () => {\n    },\n    setEnd: () => {\n    },\n    // @ts-ignore\n    commonAncestorContainer: {\n      nodeName: 'BODY',\n      ownerDocument: document,\n    },\n    // @ts-ignore\n    getBoundingClientRect: () => {\n\n    }\n  });\n}\n\n// @ts-ignore\nwindow.getComputedStyle = () => ({\n  getPropertyValue: () => {\n    return \"\";\n  }\n});\n\n\n// @ts-ignore\nclass Worker {\n\n  private readonly url;\n  private readonly onmessage: () => void;\n  constructor(stringUrl) {\n    this.url = stringUrl;\n    this.onmessage = () => {};\n  }\n\n  postMessage(_msg) {\n    this.onmessage();\n  }\n}window.Worker = Worker;\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "stringUrl",
                        "type": ""
                    }
                ],
                "line": 39,
                "jsdoctags": [
                    {
                        "name": "stringUrl",
                        "type": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "onmessage",
                    "type": "function",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "url",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 38,
                    "modifierKind": [
                        112,
                        132
                    ]
                }
            ],
            "methods": [
                {
                    "name": "postMessage",
                    "args": [
                        {
                            "name": "_msg",
                            "type": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 45,
                    "jsdoctags": [
                        {
                            "name": "_msg",
                            "type": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        }
    ],
    "directives": [],
    "components": [
        {
            "name": "AdminComponent",
            "id": "component-AdminComponent-a1ecb027a759dc0793b13a9461c01d7f",
            "file": "src/main/webapp/src/app/admin/admin/admin.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "admin-root",
            "styleUrls": [
                "./admin.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./admin.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "gravatarURL",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "sideNavOpen",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "userLoggedIn",
                    "defaultValue": "new BehaviorSubject<boolean>(false)",
                    "type": "Subject<boolean>",
                    "optional": false,
                    "description": "",
                    "line": 19
                }
            ],
            "methodsClass": [
                {
                    "name": "getGravatarURL",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 42,
                    "description": "<p>Get the Gravitar URL for the logged in user</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1127,
                                "end": 1134,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "login",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 32,
                    "description": "<p>If the user is not logged in, send them to the login page</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "logout",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 57,
                    "description": "<p>Logout the user</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 23
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from \"@angular/core\";\nimport {Router} from \"@angular/router\";\nimport * as CryptoJS from \"crypto-js\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {AuthService} from '../../user/authentication.service';\n\n@Component({\n    selector: \"admin-root\",\n    templateUrl: \"./admin.component.html\",\n    styleUrls: [\"./admin.component.scss\"],\n})\n\nexport class AdminComponent implements OnInit {\n\n    public sideNavOpen: boolean;\n    userLoggedIn: Subject<boolean> = new BehaviorSubject<boolean>(false);\n    private gravatarURL: string;\n    constructor(private authService: AuthService, private router: Router) {}\n\n    ngOnInit(): void {\n        this.sideNavOpen = true;\n        console.debug(\"Init check for logged in\");\n        this.userLoggedIn.next(this.authService.loggedIn());\n    }\n\n    /**\n     * If the user is not logged in, send them to the login page\n     */\n    public login(): void {\n        if (!this.userLoggedIn) {\n            this.router.navigate([\"/login\"]);\n        }\n    }\n\n    /**\n     * Get the Gravitar URL for the logged in user\n     * @returns {string}\n     */\n    public getGravatarURL(): string {\n        if (this.gravatarURL == null) {\n            let user = this.authService.getUser();\n            if (user != null) {\n                let hash = CryptoJS.MD5(user.email.trim().toLowerCase()).toString();\n                this.gravatarURL = \"https://www.gravatar.com/avatar/\" + hash + \"?d=identicon\" + \"&s=50\";\n                return this.gravatarURL;\n            }\n        }\n        return this.gravatarURL;\n    }\n\n    /**\n     * Logout the user\n     */\n    public logout(): void {\n        this.authService.logout();\n        this.userLoggedIn.next(false);\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".app-content {\n  padding: 20px;\n  height: 100%;\n}\n\n.toolbar-spacer {\n  flex: 1 1 auto;\n}\n\n.top-layout {\n  height: 50px;\n}\n\n.img-circle {\n  height: 50px;\n  border-radius: 50%;\n  margin: 0 10px;\n}\n",
                    "styleUrl": "./admin.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "authService",
                        "type": "AuthService"
                    },
                    {
                        "name": "router",
                        "type": "Router"
                    }
                ],
                "line": 20,
                "jsdoctags": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<!--<md-sidenav-container>-->\n    <!--<md-sidenav #sidenav mode=\"side\" color=\"accent\">-->\n        <!--<button md-raised-button class=\"top-layout\">TRESTLE</button>-->\n    <!--</md-sidenav>-->\n    <!--<md-toolbar color=\"primary\" class=\"top-layout z-depth-2\">-->\n        <!--<button md-button hide-gt-sm>-->\n        <!--&lt;!&ndash;<button md-button hide-gt-sm (click)=\"sidenav.toggle()\">&ndash;&gt;-->\n            <!--<i class=\"material-icons app-toolbar-menu\">menu</i>-->\n        <!--</button>-->\n        <!--<span class=\"toolbar-spacer\"></span>-->\n        <!--<a md-button routerLink=\"/dashboard\" aria-label=\"dashboard link\">DASHBOARD</a>-->\n        <!--<div *ngIf=\"userLoggedIn | async\">-->\n            <!--<a md-button routerLink=\"/metrics\" aria-label=\"metrics link\">METRICS</a>-->\n            <!--<a md-button routerLink=\"/visualize\" aria-label=\"visualizer link\">VISUALIZER</a>-->\n            <!--<a md-button routerLink=\"/query\" aria-label=\"query link\">QUERY</a>-->\n            <!--<a md-button routerLink=\"/users\" aria-label=\"users link\">USERS</a>-->\n            <!--<button md-button class=\"toolbar-button\" (click)=\"logout()\" aria-label=\"Logout\">-->\n                <!--<i class=\"material-icons\">system_update_alt</i>-->\n            <!--</button>-->\n        <!--</div>-->\n        <!--<img class=\"img-circle\" *ngIf=\"userLoggedIn | async\" [src]=\"getGravatarURL()\">-->\n        <!--<button md-button class=\"toolbar-button\" *ngIf=\"!(userLoggedIn | async)\" routerLink=\"/login\" aria-label=\"Login\">-->\n            <!--<i class=\"material-icons\">input</i>-->\n        <!--</button>-->\n        <!--<button md-button class=\"toolbar-button\" aria-label=\"Settings\">-->\n            <!--<i class=\"material-icons\">menu</i>-->\n        <!--</button>-->\n    <!--</md-toolbar>-->\n    <!--<div class=\"app-content\">-->\n        <!--<router-outlet></router-outlet>-->\n    <!--</div>-->\n<!--</md-sidenav-container>-->\nI'm the admin"
        },
        {
            "name": "AggregateComponent",
            "id": "component-AggregateComponent-5a7459e2e4afda5f02137a293e5ceabe",
            "file": "src/main/webapp/src/app/explore/aggregate/aggregate.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "aggregate",
            "styleUrls": [
                "./aggregate.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./aggregate.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "aggregationFields",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "aggregationForm",
                    "type": "FormGroup",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "availableAggregations",
                    "defaultValue": "[\n    {name: 'Equals', value: 'EQ'},\n    {name: 'Not Equals', value: 'NEQ'},\n    {name: 'Greater than', value: 'GT'},\n    {name: 'Greater than or equal to', value: 'GTEQ'},\n    {name: 'Less than', value: 'LT'},\n    {name: 'Less than or equal to', value: 'LTEQ'}\n  ]",
                    "type": "literal type[]",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "dataChanges",
                    "type": "ReplaySubject<MapSource>",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "datasets",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "inProgress",
                    "defaultValue": "false",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "map",
                    "type": "TrestleMapComponent",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'map'"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mapConfig",
                    "type": "mapboxgl.MapboxOptions",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "properties",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "restrictionValueHidden",
                    "defaultValue": "true",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 40,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedAggregation",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedDs",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedProperty",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedValue",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "values",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "aggregate",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 128,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getFormControl",
                    "args": [
                        {
                            "name": "group",
                            "type": "\"restriction\" | \"strategy\""
                        },
                        {
                            "name": "control",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "AbstractControl",
                    "typeParameters": [],
                    "line": 175,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "group",
                            "type": "\"restriction\" | \"strategy\"",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "control",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFormValue",
                    "args": [
                        {
                            "name": "group",
                            "type": "\"restriction\" | \"strategy\""
                        },
                        {
                            "name": "control",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 171,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "group",
                            "type": "\"restriction\" | \"strategy\"",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "control",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 59,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "restrictionValidation",
                    "args": [
                        {
                            "name": "f",
                            "type": "FormGroup"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 183,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "f",
                            "type": "FormGroup",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, OnInit, ViewChild} from '@angular/core';\nimport {MapService} from '../viewer/map.service';\nimport {AggregationOperation, AggregationService, BBOX_PROPERTY} from './aggregation.service';\nimport {stringify, GeoJSONGeometry} from 'wellknown';\nimport {AbstractControl, FormBuilder, FormGroup, Validators} from '@angular/forms';\nimport {debounceTime, filter, switchMap, tap} from 'rxjs/operators';\nimport {MapSource, TrestleMapComponent} from '../../ui/trestle-map/trestle-map.component';\nimport {ReplaySubject} from 'rxjs';\nimport {DatasetService} from '../../shared/dataset/dataset.service';\n\n@Component({\n  selector: 'aggregate',\n  templateUrl: './aggregate.component.html',\n  styleUrls: ['./aggregate.component.scss']\n})\nexport class AggregateComponent implements OnInit {\n\n  @ViewChild('map')\n  public map: TrestleMapComponent;\n  public aggregationForm: FormGroup;\n  public selectedAggregation: string;\n  public datasets: string[];\n  public properties: string[];\n  public values: string[];\n  public aggregationFields: string[];\n  public selectedDs: string;\n  public selectedProperty: string;\n  public selectedValue: string;\n  public mapConfig: mapboxgl.MapboxOptions;\n  public dataChanges: ReplaySubject<MapSource>;\n  public availableAggregations: { name: string, value: AggregationOperation }[] = [\n    {name: 'Equals', value: 'EQ'},\n    {name: 'Not Equals', value: 'NEQ'},\n    {name: 'Greater than', value: 'GT'},\n    {name: 'Greater than or equal to', value: 'GTEQ'},\n    {name: 'Less than', value: 'LT'},\n    {name: 'Less than or equal to', value: 'LTEQ'}\n  ];\n  public inProgress = false;\n  public restrictionValueHidden = true;\n\n  public constructor(private ms: MapService,\n                     private as: AggregationService,\n                     private ds: DatasetService,\n                     private formBuilder: FormBuilder) {\n    this.datasets = [];\n    this.properties = [];\n    this.values = [];\n\n    this.mapConfig = {\n      style: 'mapbox://styles/nrobison/cj3n7if3q000s2sutls5a1ny7',\n      center: [32.3558991, -25.6854313],\n      zoom: 1,\n      container: 'map'\n    };\n    this.dataChanges = new ReplaySubject<MapSource>(50);\n  }\n\n  public ngOnInit(): void {\n    this.ds\n      .getAvailableDatasets()\n      .subscribe((ds) => {\n        this.datasets = ds;\n      });\n\n    const restrictionGroup = this.formBuilder.group({\n      dataset: ['', Validators.required],\n      property: '',\n      value: undefined,\n      validator: AggregateComponent.restrictionValidation\n    });\n\n    const strategyGroup = this.formBuilder.group({\n      field: ['', Validators.required],\n      operation: ['', Validators.required],\n      value: [undefined, Validators.required]\n    });\n\n    this.aggregationForm = this.formBuilder.group({\n      restriction: restrictionGroup,\n      strategy: strategyGroup\n    });\n\n    // Monitor Restriction dataset changes\n    this.getFormControl('restriction', 'dataset')\n      .valueChanges\n      .pipe(\n        debounceTime(400),\n        // Reset form values\n        tap(() => this.getFormControl('restriction', 'value').reset()),\n        // Fetch dataset properties\n        tap((value) => this.getFormControl('restriction', 'dataset').setValue(value)),\n        switchMap((value) => this.ds.getDatasetProperties(value))\n      )\n      .subscribe((values) => {\n        this.properties = [BBOX_PROPERTY].concat(values);\n        this.aggregationFields = ['EXISTENCE'].concat(values);\n      });\n\n    // Monitor Restriction property changes\n    this.getFormControl('restriction', 'property')\n      .valueChanges\n      .pipe(\n        debounceTime(400),\n        // Hide value selection if BBOX\n        tap((value) => {\n          // If bounding box, hide the value, but give it a dummy value\n          const valueControl = this.getFormControl('restriction', 'property');\n          if (!value || value === BBOX_PROPERTY) {\n            this.restrictionValueHidden = true;\n            valueControl.setValue('wktValue');\n          } else {\n            valueControl.reset();\n            this.restrictionValueHidden = false;\n          }\n          this.getFormControl('restriction', 'property').setValue(value);\n        }),\n        // Filter out BBOX and empty values\n        filter((value) => value && value !== BBOX_PROPERTY),\n        // Fetch Property values\n        switchMap((value) => this.ds\n          .getDatasetFactValues(this.getFormValue('restriction', 'dataset'), value)))\n      .subscribe((propertyValues) => {\n        this.values = propertyValues;\n      });\n  }\n\n  public aggregate(): void {\n    console.debug('Aggregate values:', this.aggregationForm.value);\n\n    // Reset the map\n    this.map.removeIndividual('aggregation-query');\n    // Special casing of WKT\n    if (this.getFormValue('restriction', 'property') === BBOX_PROPERTY) {\n      this.getFormControl('restriction', 'property').setValue('asWKT');\n      this.getFormControl('restriction', 'value').setValue(stringify(MapService.normalizeToGeoJSON(this.map.getMapBounds()) as GeoJSONGeometry));\n    }\n\n    // Special casing of ExistsFrom\n    if (this.getFormValue('strategy', 'field') === 'EXISTENCE') {\n      this.getFormControl('strategy', 'field').setValue('trestle:existsFrom');\n    }\n    this.inProgress = true;\n    this.as.performAggregation(this.aggregationForm.value)\n      .subscribe((agg) => {\n        console.debug('Done', agg);\n        this.dataChanges.next({\n          id: 'aggregation-query',\n          idField: 'id',\n          data: {\n            type: 'Feature',\n            geometry: agg,\n            properties: null,\n            id: 'test'\n          }\n        });\n        this.inProgress = false;\n      });\n    //    Reset from the special casing\n    if (this.getFormValue('restriction', 'property') === 'asWKT') {\n      this.getFormControl('restriction', 'property').setValue(BBOX_PROPERTY);\n      this.getFormControl('restriction', 'value').setValue(undefined);\n    }\n\n    if (this.getFormValue('strategy', 'field') === 'trestle:existsFrom') {\n      this.getFormControl('strategy', 'field').setValue('EXISTENCE');\n    }\n\n  }\n\n  private getFormValue(group: 'restriction' | 'strategy', control: string): any {\n    return this.getFormControl(group, control).value;\n  }\n\n  private getFormControl(group: 'restriction' | 'strategy', control: string): AbstractControl {\n    const fControl = this.aggregationForm.get([group, control]);\n    if (fControl) {\n      return fControl;\n    }\n    throw new Error('Cannot get control');\n  }\n\n  private static restrictionValidation(f: FormGroup): void {\n    const propertyControl = f.controls['property'];\n    const valueControl = f.controls['value'];\n    const value = valueControl.value;\n    if (propertyControl.value === BBOX_PROPERTY) {\n      valueControl.setErrors(null);\n    } else if (value === '') {\n      valueControl.setErrors({\n        minimumLength: true\n      });\n    } else if (value === undefined) {\n      valueControl.setErrors({\n        required: true\n      });\n    } else {\n      valueControl.setErrors(null);\n    }\n  };\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".map-container {\n  height: 700px;\n}\n\n.aggregate-container {\n  margin-bottom: 50px;\n  margin-right: 20px;\n  margin-left: 5px;\n}\n\n::ng-deep .mat-input-underline {\n  display: none;\n}\n::ng-deep .mat-form-field-underline {\n  display: none;\n}\n\n",
                    "styleUrl": "./aggregate.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "ms",
                        "type": "MapService"
                    },
                    {
                        "name": "as",
                        "type": "AggregationService"
                    },
                    {
                        "name": "ds",
                        "type": "DatasetService"
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder"
                    }
                ],
                "line": 40,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "ms",
                        "type": "MapService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "as",
                        "type": "AggregationService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "ds",
                        "type": "DatasetService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<div fxLayout=\"column\" fxLayoutGap=\"50px\">\n    <div class=\"map-container\">\n        <trestle-map #map [single]=\"false\"\n                     [multiSelect]=\"true\"\n                     [zoomOnLoad]=\"true\"\n                     [config]=\"mapConfig\"\n                     [dataChanges]=\"dataChanges\"\n                     class=\"map-container\"></trestle-map>\n    </div>\n    <form fxLayout=\"column\" fxLayoutGap=\"20px\" class=\"aggregate-container\" [formGroup]=\"aggregationForm\">\n        <h4>Aggregation Restriction</h4>\n        <div fxLayout=\"row\" formGroupName=\"restriction\">\n            <div fxFlex=\"33%\">\n                <mat-select matInput\n                            placeholder=\"Select available dataset\"\n                            formControlName=\"dataset\">\n                    <mat-option *ngFor=\"let ds of datasets\" [value]=\"ds\">\n                        {{ds}}\n                    </mat-option>\n                </mat-select>\n            </div>\n            <div fxFlex=\"33%\">\n                <mat-select matInput\n                            placeholder=\"Select data property\"\n                            formControlName=\"property\">\n                    <mat-option *ngFor=\"let property of properties\" [value]=\"property\">\n                        {{property}}\n                    </mat-option>\n                </mat-select>\n            </div>\n            <div [hidden]=\"restrictionValueHidden\" fxFlex=\"33%\">\n                <mat-select\n                        matInput\n                        placeholder=\"Select value\"\n                        formControlName=\"value\">\n                    <mat-option *ngFor=\"let pv of values | ArraySort\" [value]=\"pv\">\n                        {{pv}}\n                    </mat-option>\n                </mat-select>\n            </div>\n        </div>\n        <h4>Aggregation Strategy</h4>\n        <div fxLayout=\"row\" fxLayoutAlign=\"start\" formGroupName=\"strategy\">\n            <div fxFlex=\"30%\">\n                <mat-select [(value)]=\"selectedAggregation\" placeholder=\"Select an aggregation field\"\n                            formControlName=\"field\">\n                    <mat-option *ngFor=\"let aggregation of aggregationFields\" [value]=\"aggregation\">\n                        {{aggregation}}\n                    </mat-option>\n                </mat-select>\n            </div>\n            <div fxFlex=\"30%\">\n                <mat-select placeholder=\"Select an aggregation operation\"\n                            formControlName=\"operation\">\n                    <mat-option *ngFor=\"let op of availableAggregations\" [value]=\"op.value\">\n                        {{op.name}}\n                    </mat-option>\n                </mat-select>\n            </div>\n            <div fxFlex=\"40%\">\n                <mat-form-field>\n                    <input matInput formControlName=\"value\" placeholder=\"Set value\">\n                </mat-form-field>\n            </div>\n            <div>\n                <button mat-raised-button type=\"submit\" color=\"primary\"\n                        [disabled]=\"!aggregationForm.valid\"\n                        (click)=\"aggregate()\">\n                    AGGREGATE\n                </button>\n            </div>\n        </div>\n        <div [hidden]=\"!inProgress\">\n            Aggregating....\n        </div>\n    </form>\n</div>\n"
        },
        {
            "name": "AppComponent",
            "id": "component-AppComponent-5f11d03043f45355b4d89a664212701e",
            "file": "src/main/webapp/src/app/app.component.ts",
            "encapsulation": [
                "ViewEncapsulation.None"
            ],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-root",
            "styleUrls": [
                "./app.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./app.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "gravatarURL",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mobileQuery",
                    "type": "MediaQueryList",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mobileQueryListener",
                    "type": "function",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "Privileges",
                    "defaultValue": "Privileges",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "user",
                    "type": "Observable<TrestleUser>",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 47,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 42,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {ChangeDetectorRef, Component, OnDestroy, OnInit, ViewEncapsulation} from '@angular/core';\nimport {Privileges, TrestleUser} from './user/trestle-user';\nimport {AuthService} from './user/authentication.service';\nimport {Router} from '@angular/router';\nimport {MediaMatcher} from '@angular/cdk/layout';\nimport {select, Store} from '@ngrx/store';\nimport {selectUserFromUser, State} from './reducers';\nimport {Observable} from 'rxjs';\nimport {tap} from 'rxjs/operators';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss'],\n  encapsulation: ViewEncapsulation.None\n})\nexport class AppComponent implements OnInit, OnDestroy {\n\n  public gravatarURL: string;\n  // We need this in order to access the Privileges enum from the template\n  public Privileges = Privileges;\n  public user: Observable<TrestleUser>;\n\n  public mobileQuery: MediaQueryList;\n  private readonly mobileQueryListener: () => void;\n\n  constructor(private authService: AuthService,\n              private router: Router,\n              private store: Store<State>,\n              changeDetectorRef: ChangeDetectorRef,\n              media: MediaMatcher\n  ) {\n    this.mobileQuery = media.matchMedia('(max-width: 800px)');\n    this.mobileQueryListener = () => changeDetectorRef.detectChanges();\n    this.mobileQuery.addEventListener('change', this.mobileQueryListener);\n  }\n\n\n  public ngOnInit(): void {\n    // Get the current user, if it exists\n    this.user = this.store.pipe(select(selectUserFromUser), tap(user => console.log('User: ', user)));\n  }\n\n  public ngOnDestroy(): void {\n    this.mobileQuery.removeEventListener('change', this.mobileQueryListener);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "html {\n  height: 100%;\n}\n.app-content {\n  min-height: 100vh;\n}\n",
                    "styleUrl": "./app.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "authService",
                        "type": "AuthService"
                    },
                    {
                        "name": "router",
                        "type": "Router"
                    },
                    {
                        "name": "store",
                        "type": "Store<State>"
                    },
                    {
                        "name": "changeDetectorRef",
                        "type": "ChangeDetectorRef"
                    },
                    {
                        "name": "media",
                        "type": "MediaMatcher"
                    }
                ],
                "line": 28,
                "jsdoctags": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "store",
                        "type": "Store<State>",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "changeDetectorRef",
                        "type": "ChangeDetectorRef",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "media",
                        "type": "MediaMatcher",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "OnDestroy"
            ],
            "templateData": "<top-nav (headerClicked)=\"sidenav.toggle()\"></top-nav>\n<mat-sidenav-container>\n  <app-sidebar #sidenav></app-sidebar>\n  <div class=\"app-content\">\n    <router-outlet></router-outlet>\n  </div>\n</mat-sidenav-container>\n"
        },
        {
            "name": "ButtonComponent",
            "id": "component-ButtonComponent-642c6c4e474cd5a0ac760dfda26b2fc9",
            "file": "src/stories/button.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "storybook-button",
            "styleUrls": [
                "./button.css"
            ],
            "styles": [],
            "template": "<button   type=\"button\"\n   (click)=\"onClick.emit($event)\"\n   [ngClass]=\"classes\"\n   [ngStyle]=\"{ 'background-color': backgroundColor }\"\n >\n   {{ label }}\n </button>",
            "templateUrl": [],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "backgroundColor",
                    "description": "<p>What background color to use</p>\n",
                    "line": 26,
                    "type": "string"
                },
                {
                    "name": "label",
                    "defaultValue": "'Button'",
                    "description": "<p>Button contents</p>\n",
                    "line": 40
                },
                {
                    "name": "primary",
                    "defaultValue": "false",
                    "description": "<p>Is this the principal call to action on the page?</p>\n",
                    "line": 20
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "description": "<p>How large should the button be?</p>\n",
                    "line": 32,
                    "type": "\"small\" | \"medium\" | \"large\""
                }
            ],
            "outputsClass": [
                {
                    "name": "onClick",
                    "defaultValue": "new EventEmitter<Event>()",
                    "description": "<p>Optional click handler</p>\n",
                    "line": 46,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'storybook-button',\n  template: ` <button\n    type=\"button\"\n    (click)=\"onClick.emit($event)\"\n    [ngClass]=\"classes\"\n    [ngStyle]=\"{ 'background-color': backgroundColor }\"\n  >\n    {{ label }}\n  </button>`,\n  styleUrls: ['./button.css'],\n})\nexport default class ButtonComponent {\n  /**\n   * Is this the principal call to action on the page?\n   */\n  @Input()\n  primary = false;\n\n  /**\n   * What background color to use\n   */\n  @Input()\n  backgroundColor?: string;\n\n  /**\n   * How large should the button be?\n   */\n  @Input()\n  size: 'small' | 'medium' | 'large' = 'medium';\n\n  /**\n   * Button contents\n   *\n   * @required\n   */\n  @Input()\n  label = 'Button';\n\n  /**\n   * Optional click handler\n   */\n  @Output()\n  onClick = new EventEmitter<Event>();\n\n  public get classes(): string[] {\n    const mode = this.primary ? 'storybook-button--primary' : 'storybook-button--secondary';\n\n    return ['storybook-button', `storybook-button--${this.size}`, mode];\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".storybook-button {\n  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  font-weight: 700;\n  border: 0;\n  border-radius: 3em;\n  cursor: pointer;\n  display: inline-block;\n  line-height: 1;\n}\n.storybook-button--primary {\n  color: white;\n  background-color: #1ea7fd;\n}\n.storybook-button--secondary {\n  color: #333;\n  background-color: transparent;\n  box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;\n}\n.storybook-button--small {\n  font-size: 12px;\n  padding: 10px 16px;\n}\n.storybook-button--medium {\n  font-size: 14px;\n  padding: 11px 20px;\n}\n.storybook-button--large {\n  font-size: 16px;\n  padding: 12px 24px;\n}\n",
                    "styleUrl": "./button.css"
                }
            ],
            "stylesData": "",
            "accessors": {
                "classes": {
                    "name": "classes",
                    "getSignature": {
                        "name": "classes",
                        "type": "[]",
                        "returnType": "string[]",
                        "line": 48
                    }
                }
            }
        },
        {
            "name": "CodeMirrorComponent",
            "id": "component-CodeMirrorComponent-3510b8b4ca6e348c12bb958f88e7edd1",
            "file": "src/main/webapp/src/app/explore/query/codemirror/codemirror.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "codemirror",
            "styleUrls": [
                "./codemirror.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./codemirror.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "prefixes",
                    "line": 19,
                    "type": "string"
                }
            ],
            "outputsClass": [
                {
                    "name": "query",
                    "defaultValue": "new EventEmitter<string>()",
                    "line": 20,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "host",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'code'"
                        }
                    ]
                },
                {
                    "name": "instance",
                    "type": "CodeMirror.Editor",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 26
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 34,
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "submitQuery",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 47
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {\n    Component, AfterViewInit, ViewChild, ElementRef, Output, EventEmitter, Input, OnChanges,\n    SimpleChanges\n} from \"@angular/core\";\nimport * as CodeMirror from \"codemirror\";\n\n@Component({\n    selector: \"codemirror\",\n    templateUrl: \"./codemirror.component.html\",\n    styleUrls: [\"./codemirror.component.scss\"]\n})\n\nexport class CodeMirrorComponent implements AfterViewInit, OnChanges {\n\n    @ViewChild(\"code\") host: ElementRef;\n    @Input() prefixes: string;\n    @Output() query = new EventEmitter<string>();\n    private instance: CodeMirror.Editor;\n\n    constructor() {\n    }\n\n    ngAfterViewInit(): void {\n        this.instance = CodeMirror.fromTextArea(this.host.nativeElement, {\n            lineNumbers: true,\n            theme: \"material\",\n            mode: \"sparql\"\n        });\n    }\n\n    ngOnChanges(changes: SimpleChanges): void {\n        console.debug(\"Updating text from:\", changes[\"prefixes\"].previousValue, \"to:\", changes[\"prefixes\"].currentValue, \"old:\", this.prefixes);\n        // if ((changes[\"prefixes\"].currentValue !== this.prefixes) && (this.instance != null)) {\n        //     console.debug(\"Updating text\", changes[\"prefixes\"]);\n            this.prefixes = changes[\"prefixes\"].currentValue;\n            if (this.instance != null) {\n                console.debug(\"defined, updating\");\n                this.instance.setValue(this.prefixes);\n            }\n            // this.instance.setValue(changes[\"prefixes\"].currentValue);\n        // }\n    }\n\n    submitQuery() {\n        this.query.next(this.instance.getValue());\n    }\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".CodeMirror {\n  text-align: justify;\n  white-space: normal;\n}\n",
                    "styleUrl": "./codemirror.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 21
            },
            "implements": [
                "AfterViewInit",
                "OnChanges"
            ],
            "templateData": "<h4>SPARQL Editor</h4>\n<!--suppress HtmlFormInputWithoutLabel -->\n<textarea #code></textarea>\n<button mat-raised-button (click)=\"submitQuery()\">Execute Query</button>\n"
        },
        {
            "name": "CompareComponent",
            "id": "component-CompareComponent-76b2c67b99f63b7db50272eed3499d5a",
            "file": "src/main/webapp/src/app/explore/compare/compare.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "compare",
            "styleUrls": [
                "./compare.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./compare.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "baseIndividual",
                    "type": "ICompareIndividual | null",
                    "optional": false,
                    "description": "",
                    "line": 50,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "currentSliderValue",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 56,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "dataChanges",
                    "type": "BehaviorSubject<MapSource | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 51,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "disabledFocusIndividuals",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 66,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "exportValues",
                    "type": "IDataExport[]",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "filterCompareResults",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 58,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "layerChanges",
                    "type": "Subject<IMapAttributeChange>",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "layerDepth",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 59,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "layerNumber",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 61,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "loadedOverlap",
                    "type": "ISpatialComparisonReport | null",
                    "optional": false,
                    "description": "",
                    "line": 54,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "loading",
                    "type": "ILoadingState",
                    "optional": false,
                    "description": "",
                    "line": 55,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mapComponent",
                    "type": "TrestleMapComponent",
                    "optional": false,
                    "description": "",
                    "line": 63,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "TrestleMapComponent"
                        }
                    ],
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "mapConfig",
                    "type": "MapboxOptions",
                    "optional": false,
                    "description": "",
                    "line": 48,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mapRef",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 65,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'loadable'"
                        }
                    ],
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "maxHeight",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 60,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "selectedIndividuals",
                    "type": "Map<string | ICompareIndividual>",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "zoomMap",
                    "defaultValue": "true",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 47,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "addBaseIndividual",
                    "args": [
                        {
                            "name": "individual",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 212,
                    "description": "<p>Add base individual to compare</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 7187,
                                "end": 7197,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 7172,
                                "end": 7177,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 7178,
                                "end": 7186,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7179,
                                    "end": 7185,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "addIndividualToCompare",
                    "args": [
                        {
                            "name": "individual",
                            "type": "TrestleIndividual"
                        },
                        {
                            "name": "baseIndividual",
                            "type": "",
                            "defaultValue": "false"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 527,
                    "description": "<p>Add individual to the comparison set and the map</p>\n",
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 17784,
                                "end": 17794,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "TrestleIndividual",
                            "tagName": {
                                "pos": 17758,
                                "end": 17763,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 17764,
                                "end": 17783,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 17765,
                                    "end": 17782,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 17765,
                                        "end": 17782,
                                        "flags": 2097152,
                                        "escapedText": "TrestleIndividual"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 17817,
                                "end": 17831,
                                "flags": 0,
                                "escapedText": "baseIndividual"
                            },
                            "type": "",
                            "defaultValue": "false",
                            "tagName": {
                                "pos": 17801,
                                "end": 17806,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 17807,
                                "end": 17816,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 17808,
                                    "end": 17815,
                                    "flags": 2097152,
                                    "kind": 122
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "compareIndividuals",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 134,
                    "description": "<p>Compare the base individual against all the other currently visible objects</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "filterChanged",
                    "args": [
                        {
                            "name": "event",
                            "type": "MatSlideToggleChange"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 347,
                    "description": "<p>Filter compare results to only return objects which overlap in some way</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 11843,
                                "end": 11848,
                                "flags": 0,
                                "escapedText": "event"
                            },
                            "type": "MatSlideToggleChange",
                            "tagName": {
                                "pos": 11814,
                                "end": 11819,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 11820,
                                "end": 11842,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 11821,
                                    "end": 11841,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 11821,
                                        "end": 11841,
                                        "flags": 2097152,
                                        "escapedText": "MatSlideToggleChange"
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "filterOverlapIndividuals",
                    "args": [
                        {
                            "name": "value",
                            "type": "ICompareIndividual"
                        },
                        {
                            "name": "overlap",
                            "type": "ISpatialComparisonReport"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 620,
                    "description": "<p>Filter only individuals actually involved in the overlap</p>\n",
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 20672,
                                "end": 20677,
                                "flags": 0,
                                "escapedText": "value"
                            },
                            "type": "ICompareIndividual",
                            "tagName": {
                                "pos": 20645,
                                "end": 20650,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 20651,
                                "end": 20671,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 20652,
                                    "end": 20670,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 20652,
                                        "end": 20670,
                                        "flags": 2097152,
                                        "escapedText": "ICompareIndividual"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 20717,
                                "end": 20724,
                                "flags": 0,
                                "escapedText": "overlap"
                            },
                            "type": "ISpatialComparisonReport",
                            "tagName": {
                                "pos": 20684,
                                "end": 20689,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 20690,
                                "end": 20716,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 20691,
                                    "end": 20715,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 20691,
                                        "end": 20715,
                                        "flags": 2097152,
                                        "escapedText": "ISpatialComparisonReport"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 20731,
                                "end": 20738,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "getBase",
                    "args": [
                        {
                            "name": "temporal",
                            "type": "TrestleTemporal"
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 610,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "temporal",
                            "type": "TrestleTemporal",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getHeight",
                    "args": [
                        {
                            "name": "temporal",
                            "type": "TrestleTemporal"
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 601,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "temporal",
                            "type": "TrestleTemporal",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getSelectedIndividuals",
                    "args": [],
                    "optional": false,
                    "returnType": "ICompareIndividual[]",
                    "typeParameters": [],
                    "line": 398,
                    "description": "<p>Get all currently selected individuals</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 13356,
                                "end": 13363,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "[]"
                        }
                    ]
                },
                {
                    "name": "intersectBaseIndividual",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 354,
                    "description": "<p>Perform spatial intersection with base individual</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "loadSelectedIndividual",
                    "args": [
                        {
                            "name": "individual",
                            "type": "string"
                        },
                        {
                            "name": "baseIndividual",
                            "type": "",
                            "defaultValue": "false"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 517,
                    "description": "<p>Load the selected individual by fetching its value from the database</p>\n",
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 17420,
                                "end": 17430,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 17405,
                                "end": 17410,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 17411,
                                "end": 17419,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 17412,
                                    "end": 17418,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 17453,
                                "end": 17467,
                                "flags": 0,
                                "escapedText": "baseIndividual"
                            },
                            "type": "",
                            "defaultValue": "false",
                            "tagName": {
                                "pos": 17437,
                                "end": 17442,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 17443,
                                "end": 17452,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 17444,
                                    "end": 17451,
                                    "flags": 2097152,
                                    "kind": 122
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "ngAfterViewChecked",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 127,
                    "description": "<p>Recheck the view.\nI&#39;m really not sure why I need this, but SO says so\n<a href=\"https://stackoverflow.com/questions/43513421/ngif-expression-has-changed-after-it-was-checked\">https://stackoverflow.com/questions/43513421/ngif-expression-has-changed-after-it-was-checked</a></p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 107,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "removeIndividual",
                    "args": [
                        {
                            "name": "individual",
                            "type": "ICompareIndividual"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 307,
                    "description": "<p>Remove the given individual from the comparison list</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 10376,
                                "end": 10386,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "ICompareIndividual",
                            "tagName": {
                                "pos": 10349,
                                "end": 10354,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 10355,
                                "end": 10375,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 10356,
                                    "end": 10374,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 10356,
                                        "end": 10374,
                                        "flags": 2097152,
                                        "escapedText": "ICompareIndividual"
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "reset",
                    "args": [
                        {
                            "name": "individual",
                            "type": "string",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 222,
                    "description": "<p>Reset comparison to the base state</p>\n<p>If a new individual is provided, add it</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 7432,
                                "end": 7442,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "string",
                            "optional": true,
                            "tagName": {
                                "pos": 7417,
                                "end": 7422,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 7423,
                                "end": 7431,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7424,
                                    "end": 7430,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "selectedHandler",
                    "args": [
                        {
                            "name": "individual",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 203,
                    "description": "<p>Handler function to load the selected individual</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 6960,
                                "end": 6970,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 6945,
                                "end": 6950,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 6951,
                                "end": 6959,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 6952,
                                    "end": 6958,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "sliderUpdate",
                    "args": [
                        {
                            "name": "event",
                            "type": "MatSliderChange"
                        },
                        {
                            "name": "selection",
                            "type": "",
                            "defaultValue": "this.baseIndividual"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 329,
                    "description": "<p>Update explode slider and change the values on the map</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 11079,
                                "end": 11084,
                                "flags": 0,
                                "escapedText": "event"
                            },
                            "type": "MatSliderChange",
                            "tagName": {
                                "pos": 11055,
                                "end": 11060,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 11061,
                                "end": 11078,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 11062,
                                    "end": 11077,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 11062,
                                        "end": 11077,
                                        "flags": 2097152,
                                        "escapedText": "MatSliderChange"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 11125,
                                "end": 11134,
                                "flags": 0,
                                "escapedText": "selection"
                            },
                            "type": "",
                            "defaultValue": "this.baseIndividual",
                            "tagName": {
                                "pos": 11091,
                                "end": 11096,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 11097,
                                "end": 11124,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 11098,
                                    "end": 11123,
                                    "flags": 2097152,
                                    "kind": 168,
                                    "types": [
                                        {
                                            "pos": 11098,
                                            "end": 11116,
                                            "flags": 2097152,
                                            "kind": 161,
                                            "typeName": {
                                                "pos": 11098,
                                                "end": 11116,
                                                "flags": 2097152,
                                                "escapedText": "ICompareIndividual"
                                            }
                                        },
                                        {
                                            "pos": 11118,
                                            "end": 11123,
                                            "flags": 2097152,
                                            "kind": 95
                                        }
                                    ]
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "toggleFocus",
                    "args": [
                        {
                            "name": "individual",
                            "type": "ICompareIndividual"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 257,
                    "description": "<p>Toggle the focus of a given individual, this will hide all other currently visible individuals</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 8476,
                                "end": 8486,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "ICompareIndividual",
                            "tagName": {
                                "pos": 8449,
                                "end": 8454,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 8455,
                                "end": 8475,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 8456,
                                    "end": 8474,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 8456,
                                        "end": 8474,
                                        "flags": 2097152,
                                        "escapedText": "ICompareIndividual"
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "toggleOverlap",
                    "args": [
                        {
                            "name": "overlap",
                            "type": "ISpatialComparisonReport"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 414,
                    "description": "<p>Toggle overlap between the base individual and the selected individual</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 13855,
                                "end": 13862,
                                "flags": 0,
                                "escapedText": "overlap"
                            },
                            "type": "ISpatialComparisonReport",
                            "tagName": {
                                "pos": 13822,
                                "end": 13827,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 13828,
                                "end": 13854,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 13829,
                                    "end": 13853,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 13829,
                                        "end": 13853,
                                        "flags": 2097152,
                                        "escapedText": "ISpatialComparisonReport"
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "toggleVisibility",
                    "args": [
                        {
                            "name": "individual",
                            "type": "ICompareIndividual"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 245,
                    "description": "<p>Toggle the visibility of the given individual</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 8076,
                                "end": 8086,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "ICompareIndividual",
                            "tagName": {
                                "pos": 8049,
                                "end": 8054,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 8055,
                                "end": 8075,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 8056,
                                    "end": 8074,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 8056,
                                        "end": 8074,
                                        "flags": 2097152,
                                        "escapedText": "ICompareIndividual"
                                    }
                                }
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {AfterViewChecked, AfterViewInit, ChangeDetectorRef, Component, ElementRef, ViewChild} from \"@angular/core\";\nimport {ISpatialComparisonReport, MapService} from \"../viewer/map.service\";\nimport moment from \"moment\";\nimport {interpolateReds} from \"d3-scale-chromatic\";\nimport {IDataExport} from \"../exporter/exporter.component\";\nimport {parse} from \"wellknown\";\nimport {MultiPolygon} from \"geojson\";\nimport {ActivatedRoute} from \"@angular/router\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {IMapAttributeChange, MapSource, TrestleMapComponent} from \"../../ui/trestle-map/trestle-map.component\";\nimport {IndividualService} from \"../../shared/individual/individual.service\";\nimport {LoadingSpinnerService} from \"../../ui/loading-spinner/loading-spinner.service\";\nimport {ColorService} from \"../../shared/color/color.service\";\nimport {TrestleTemporal} from \"../../shared/individual/TrestleIndividual/trestle-temporal\";\nimport {MapboxOptions} from \"mapbox-gl\";\nimport {MatSliderChange} from \"@angular/material/slider\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\ninterface ICompareIndividual {\n  individual: TrestleIndividual;\n  color: string;\n  visible: boolean;\n  focused: boolean;\n  height: number;\n  base: number;\n  sliderValue: number;\n  report?: ISpatialComparisonReport;\n}\n\ninterface ILoadingState {\n  color: loadingColor;\n  type: loadingState;\n  visible: boolean;\n}\n\nexport type loadingState = 'determinate' | 'indeterminate';\nexport type loadingColor = 'accent' | 'warn' | 'primary';\n\n@Component({\n  selector: 'compare',\n  templateUrl: './compare.component.html',\n  styleUrls: ['./compare.component.scss']\n})\nexport class CompareComponent implements AfterViewInit, AfterViewChecked {\n\n  public zoomMap = true;\n  public mapConfig: MapboxOptions;\n  public selectedIndividuals: Map<string, ICompareIndividual>;\n  public baseIndividual: ICompareIndividual | null;\n  public dataChanges: BehaviorSubject<MapSource | undefined>;\n  public layerChanges: Subject<IMapAttributeChange>;\n  public exportValues: IDataExport[];\n  public loadedOverlap: ISpatialComparisonReport | null;\n  public loading: ILoadingState;\n  public currentSliderValue: number;\n\n  private filterCompareResults: boolean;\n  private layerDepth: number;\n  private maxHeight: number;\n  private layerNumber: number;\n  @ViewChild(TrestleMapComponent)\n  private mapComponent: TrestleMapComponent;\n  @ViewChild('loadable')\n  private mapRef: ElementRef;\n  private disabledFocusIndividuals: string[];\n\n  constructor(private is: IndividualService,\n              private vs: MapService,\n              private spinner: LoadingSpinnerService,\n              private route: ActivatedRoute,\n              private cdRef: ChangeDetectorRef,\n              private cs: ColorService\n  ) {\n\n    this.mapConfig = {\n      style: 'mapbox://styles/nrobison/cj3n7if3q000s2sutls5a1ny7',\n      center: [32.3558991, -25.6854313],\n      zoom: 8,\n      pitch: 40,\n      bearing: 20,\n      container: \"map\"\n    };\n    this.layerDepth = 50;\n    this.maxHeight = 2016;\n    this.selectedIndividuals = new Map();\n    // Setup layer coloring\n    this.layerNumber = 0;\n    this.currentSliderValue = 0;\n    this.dataChanges = new BehaviorSubject(undefined);\n    this.layerChanges = new Subject();\n    this.filterCompareResults = true;\n    this.exportValues = [{\n      dataset: 'GAUL',\n      individuals: []\n    }];\n    this.loadedOverlap = null;\n\n    this.loading = {\n      color: 'primary',\n      type: 'indeterminate',\n      visible: false\n    };\n    this.disabledFocusIndividuals = [];\n  }\n\n  public ngAfterViewInit(): void {\n    // Subscribe to route observables\n    this.route.queryParams\n      .subscribe((queryParams) => {\n        console.debug('params', queryParams);\n        const individual = queryParams['id'];\n        if (individual !== null) {\n          this.addBaseIndividual(individual);\n        }\n      });\n\n    console.debug('Child', this.mapComponent);\n    this.spinner.setViewContainerRef(this.mapRef.nativeElement);\n  }\n\n  /**\n   * Recheck the view.\n   * I'm really not sure why I need this, but SO says so\n   * https://stackoverflow.com/questions/43513421/ngif-expression-has-changed-after-it-was-checked\n   */\n  public ngAfterViewChecked(): void {\n    this.cdRef.detectChanges();\n  }\n\n  /**\n   * Compare the base individual against all the other currently visible objects\n   */\n  public compareIndividuals(): void {\n    // Get all the individuals\n    if (this.baseIndividual) {\n      this.loading = {\n        color: 'accent',\n        type: 'indeterminate',\n        visible: true\n      };\n      this.vs.compareIndividuals({\n        compare: this.baseIndividual.individual.getID(),\n        compareAgainst: Array.from(this.selectedIndividuals.values())\n          // Filter out invisible members\n          .filter((individual) => individual.visible === true)\n          .map((individual) => individual.individual.getID())\n      })\n        .subscribe((data) => {\n          console.debug('Has data from compare', data);\n          // Add the comparison reports to each individual,\n          // or set them equal to undefined\n          data.reports.forEach((report) => {\n            this.loading.visible = false;\n            const selection = this.selectedIndividuals.get(report.objectBID);\n            if (selection) {\n              if (selection.visible) {\n                selection.report = report;\n                //    Change the color to something on the red scale\n                if (report.spatialOverlapPercentage) {\n                  const interpolated = interpolateReds(\n                    report.spatialOverlapPercentage);\n                  selection.color = interpolated;\n                  this.layerChanges.next({\n                    individual: selection.individual.getID(),\n                    // Change the color and set the opacity a little higher\n                    changes: [\n                      {\n                        attribute: 'fill-extrusion-color',\n                        value: interpolated\n                      },\n                      {\n                        attribute: 'fill-extrusion-opacity',\n                        value: 0.85\n                      }]\n                  });\n                } else {\n                  // If we don't have any overlap, are we supposed to filter ou those individuals?\n                  if (this.filterCompareResults) {\n                    this.removeIndividual(selection);\n                  }\n                }\n              } else {\n                selection.report = undefined;\n              }\n            }\n          });\n        }, (error) => {\n          console.debug(error);\n          this.loading = {\n            color: 'warn',\n            type: 'determinate',\n            visible: true\n          };\n        });\n    }\n  }\n\n  /**\n   * Handler function to load the selected individual\n   * @param {string} individual\n   */\n  public selectedHandler(individual: string): void {\n    console.debug('Selected:', individual);\n    this.loadSelectedIndividual(individual);\n  }\n\n  /**\n   * Add base individual to compare\n   * @param {string} individual\n   */\n  public addBaseIndividual(individual: string): void {\n    this.loadSelectedIndividual(individual, true);\n  }\n\n  /**\n   * Reset comparison to the base state\n   *\n   * If a new individual is provided, add it\n   * @param {string} individual\n   */\n  public reset(individual?: string): void {\n    //    Clear the map\n    //    Remove all the individuals from map\n    this.mapComponent.clearMap();\n    this.zoomMap = true;\n    // this.selectedIndividuals = [];\n    this.selectedIndividuals = new Map();\n    //    Clear the base selection\n    this.baseIndividual = null;\n    this.layerNumber = 0;\n    this.currentSliderValue = 0;\n    this.cs.reset();\n\n    //    Should we add the given individual to the compare?\n    if (individual) {\n      this.addBaseIndividual(individual);\n    }\n  }\n\n  /**\n   * Toggle the visibility of the given individual\n   * @param {ICompareIndividual} individual\n   */\n  public toggleVisibility(individual: ICompareIndividual): void {\n    individual.visible = !individual.visible;\n    this.mapComponent\n      .toggleIndividualVisibility(individual\n          .individual.getID(),\n        individual.visible);\n  }\n\n  /**\n   * Toggle the focus of a given individual, this will hide all other currently visible individuals\n   * @param {ICompareIndividual} individual\n   */\n  public toggleFocus(individual: ICompareIndividual): void {\n    individual.focused = !individual.focused;\n\n    // If we've selected the focus option, grab all the currently visible layers, disable them, and stash them for later\n    if (individual.focused) {\n      // If we have previously disabled individuals, reenable them, then do your thing\n      if (!(this.disabledFocusIndividuals.length === 0)) {\n        this.disabledFocusIndividuals\n          .forEach((fIndividual) => {\n            const mapValue = this.selectedIndividuals.get(fIndividual);\n            if (mapValue) {\n              this.toggleVisibility(mapValue);\n            }\n          });\n        // Also, find any other focused layers, and unfocus them.\n        this.selectedIndividuals\n          .forEach((value) => {\n            if (value !== individual && value.focused) {\n              value.focused = false;\n            }\n          });\n        this.disabledFocusIndividuals = [];\n      }\n      //    Get all the currently visible layers\n      this.selectedIndividuals\n        .forEach((value, key) => {\n          // If the individual is visible, stash it's value so we can enable it later\n          if (value !== individual && value.visible) {\n            this.disabledFocusIndividuals.push(key);\n            this.toggleVisibility(value);\n          }\n        });\n      //    If the individual isn't supposed to be focused, grab all the stashed individuals and reenable them.\n    } else {\n      this.disabledFocusIndividuals\n        .forEach((fIndividual) => {\n          const mapValue = this.selectedIndividuals.get(fIndividual);\n          if (mapValue) {\n            this.toggleVisibility(mapValue);\n          }\n        });\n      //    Reset the focused list\n      this.disabledFocusIndividuals = [];\n    }\n  }\n\n  /**\n   * Remove the given individual from the comparison list\n   * @param {ICompareIndividual} individual\n   */\n  public removeIndividual(individual: ICompareIndividual): void {\n    console.debug('Remove:', individual);\n    // Remove from the array first, then from the map\n    this.selectedIndividuals.delete(individual.individual.getID());\n    this.mapComponent\n      .removeIndividual(individual.individual.getID());\n\n    //    Remove from export\n    const idx = this.exportValues[0].individuals.indexOf(individual.individual.getID());\n    if (idx > -1) {\n      this.exportValues[0].individuals.splice(idx);\n    }\n\n    //    Return the color to reuse\n    this.cs.returnColor(individual.color);\n  }\n\n  /**\n   * Update explode slider and change the values on the map\n   * @param {MatSliderChange} event\n   * @param {ICompareIndividual | null} selection\n   */\n  public sliderUpdate(event: MatSliderChange, selection = this.baseIndividual) {\n    if ((event.value !== null) && (selection !== null)) {\n      //     For now, let's just change the base individual,\n      // we'll figure out the rest later\n      const newOffset = (event.value - selection.sliderValue) * 50;\n      this.mapComponent.change3DOffset(selection.height,\n        newOffset,\n        selection.individual.getID());\n      selection.sliderValue = event.value;\n      selection.height = selection.height + newOffset;\n      selection.base = selection.base + newOffset;\n    }\n  }\n\n  /**\n   * Filter compare results to only return objects which overlap in some way\n   * @param {MatSlideToggleChange} event\n   */\n  public filterChanged(event: MatSlideToggleChange): void {\n    this.filterCompareResults = event.checked;\n  }\n\n  /**\n   * Perform spatial intersection with base individual\n   */\n  public intersectBaseIndividual(): void {\n    if (this.baseIndividual) {\n      // this.spinner.reveal();\n      this.loading = {\n        color: 'accent',\n        type: 'indeterminate',\n        visible: true\n      };\n      this.vs\n        .stIntersectIndividual('GAUL',\n          this.baseIndividual.individual.getSpatialValue(),\n          undefined,\n          moment(),\n          0)\n        .subscribe((results) => {\n          console.debug('IDs', results.map((indv) => indv.withoutHostname()));\n          // If we have results, turn off the loading bar\n          this.loading.visible = false;\n          results\n            .filter((result) => {\n              // Filter out the base individual,\n              // if it exists, in the grossest way possible\n              if (this.baseIndividual !== null) {\n                return !(result.getID() === this.baseIndividual.individual.getID());\n              }\n              return true;\n            })\n            .forEach((result) => this.addIndividualToCompare(result, false));\n          // this.spinner.hide();\n        }, (error) => {\n          console.error(error);\n          this.loading = {\n            color: 'warn',\n            type: 'determinate',\n            visible: true\n          };\n        });\n    }\n  };\n\n  /**\n   * Get all currently selected individuals\n   * @returns {ICompareIndividual[]}\n   */\n  public getSelectedIndividuals(): ICompareIndividual[] {\n    return Array.from(this.selectedIndividuals.values());\n  }\n\n  /**\n   * Pipe function to enable the view to check for changes\n   * @returns {ICompareIndividual[]}\n   */\n  public get mapValues(): ICompareIndividual[] {\n    return Array.from(this.selectedIndividuals.values());\n  }\n\n  /**\n   * Toggle overlap between the base individual and the selected individual\n   * @param {ISpatialComparisonReport} overlap\n   */\n  public toggleOverlap(overlap: ISpatialComparisonReport): void {\n    const id = TrestleIndividual.filterID(overlap.objectAID)\n      + '-' + TrestleIndividual.filterID(overlap.objectBID);\n    // If we have an overlap, and we haven't loaded it yet\n    if (overlap.spatialOverlap) {\n      // If the loaded overlap is null, add the new one\n      if (this.loadedOverlap === null) {\n        // Build the change value\n        const changes: MapSource = {\n          id,\n          data: {\n            type: 'Feature',\n            // TODO(nickrobison): Gross?\n            geometry: (parse(overlap.spatialOverlap) as MultiPolygon),\n            properties: null,\n            id\n          },\n          extrude: {\n            id: id + '-extrude',\n            type: 'fill-extrusion',\n            source: id,\n            paint: {\n              'fill-extrusion-color': 'blue',\n              'fill-extrusion-height': 3050,\n              'fill-extrusion-base': 3000,\n              'fill-extrusion-opacity': 0.7\n            }\n          }\n        };\n\n        //    Turn off all layers except objects A and B that we need\n        this.selectedIndividuals.forEach((value) => {\n          if (CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            this.toggleVisibility(value);\n          }\n        });\n\n        //    Now, add the new overlap\n        this.dataChanges.next(changes);\n        this.loadedOverlap = overlap;\n\n        //    If we are the overlap, remove us and turn everything back on\n      } else if (this.loadedOverlap === overlap) {\n        this.selectedIndividuals.forEach((value) => {\n          if (CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            this.toggleVisibility(value);\n          }\n        });\n        this.mapComponent.removeIndividual(id);\n        this.loadedOverlap = null;\n        //    Otherwise, remove the current overlap, and cycle what needs to be toggled\n      } else {\n        //    Unload the current overlap\n        const overlapID = TrestleIndividual.filterID(this.loadedOverlap.objectAID)\n          + '-' + TrestleIndividual.filterID(this.loadedOverlap.objectBID);\n        this.mapComponent.removeIndividual(overlapID);\n        //    Build the change value\n        const changes: MapSource = {\n          id,\n          data: {\n            type: 'Feature',\n            // TODO(nickrobison): Gross?\n            geometry: (parse(overlap.spatialOverlap) as MultiPolygon),\n            properties: null,\n            id\n          },\n          extrude: {\n            id: id + '-extrude',\n            type: 'fill-extrusion',\n            source: id,\n            paint: {\n              'fill-extrusion-color': 'blue',\n              'fill-extrusion-height': 4000,\n              'fill-extrusion-base': 3000,\n              'fill-extrusion-opacity': 0.7\n            }\n          }\n        };\n\n        this.selectedIndividuals.forEach((value) => {\n          //    If it's part of the new overlap, and is not visible, turn it on\n          if (!CompareComponent.filterOverlapIndividuals(value, overlap)) {\n            if (!value.visible) {\n              this.toggleVisibility(value);\n            }\n            //    If it's visible and not part of the new overlap, turn it off\n          } else if (value.visible) {\n            this.toggleVisibility(value);\n          }\n        });\n\n        //    Set the new overlap\n        this.dataChanges.next(changes);\n        this.loadedOverlap = overlap;\n      }\n    }\n  }\n\n  /**\n   * Load the selected individual by fetching its value from the database\n   * @param {string} individual\n   * @param {boolean} baseIndividual\n   */\n  private loadSelectedIndividual(individual: string, baseIndividual = false): void {\n    this.is.getTrestleIndividual(individual)\n      .subscribe((result) => this.addIndividualToCompare(result, baseIndividual));\n  }\n\n  /**\n   * Add individual to the comparison set and the map\n   * @param {TrestleIndividual} individual\n   * @param {boolean} baseIndividual\n   */\n  private addIndividualToCompare(individual: TrestleIndividual, baseIndividual = false): void {\n    console.debug('Adding individual:', individual);\n    // Before we add any individuals to the map, we need to see if we're loading the base individual or not\n    // This is to deal with some racy behavior between drawing the individual on the map and moving on from the data load\n    // It's gross, but what do you expect?\n    if (baseIndividual) {\n      console.debug('Setting zoom true');\n      this.zoomMap = true;\n    } else {\n      console.debug('Setting zoom false');\n      // If zoom is true, manually run the change detection.\n      // Why? no idea\n      if (this.zoomMap === true) {\n        this.zoomMap = false;\n        this.cdRef.detectChanges();\n      } else {\n        this.zoomMap = false;\n      }\n    }\n\n    // This is one way to filter out the base individual\n    console.debug('Adding %s to map', individual.getFilteredID());\n    const color = this.cs.getColor(this.layerNumber);\n    const height = this.getHeight(individual.getTemporal());\n    const baseHeight = CompareComponent.getBase(individual.getTemporal());\n    this.dataChanges.next({\n      id: individual.getID(),\n      data: {\n        type: 'Feature',\n        geometry: individual.getSpatialValue(),\n        id: individual.getFilteredID(),\n        properties: individual.getFactValues()\n      },\n      extrude: {\n        id: individual.getID() + '-extrude',\n        type: 'fill-extrusion',\n        source: individual.getID(),\n        paint: {\n          'fill-extrusion-color': color,\n          'fill-extrusion-height': height,\n          'fill-extrusion-base': baseHeight,\n          'fill-extrusion-opacity': 0.7\n        }\n      },\n      labelField: 'adm2_name'\n    });\n\n    const compare = {\n      individual,\n      color,\n      visible: true,\n      focused: false,\n      height,\n      base: baseHeight,\n      sliderValue: 50\n    };\n\n    // Are we loading the base selection, or not?\n    if (baseIndividual) {\n      // Reset the slider value to 0\n      compare.sliderValue = 0;\n      this.baseIndividual = compare;\n    } else {\n      //    Add the selection to the list\n      this.selectedIndividuals.set(compare.individual.getID(),\n        compare);\n      // this.selectedIndividuals.push(compare);\n    }\n    this.layerNumber++;\n\n    //    Add them to the export record\n    this.exportValues[0].individuals.push(compare.individual.getID());\n  }\n\n  private getHeight(temporal: TrestleTemporal): number {\n    const to = temporal.getTo();\n    if (to === undefined) {\n      return this.maxHeight;\n    } else {\n      return to.get('year');\n    }\n  }\n\n  private static getBase(temporal: TrestleTemporal): number {\n    return temporal.getFrom().get('year');\n  }\n\n  /**\n   * Filter only individuals actually involved in the overlap\n   * @param {ICompareIndividual} value\n   * @param {ISpatialComparisonReport} overlap\n   * @returns {boolean}\n   */\n  private static filterOverlapIndividuals(value: ICompareIndividual, overlap: ISpatialComparisonReport) {\n    const id = value.individual.getID();\n    return (id !== overlap.objectAID) &&\n      (id !== overlap.objectBID);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".map-container {\n  height: 400px;\n}\n\n.mat-slider-vertical {\n  height: 400px;\n}\n\n.ui-row {\n  height: 530px;\n}\n\n.results-row {\n  display: flex;\n  align-items: center;\n}\n\na {\n  color:inherit;\n}\n\n.legend {\n  float: left;\n  width: 20px;\n  height: 20px;\n  margin: 5px;\n  border: 1px solid rgba(0, 0, 0, .2);\n}\n\n.thin-column {\n  padding: 0;\n}\n\n.legend-column {\n  width: 20px;\n}\n\n.wide-slider {\n  width: 80%;\n}\n\n.map-container .mat-slider-vertical {\n  height: 90%\n}\n\n.progress {\n  width: 95%;\n  margin-top: 10px;\n}\n",
                    "styleUrl": "./compare.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "is",
                        "type": "IndividualService"
                    },
                    {
                        "name": "vs",
                        "type": "MapService"
                    },
                    {
                        "name": "spinner",
                        "type": "LoadingSpinnerService"
                    },
                    {
                        "name": "route",
                        "type": "ActivatedRoute"
                    },
                    {
                        "name": "cdRef",
                        "type": "ChangeDetectorRef"
                    },
                    {
                        "name": "cs",
                        "type": "ColorService"
                    }
                ],
                "line": 66,
                "jsdoctags": [
                    {
                        "name": "is",
                        "type": "IndividualService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "vs",
                        "type": "MapService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "spinner",
                        "type": "LoadingSpinnerService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "route",
                        "type": "ActivatedRoute",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "cdRef",
                        "type": "ChangeDetectorRef",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "cs",
                        "type": "ColorService",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "AfterViewInit",
                "AfterViewChecked"
            ],
            "accessors": {
                "mapValues": {
                    "name": "mapValues",
                    "getSignature": {
                        "name": "mapValues",
                        "type": "[]",
                        "returnType": "ICompareIndividual[]",
                        "line": 406,
                        "description": "<p>Pipe function to enable the view to check for changes</p>\n",
                        "jsdoctags": [
                            {
                                "pos": 13584,
                                "end": 13615,
                                "flags": 0,
                                "kind": 293,
                                "atToken": {
                                    "pos": 13584,
                                    "end": 13585,
                                    "flags": 0,
                                    "kind": 57
                                },
                                "tagName": {
                                    "pos": 13585,
                                    "end": 13592,
                                    "flags": 0,
                                    "escapedText": "returns"
                                },
                                "typeExpression": {
                                    "pos": 13593,
                                    "end": 13615,
                                    "flags": 0,
                                    "kind": 277,
                                    "type": {
                                        "pos": 13594,
                                        "end": 13614,
                                        "flags": 2097152,
                                        "kind": 166,
                                        "elementType": {
                                            "pos": 13594,
                                            "end": 13612,
                                            "flags": 2097152,
                                            "kind": 161,
                                            "typeName": {
                                                "pos": 13594,
                                                "end": 13612,
                                                "flags": 2097152,
                                                "escapedText": "ICompareIndividual"
                                            }
                                        }
                                    }
                                },
                                "comment": ""
                            }
                        ]
                    }
                }
            },
            "templateData": "<div class=\"section\">\n    <h4>Spatial Compare</h4>\n    <div class=\"row\">\n        <div #loadable class=\"col s11 map-container\">\n            <trestle-map [single]=\"false\"\n                         [multiSelect]=\"false\"\n                         [zoomOnLoad]=\"zoomMap\"\n                         [config]=\"mapConfig\"\n                         [dataChanges]=\"dataChanges\"\n                         [attributeChanges]=\"layerChanges\"></trestle-map>\n        </div>\n        <div class=\"col s01 map-container\">\n            <h6 class=\"light_gray_text\">Explode</h6>\n            <mat-slider\n                    [vertical]=\"true\"\n                    [min]=\"0\"\n                    [max]=\"500\"\n                    [(ngModel)]=\"currentSliderValue\"\n                    (input)=\"sliderUpdate($event)\"></mat-slider>\n        </div>\n    </div>\n</div>\n<div class=\"section\">\n    <div *ngIf=\"!baseIndividual\">\n        <h5>Add base individual</h5>\n        <search (selected)=\"addBaseIndividual($event)\"></search>\n    </div>\n    <div *ngIf=\"baseIndividual\">\n        <div class=\"row\">\n            <div class=\"row results-row\">\n                <h5>Comparing: {{baseIndividual.individual.getFilteredID()}}</h5>\n                <a [routerLink]=\"['/explore', 'visualize', baseIndividual.individual.withoutHostname()]\"\n                   [queryParams]=\"{root: baseIndividual.individual.getHostname()}\">\n                    <mat-icon>link</mat-icon>\n                </a>\n            </div>\n            <button mat-raised-button color=\"primary\" (click)=\"intersectBaseIndividual()\">INTERSECT</button>\n            <button mat-raised-button color=\"warn\" (click)=\"reset()\">RESET</button>\n            <mat-button-toggle mat-raised-button (click)=\"toggleVisibility(baseIndividual)\">HIDE</mat-button-toggle>\n            <!--Need this because the hidden attribute doesn't work on progress bars. That would be too easy-->\n            <div class=\"progress\" [style.visibility]=\"loading.visible ? 'visible' : 'hidden'\">\n                <mat-progress-bar [color]=\"loading.color\"\n                                  [mode]=\"loading.type\"\n                                  [value]=\"100\"></mat-progress-bar>\n            </div>\n        </div>\n\n        <div class=\"row\">\n            <div class=\"col s12 l5 ui-row\">\n                Add additional individuals\n                <search (selected)=\"selectedHandler($event)\"></search>\n                <div class=\"row\">\n                    <button mat-raised-button>ADD</button>\n                    <button mat-raised-button\n                            color=\"primary\"\n                            (click)=\"compareIndividuals()\"\n                            [disabled]=\"selectedIndividuals.size === 0\">COMPARE\n                    </button>\n                    <mat-slide-toggle\n                            [color]=\"'accent'\"\n                            [checked]=\"true\"\n                            (change)=\"filterChanged($event)\"\n                    >Filter non-overlapping results?\n                    </mat-slide-toggle>\n                </div>\n                <div class=\"row\">\n                    <data-exporter [dataExport]=\"exportValues\"></data-exporter>\n                </div>\n            </div>\n            <div class=\"col s12 l6 ui-row\">\n                Comparing against:\n                <mat-accordion [multi]=\"true\">\n                    <mat-expansion-panel *ngFor=\"let selection of getSelectedIndividuals()\">\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                <div class=\"legend\" [style.background]=\"selection.color\"></div>\n                                {{selection.individual.getFilteredID()}}\n                                <a\n                                        matTooltip=\"Visualize individual\"\n                                        [routerLink]=\"['/explore',\n                                'visualize',\n                                selection.individual.withoutHostname()]\"\n                                        [queryParams]=\"{root: selection.individual.getHostname()}\">\n                                    <mat-icon>link</mat-icon>\n                                </a>\n                                <mat-icon matTooltip=\"Use as comparison\" (click)=\"reset(selection.individual.getID())\">compare</mat-icon>\n\n                            </mat-panel-title>\n                            <mat-panel-description>\n                            </mat-panel-description>\n                        </mat-expansion-panel-header>\n                        <div *ngIf=\"selection.report === undefined\">\n                            <p class=\"comparison-placeholder\">No comparison report</p>\n                        </div>\n                        <div *ngIf=\"selection.report\">\n                            Accounts for {{selection.report.spatialOverlapPercentage * 100 | rounding: 2}}% of the\n                            individual\n                            <div *ngIf=\"selection.report.spatialOverlap\">\n                                <mat-icon *ngIf=\"selection.report !== loadedOverlap\"\n                                          matTooltip=\"Add overlap to map\"\n                                          (click)=\"toggleOverlap(selection.report)\">layers\n                                </mat-icon>\n                                <mat-icon *ngIf=\"selection.report === loadedOverlap\"\n                                          matTooltip=\"Remove overlap from map\"\n                                          (click)=\"toggleOverlap(selection.report)\">layers_clear\n                                </mat-icon>\n                            </div>\n                            <!--Relations-->\n                            <h6>Relations:</h6>\n                            <ul>\n                                <li *ngFor=\"let relation of selection.report.relations\">{{relation}}</li>\n                            </ul>\n\n                        </div>\n                        <mat-action-row>\n                            <mat-slider class=\"wide-slider\"\n                                        [min]=\"0\"\n                                        [max]=\"100\"\n                                        [value]=\"selection.sliderValue\"\n                                        (input)=\"sliderUpdate($event,\n                            selection)\"></mat-slider>\n                            <button mat-button *ngIf=\"!selection.focused\" (click)=\"toggleFocus(selection)\">Focus</button>\n                            <button mat-button *ngIf=\"selection.focused\" (click)=\"toggleFocus(selection)\">Unfocus</button>\n                            <button mat-button *ngIf=\"selection.visible\" (click)=\"toggleVisibility(selection)\">Hide\n                            </button>\n                            <button mat-button *ngIf=\"!selection.visible\" (click)=\"toggleVisibility(selection)\">Show\n                            </button>\n                            <button mat-button color=\"warn\" (click)=\"removeIndividual(selection)\">Remove</button>\n                        </mat-action-row>\n                    </mat-expansion-panel>\n                </mat-accordion>\n            </div>\n        </div>\n    </div>\n</div>\n"
        },
        {
            "name": "DashboardComponent",
            "id": "component-DashboardComponent-b435eaaae66f2915cd8d460422bda865",
            "file": "src/main/webapp/src/app/admin/dashboard/dashboard.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "admin-dashboard",
            "styleUrls": [
                "./dashboard.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./dashboard.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component} from \"@angular/core\";\n@Component({\n    selector: \"admin-dashboard\",\n    templateUrl: \"./dashboard.component.html\",\n    styleUrls: [\"./dashboard.component.scss\"]\n})\n\nexport class DashboardComponent {\n    constructor() {}\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".dashboard-card {\n    width: 400px;\n    padding: 10px;\n    margin: 20px;\n    text-align: center;\n}\n",
                    "styleUrl": "./dashboard.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 12
            },
            "templateData": "<mat-card>\n    <mat-card-content>\n        An example card\n    </mat-card-content>\n</mat-card>\n<mat-grid-list cols=\"4\" rowHeight=\"400px\">\n    <mat-grid-tile colspan=\"2\" rowspan=\"1\">\n        <mat-card class=\"dashboard-card\">\n            <mat-card-content>\n                Another example card\n            </mat-card-content>\n        </mat-card>\n    </mat-grid-tile>\n    <mat-grid-tile rowspan=\"2\" colspan=\"1\">\n        <mat-card class=\"dashboard-card\">\n            <mat-card-content>\n                A third example card\n            </mat-card-content>\n        </mat-card>\n    </mat-grid-tile>\n    <mat-grid-tile>\n        <mat-card class=\"dashboard-card\">\n            <mat-card-content>\n                Final example card\n            </mat-card-content>\n        </mat-card>\n    </mat-grid-tile>\n</mat-grid-list>"
        },
        {
            "name": "EventGraphComponent",
            "id": "component-EventGraphComponent-ea0c561eeea2d6596a2cf4d50bd8a44d",
            "file": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "event-graph",
            "styleUrls": [
                "./event-graph.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./event-graph.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "data",
                    "line": 37,
                    "type": "IEventData"
                },
                {
                    "name": "filterLabel",
                    "line": 42,
                    "type": "function"
                },
                {
                    "name": "graphHeight",
                    "line": 38,
                    "type": "number"
                },
                {
                    "name": "graphWidth",
                    "line": 39,
                    "type": "number"
                },
                {
                    "name": "maxDate",
                    "line": 41,
                    "type": "Date"
                },
                {
                    "name": "minDate",
                    "line": 40,
                    "type": "Date"
                },
                {
                    "name": "selectedIndividual",
                    "line": 36,
                    "type": "string"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "applyFilter",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "<p>Apply the filter function, if it exists, otherwise, return the entity as the label</p>\n",
                    "line": 240,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "pos": 7363,
                            "end": 7397,
                            "flags": 0,
                            "kind": 292,
                            "atToken": {
                                "pos": 7363,
                                "end": 7364,
                                "flags": 0,
                                "kind": 57
                            },
                            "tagName": {
                                "pos": 7364,
                                "end": 7369,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "typeExpression": {
                                "pos": 7370,
                                "end": 7385,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7371,
                                    "end": 7384,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 7371,
                                        "end": 7384,
                                        "flags": 2097152,
                                        "escapedText": "IEventElement"
                                    }
                                }
                            },
                            "name": {
                                "pos": 7386,
                                "end": 7391,
                                "flags": 0,
                                "escapedText": "input"
                            },
                            "isNameFirst": false,
                            "isBracketed": false,
                            "comment": ""
                        },
                        {
                            "pos": 7397,
                            "end": 7414,
                            "flags": 0,
                            "kind": 293,
                            "atToken": {
                                "pos": 7397,
                                "end": 7398,
                                "flags": 0,
                                "kind": 57
                            },
                            "tagName": {
                                "pos": 7398,
                                "end": 7405,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "typeExpression": {
                                "pos": 7406,
                                "end": 7414,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7407,
                                    "end": 7413,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            },
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "element",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 34,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'graph'"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "height",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 47,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "host",
                    "type": "Selection<HTMLElement | IEventElement | IEventLink | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 44,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "htmlElement",
                    "type": "HTMLElement",
                    "optional": false,
                    "description": "",
                    "line": 43,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "margin",
                    "type": "ID3Margin",
                    "optional": false,
                    "description": "",
                    "line": 48,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "svg",
                    "type": "Selection<BaseType | IEventElement | IEventLink | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 45,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "tooltip",
                    "type": "any",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "tooltipEl",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 35,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'tooltip'"
                        }
                    ],
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "width",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 46,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 56,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 61,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "plotData",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 70,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "setupD3",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 196,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChanges, ViewChild} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {scaleLinear, scaleOrdinal, scaleTime} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {axisBottom} from \"d3-axis\";\nimport {ID3Margin} from \"../common\";\n\nexport interface IEventElement {\n  id: string;\n  entity: string;\n  temporal: Date;\n  bin: number;\n  value: any;\n  continuing?: boolean;\n}\n\nexport interface IEventLink {\n  source: IEventElement;\n  target: IEventElement;\n}\n\nexport interface IEventData {\n  bins: number;\n  nodes: IEventElement[];\n  links: IEventLink[];\n}\n\n@Component({\n  selector: 'event-graph',\n  templateUrl: './event-graph.component.html',\n  styleUrls: ['./event-graph.component.scss']\n})\nexport class EventGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('graph') public element: ElementRef;\n  @ViewChild('tooltip') private tooltipEl: ElementRef;\n  @Input() public selectedIndividual: string;\n  @Input() public data: IEventData;\n  @Input() public graphHeight: number;\n  @Input() public graphWidth: number;\n  @Input() public minDate: Date;\n  @Input() public maxDate: Date;\n  @Input() public filterLabel?: (input: IEventElement) => string;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IEventElement | IEventLink, null, undefined>;\n  private svg: Selection<BaseType, IEventElement | IEventLink, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private tooltip: any;\n\n\n  public constructor() {\n\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n  }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    const dataChange = changes['data'];\n    if (dataChange.currentValue !== undefined\n      && (dataChange.currentValue !== dataChange.previousValue)) {\n      console.debug('Changed, plotting data', this.data);\n      this.plotData();\n    }\n  }\n\n  private plotData(): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    //    Setup the X/Y/Z values\n    const entityNames = this.data.nodes.map((d) => d.entity);\n    const x = scaleTime()\n      .range([120, this.width])\n      .domain([this.minDate, this.maxDate]);\n    const y = scaleLinear()\n      .range([this.height, 0])\n      .domain([0, this.data.bins]);\n    const z = scaleOrdinal(schemeCategory10)\n      .domain(entityNames);\n\n    // Filter down the events, to make sure they don't go off the screen\n    this.data.nodes.map((node) => {\n      if (node.temporal > this.maxDate) {\n        node.continuing = true;\n        node.temporal = this.maxDate;\n      } else if (node.temporal < this.minDate) {\n        node.continuing = true;\n        node.temporal = this.minDate;\n      }\n    });\n\n    // Let's draw a box around the selectHandler selection\n    const focusedIndividual = this.svg.selectAll<SVGRectElement, BaseType>('.selected')\n      .data(this.data.nodes\n          .filter((node) => node.entity === this.selectedIndividual),\n        (d: IEventElement) => d.entity);\n\n    // Calculate bin height\n    const binHeight = y(1) - y(2);\n\n    focusedIndividual\n      .enter()\n      .append('rect')\n      .attr('class', 'selected')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin + 1) + (binHeight / 2))\n      .attr('height', binHeight)\n      .attr('width', () => x(this.maxDate) + 120)\n      .attr('fill', '#FAFAD2')\n      .attr('opacity', '0.7')\n      .merge(focusedIndividual);\n\n    focusedIndividual\n      .exit()\n      .remove();\n\n    //    Add the lines\n    const links = this.svg\n      .selectAll<SVGLineElement, BaseType>('.link')\n      .data(this.data.links, (link: IEventLink) => link.source.id + '_' + link.target.id);\n\n    links\n      .enter()\n      .append('line')\n      .attr('class', 'link')\n      .attr('x1', (d) => x(d.source.temporal))\n      .attr('y1', (d) => y(d.source.bin) || null)\n      .attr('x2', (d) => x(d.target.temporal))\n      .attr('y2', (d) => y(d.target.bin) || null)\n      .merge(links);\n\n    links\n      .exit()\n      .remove();\n\n    //    Add the nodes to the graph\n    const nodes = this.svg\n      .selectAll<SVGCircleElement, BaseType>('.node')\n      .data(this.data.nodes, (data: IEventElement) => data.id);\n\n    nodes\n      .enter()\n      .append('circle')\n      .attr('class', 'node')\n      .attr('cx', (d) => x(d.temporal))\n      .attr('cy', (d) => y(d.bin) || null)\n      .attr('r', 9)\n      .attr('name', (d) => d.bin)\n      .attr('node-id', (d) => d.id)\n      .attr('entity', (d) => d.entity)\n      .style('fill', (d: IEventElement) => z(d.entity))\n      .style('opacity', (d) => d.continuing ? 0.7 : 1.0)\n      .merge(nodes);\n\n    nodes\n      .exit()\n      .remove();\n\n    // Add the labels\n    const mainLabels = this.svg.selectAll<SVGTextElement, BaseType>('.entityName')\n      .data(this.data.nodes, (d: IEventElement) => d.entity);\n\n    mainLabels\n      .enter()\n      .append('text')\n      .text((d) => this.applyFilter(d))\n      .attr('class', 'entityName')\n      .attr('x', 0)\n      .attr('y', (d) => y(d.bin) || 0)\n      .attr('text-anchor', 'start')\n      .attr('dy', '.1ex')\n      .attr('font-size', '12px')\n      .merge(mainLabels);\n\n    mainLabels\n      .exit()\n      .remove();\n\n    //    Update the X-axis\n    const xSelection = this.svg.selectAll('g.x-axis');\n    if (xSelection.empty()) {\n      this.svg\n        .append('g')\n        .attr('class', 'axis x-axis')\n        .attr('transform', 'translate(0,' + this.height + ')')\n        .call(axisBottom(x));\n    } else {\n      xSelection\n        .call(axisBottom(x));\n    }\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IEventElement | IEventLink>(this.htmlElement);\n    console.debug('Width for event graph:', this.htmlElement.offsetWidth);\n    this.margin = {top: 20, right: 30, bottom: 20, left: 20};\n    // this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    // Calculate width\n    // If the element isn't actually on the screen, then the width will be 0 which is wrong\n    // So we'll either take it from the input, or just make something up\n    if (this.graphWidth === undefined) {\n      if (this.htmlElement.offsetWidth == 0) {\n        this.width = 800 - this.margin.left - this.margin.right;\n      } else {\n        this.width = (this.htmlElement.offsetWidth) - this.margin.left - this.margin.right;\n      }\n    } else {\n      this.width = this.graphWidth - this.margin.left - this.margin.right;\n    }\n\n    this.height = this.graphHeight - this.margin.top - this.margin.bottom;\n\n    // Add the tooltip\n    this.tooltip = select('body')\n      .append('div')\n      // .style(\"position\", \"absolute\")\n      .style('z-index', '10')\n      .style('visibility', 'hidden')\n      .style('background', 'steelblue')\n      .text('a simple tooltip');\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    console.debug('Event Graph Initialized');\n  }\n\n  /**\n   * Apply the filter function, if it exists, otherwise, return the entity as the label\n   * @param {IEventElement} input\n   * @returns {string}\n   */\n  private applyFilter = (input: IEventElement): string => {\n    if (this.filterLabel) {\n      return this.filterLabel(input);\n    } else {\n      return input.entity;\n    }\n  };\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ":host >>> .node circle {\n  stroke: #999;\n  stroke-width: 3px;\n}\n\n:host >>> .node text {\n  font: 12px sans-serif;\n  pointer-events: none;\n  color: black;\n}\n\n:host >>> .link {\n  stroke: #999;\n  stroke-width: 2px;\n  stroke-opacity: 0.6;\n}\n",
                    "styleUrl": "./event-graph.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 49,
                "modifierKind": [
                    114
                ]
            },
            "implements": [
                "AfterViewInit",
                "OnChanges"
            ],
            "templateData": "<div #tooltip></div>\n<div #graph></div>"
        },
        {
            "name": "ExporterComponent",
            "id": "component-ExporterComponent-a8596a9437f298269896bff17cd3c4fb",
            "file": "src/main/webapp/src/app/explore/exporter/exporter.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "data-exporter",
            "styleUrls": [
                "./exporter.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./exporter.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "dataExport",
                    "line": 20,
                    "type": "IDataExport[]"
                },
                {
                    "name": "label",
                    "defaultValue": "true",
                    "line": 21
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "loading",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "options",
                    "type": "literal type[]",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedValue",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "click",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 45,
                    "description": "<p>Click handler to export given dataset objects</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "handleChange",
                    "args": [
                        {
                            "name": "change",
                            "type": "MatSelectChange"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 38,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "change",
                            "type": "MatSelectChange",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, Input} from '@angular/core';\nimport {ExporterService} from './exporter.service';\nimport {forkJoin} from 'rxjs';\nimport {finalize} from 'rxjs/operators';\nimport {saveAs} from \"file-saver\";\nimport {MatSelectChange} from '@angular/material/select';\n\nexport interface IDataExport {\n  dataset: string;\n  individuals: string[];\n}\n\n@Component({\n  selector: 'data-exporter',\n  templateUrl: './exporter.component.html',\n  styleUrls: ['./exporter.component.scss']\n})\nexport class ExporterComponent {\n\n  @Input() public dataExport: IDataExport[];\n  @Input() public label = true;\n  public options: { value: string, viewValue: string }[];\n  public selectedValue: string;\n  public loading: boolean;\n\n  public constructor(private es: ExporterService) {\n    this.options = [\n      {value: 'SHAPEFILE', viewValue: 'Shapefile'},\n      {value: 'GEOJSON', viewValue: 'GeoJson'},\n      {value: 'KML', viewValue: 'KML'},\n      {value: 'KMZ', viewValue: 'KMZ'}\n      // {value: \"TOPOJSON\", viewValue: \"TopoJSON\"}\n    ];\n    this.selectedValue = this.options[0].value;\n    this.loading = false;\n  }\n\n  public handleChange(change: MatSelectChange): void {\n    this.selectedValue = change.value;\n  }\n\n  /**\n   * Click handler to export given dataset objects\n   */\n  public click(): void {\n    console.debug('Clicked export', this.dataExport);\n    // If the input is undefined, or there are not individuals, skip\n    if ((this.dataExport !== undefined)) {\n      this.loading = true;\n\n      const exportArray = this.dataExport\n        .filter((de) => de.individuals.length > 0)\n        .map((de) => {\n          return this.es.exportIndividuals({\n            dataset: de.dataset,\n            individuals: de.individuals,\n            type: this.selectedValue\n          });\n        });\n      forkJoin(exportArray)\n        .pipe(finalize(() => this.loading = false))\n        .subscribe((exports) => {\n          exports.forEach((data) => {\n            console.debug('exported data:', data);\n            let fileName = '';\n            switch (this.selectedValue) {\n              case 'GEOJSON': {\n                fileName = 'trestle.json';\n                break;\n              }\n              case 'KML': {\n                fileName = 'trestle.kml';\n                break;\n              }\n              case 'KMZ': {\n                fileName = 'trestle.kmz';\n                break;\n              }\n              default: {\n                fileName = 'trestle.zip';\n                break;\n              }\n            }\n            saveAs(data, fileName);\n          });\n        });\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".horizontal {\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  justify-content: space-around;\n}\n",
                    "styleUrl": "./exporter.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "es",
                        "type": "ExporterService"
                    }
                ],
                "line": 24,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "es",
                        "type": "ExporterService",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "templateData": "<div class=\"horizontal\">\n    <h6 *ngIf=\"label\">Export:</h6>\n    <form>\n        <mat-form-field>\n            <mat-select placeholder=\"Format\" (selectionChange)=\"handleChange($event)\" name=\"type\">\n                <mat-option *ngFor=\"let option of options\" [value]=\"option.value\">\n                    {{option.viewValue}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n    </form>\n    <button mat-raised-button (click)=\"click()\">EXPORT</button>\n</div>\n<div [hidden]=\"!loading\">\n    <mat-progress-bar\n            [color]=\"'primary'\"\n            [mode]=\"'indeterminate'\">\n    </mat-progress-bar>\n</div>\n"
        },
        {
            "name": "FactTableComponent",
            "id": "component-FactTableComponent-a5986743de6ed0843f78bb145ce52262",
            "file": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "visualize-fact-table",
            "styleUrls": [
                "./fact-table.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./fact-table.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "facts",
                    "line": 23,
                    "type": "TrestleFact[]"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "columnsToDisplay",
                    "defaultValue": "[\"name\", \"type\", \"value\", \"from\", \"to\"]",
                    "type": "[]",
                    "optional": false,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "data",
                    "defaultValue": "[]",
                    "type": "TrestleFact[][]",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "dialogRef",
                    "type": "MatDialogRef<IndividualValueDialog> | null",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "expandedElement",
                    "type": "TrestleFact | null",
                    "optional": false,
                    "description": "",
                    "line": 25
                }
            ],
            "methodsClass": [
                {
                    "name": "groupData",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 60,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 40,
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 36
                },
                {
                    "name": "openValueModal",
                    "args": [
                        {
                            "name": "fact",
                            "type": "TrestleFact"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 51,
                    "description": "<p>Open the value Modal and display the given fact value</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1640,
                                "end": 1644,
                                "flags": 0,
                                "escapedText": "fact"
                            },
                            "type": "TrestleFact",
                            "tagName": {
                                "pos": 1620,
                                "end": 1625,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1626,
                                "end": 1639,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1627,
                                    "end": 1638,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1627,
                                        "end": 1638,
                                        "flags": 2097152,
                                        "escapedText": "TrestleFact"
                                    }
                                }
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges, ViewContainerRef} from '@angular/core';\nimport {animate, state, style, transition, trigger} from '@angular/animations';\nimport {TrestleFact} from \"../../../../shared/individual/TrestleIndividual/trestle-fact\";\nimport {MatDialog, MatDialogConfig, MatDialogRef} from \"@angular/material/dialog\";\nimport {IndividualValueDialog} from \"../../individual-value.dialog\";\nimport {filter, flow, groupBy, mapValues, orderBy} from 'lodash/fp';\n\n@Component({\n  selector: 'visualize-fact-table',\n  templateUrl: './fact-table.component.html',\n  styleUrls: ['./fact-table.component.scss'],\n  animations: [\n    trigger('detailExpand', [\n      state('collapsed', style({height: '0px', minHeight: '0'})),\n      state('expanded', style({height: '*'})),\n      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),\n    ]),\n  ],\n})\nexport class FactTableComponent implements OnInit, OnChanges {\n\n  @Input()\n  facts: TrestleFact[];\n  columnsToDisplay = [\"name\", \"type\", \"value\", \"from\", \"to\"];\n  expandedElement: TrestleFact | null;\n  data: TrestleFact[][] = [];\n  private dialogRef: MatDialogRef<IndividualValueDialog> | null;\n\n\n  constructor(\n    private dialog: MatDialog,\n    private viewContainerRef: ViewContainerRef) {\n    this.groupData();\n  }\n\n  ngOnInit(): void {\n    this.groupData();\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this.facts = changes[\"facts\"].currentValue;\n    this.groupData();\n    // This is where we should call refresh on the table.\n  }\n\n\n  /**\n   * Open the value Modal and display the given fact value\n   * @param {TrestleFact} fact\n   */\n  public openValueModal(fact: TrestleFact): void {\n    const config = new MatDialogConfig();\n    config.viewContainerRef = this.viewContainerRef;\n    this.dialogRef = this.dialog.open(IndividualValueDialog, config);\n    this.dialogRef.componentInstance.name = fact.getName();\n    this.dialogRef.componentInstance.value = fact.getValue();\n    this.dialogRef.afterClosed().subscribe(() => this.dialogRef = null);\n  }\n\n  private groupData() {\n    const d = flow(\n      // Eventually we'll want to remove this filter, but it's good enough for now.\n      filter((f: TrestleFact) => f.getDatabaseTemporal().isContinuing()),\n      groupBy((x: TrestleFact) => x.getName()),\n      mapValues((v: TrestleFact[]) => orderBy(v => v.getDatabaseTemporal().getFrom(), \"desc\", v)),\n      mapValues((v: TrestleFact[]) => orderBy(v => v.getValidTemporal().getFrom(), \"desc\", v)),\n    )(this.facts);\n    this.data = Object.values(d);\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "table {\n  width: 100%;\n}\n\ntr.example-detail-row {\n  height: 0;\n}\n\ntr.example-element-row:not(.example-expanded-row):hover {\n  background: whitesmoke;\n}\n\ntr.example-element-row:not(.example-expanded-row):active {\n  background: #efefef;\n}\n\n.example-element-row td {\n  border-bottom-width: 0;\n}\n\n.example-element-detail {\n  overflow: hidden;\n  display: flex;\n}\n\n.example-element-diagram {\n  min-width: 80px;\n  border: 2px solid black;\n  padding: 8px;\n  font-weight: lighter;\n  margin: 8px 0;\n  height: 104px;\n}\n\n.example-element-symbol {\n  font-weight: bold;\n  font-size: 40px;\n  line-height: normal;\n}\n\n.example-element-description {\n  padding: 16px;\n}\n\n.example-element-description-attribution {\n  opacity: 0.5;\n}\n\n.cell-truncated {\n  background-color: indianred;\n  opacity: 60%;\n  text-align: center;\n}\n",
                    "styleUrl": "./fact-table.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "dialog",
                        "type": "MatDialog"
                    },
                    {
                        "name": "viewContainerRef",
                        "type": "ViewContainerRef"
                    }
                ],
                "line": 27,
                "jsdoctags": [
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "viewContainerRef",
                        "type": "ViewContainerRef",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<table mat-table [dataSource]=\"data\" multiTemplateDataRows class=\"mat-elevation-z6\">\n  <ng-container matColumnDef=\"name\">\n    <th mat-header-cell *matHeaderCellDef>Name</th>\n    <td mat-cell *matCellDef=\"let fact\">{{fact[0].getName()}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"type\">\n    <th mat-header-cell *matHeaderCellDef>Type</th>\n    <td mat-cell *matCellDef=\"let fact\">{{fact[0].getType()}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"value\">\n    <th mat-header-cell *matHeaderCellDef>Value</th>\n    <td mat-cell *matCellDef=\"let fact\"\n        [className]=\"fact[0].getValue().length > 200 ? 'cell-truncated mat-cell' : 'mat-cell'\"\n        (click)=\"openValueModal(fact[0])\">{{fact[0].getValue().length > 200 ? '...' : fact[0].getValue()}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"from\">\n    <th mat-header-cell *matHeaderCellDef>From</th>\n    <td mat-cell *matCellDef=\"let fact\">{{fact[0].getValidTemporal().getFrom()}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"to\">\n    <th mat-header-cell *matHeaderCellDef>To</th>\n    <td mat-cell *matCellDef=\"let fact\">{{fact[0].getValidTemporal().getTo()}}</td>\n  </ng-container>\n\n  <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\n  <ng-container matColumnDef=\"expandedDetail\">\n    <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\n      <div class=\"example-element-detail\"\n           [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\n        <div>\n          <table mat-table [dataSource]=\"element.slice(1)\" multiTemplateDataRows>\n            <ng-container matColumnDef=\"name\">\n              <th mat-header-cell *matHeaderCellDef>Name</th>\n              <td mat-cell *matCellDef=\"let fact\">{{fact.getName()}}</td>\n            </ng-container>\n            <ng-container matColumnDef=\"type\">\n              <th mat-header-cell *matHeaderCellDef>Type</th>\n              <td mat-cell *matCellDef=\"let fact\">{{fact.getType()}}</td>\n            </ng-container>\n\n            <ng-container matColumnDef=\"value\">\n              <th mat-header-cell *matHeaderCellDef>Value</th>\n              <td mat-cell *matCellDef=\"let fact\"\n                  [className]=\"fact.getValue().length > 200 ? 'cell-truncated mat-cell' : 'mat-cell'\"\n                  (click)=\"openValueModal(fact[0])\">{{fact.getValue().length > 200 ? '...' : fact.getValue()}}</td>\n            </ng-container>\n\n            <ng-container matColumnDef=\"from\">\n              <th mat-header-cell *matHeaderCellDef>From</th>\n              <td mat-cell *matCellDef=\"let fact\">{{fact.getValidTemporal().getFrom()}}</td>\n            </ng-container>\n\n            <ng-container matColumnDef=\"to\">\n              <th mat-header-cell *matHeaderCellDef>To</th>\n              <td mat-cell *matCellDef=\"let fact\">{{fact.getValidTemporal().getTo()}}</td>\n            </ng-container>\n            <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\">\n            </tr>\n          </table>\n        </div>\n      </div>\n    </td>\n  </ng-container>\n\n  <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\n  <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\"\n      class=\"example-element-row\"\n      [class.example-expanded-row]=\"expandedElement === element\"\n      (click)=\"expandedElement = expandedElement === element ? null : element\">\n  </tr>\n  <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"example-detail-row\"></tr>\n</table>\n"
        },
        {
            "name": "HeaderComponent",
            "id": "component-HeaderComponent-246e2a69dc126a3bd76c6328dd3b93e2",
            "file": "src/stories/header.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "storybook-header",
            "styleUrls": [
                "./header.css"
            ],
            "styles": [],
            "template": "<header>    <div class=\"wrapper\">\n      <div>\n        <svg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M10 0h12a10 10 0 0110 10v12a10 10 0 01-10 10H10A10 10 0 010 22V10A10 10 0 0110 0z\"\n              fill=\"#FFF\"\n            />\n            <path\n              d=\"M5.3 10.6l10.4 6v11.1l-10.4-6v-11zm11.4-6.2l9.7 5.5-9.7 5.6V4.4z\"\n              fill=\"#555AB9\"\n            />\n            <path\n              d=\"M27.2 10.6v11.2l-10.5 6V16.5l10.5-6zM15.7 4.4v11L6 10l9.7-5.5z\"\n              fill=\"#91BAF8\"\n            />\n          </g>\n        </svg>\n        <h1>Acme</h1>\n      </div>\n      <div>\n        <storybook-button\n          *ngIf=\"user\"\n          size=\"small\"\n          (onClick)=\"onLogout.emit($event)\"\n          label=\"Log out\"\n        ></storybook-button>\n        <storybook-button\n          *ngIf=\"!user\"\n          size=\"small\"\n          (onClick)=\"onLogin.emit($event)\"\n          label=\"Log in\"\n        ></storybook-button>\n        <storybook-button\n          *ngIf=\"!user\"\n          primary\n          size=\"small\"\n          (onClick)=\"onCreateAccount.emit($event)\"\n          label=\"Sign up\"\n        ></storybook-button>\n      </div>\n    </div>\n  </header>",
            "templateUrl": [],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "user",
                    "defaultValue": "null",
                    "line": 53,
                    "type": "unknown"
                }
            ],
            "outputsClass": [
                {
                    "name": "onCreateAccount",
                    "defaultValue": "new EventEmitter<Event>()",
                    "line": 62,
                    "type": "EventEmitter"
                },
                {
                    "name": "onLogin",
                    "defaultValue": "new EventEmitter<Event>()",
                    "line": 56,
                    "type": "EventEmitter"
                },
                {
                    "name": "onLogout",
                    "defaultValue": "new EventEmitter<Event>()",
                    "line": 59,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'storybook-header',\n  template: `<header>\n    <div class=\"wrapper\">\n      <div>\n        <svg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M10 0h12a10 10 0 0110 10v12a10 10 0 01-10 10H10A10 10 0 010 22V10A10 10 0 0110 0z\"\n              fill=\"#FFF\"\n            />\n            <path\n              d=\"M5.3 10.6l10.4 6v11.1l-10.4-6v-11zm11.4-6.2l9.7 5.5-9.7 5.6V4.4z\"\n              fill=\"#555AB9\"\n            />\n            <path\n              d=\"M27.2 10.6v11.2l-10.5 6V16.5l10.5-6zM15.7 4.4v11L6 10l9.7-5.5z\"\n              fill=\"#91BAF8\"\n            />\n          </g>\n        </svg>\n        <h1>Acme</h1>\n      </div>\n      <div>\n        <storybook-button\n          *ngIf=\"user\"\n          size=\"small\"\n          (onClick)=\"onLogout.emit($event)\"\n          label=\"Log out\"\n        ></storybook-button>\n        <storybook-button\n          *ngIf=\"!user\"\n          size=\"small\"\n          (onClick)=\"onLogin.emit($event)\"\n          label=\"Log in\"\n        ></storybook-button>\n        <storybook-button\n          *ngIf=\"!user\"\n          primary\n          size=\"small\"\n          (onClick)=\"onCreateAccount.emit($event)\"\n          label=\"Sign up\"\n        ></storybook-button>\n      </div>\n    </div>\n  </header>`,\n  styleUrls: ['./header.css'],\n})\nexport default class HeaderComponent {\n  @Input()\n  user: unknown = null;\n\n  @Output()\n  onLogin = new EventEmitter<Event>();\n\n  @Output()\n  onLogout = new EventEmitter<Event>();\n\n  @Output()\n  onCreateAccount = new EventEmitter<Event>();\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".wrapper {\n  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n  padding: 15px 20px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\nsvg {\n  display: inline-block;\n  vertical-align: top;\n}\n\nh1 {\n  font-weight: 900;\n  font-size: 20px;\n  line-height: 1;\n  margin: 6px 0 6px 10px;\n  display: inline-block;\n  vertical-align: top;\n}\n\nbutton + button {\n  margin-left: 10px;\n}\n",
                    "styleUrl": "./header.css"
                }
            ],
            "stylesData": ""
        },
        {
            "name": "HistoryGraphComponent",
            "id": "component-HistoryGraphComponent-caf45312bb04768d43ef7bd188e9014e",
            "file": "src/main/webapp/src/app/ui/history-graph/history-graph.component.ts",
            "encapsulation": [
                "ViewEncapsulation.None"
            ],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "history-graph",
            "styleUrls": [
                "./history-graph.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./history-graph.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "data",
                    "line": 33,
                    "type": "IIndividualHistory"
                },
                {
                    "name": "graphHeight",
                    "line": 34,
                    "type": "number"
                },
                {
                    "name": "maxTime",
                    "line": 36,
                    "type": "Date"
                },
                {
                    "name": "minTime",
                    "line": 35,
                    "type": "Date"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "dataChanges",
                    "type": "BehaviorSubject<IIndividualHistory | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 44,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "element",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'graph'"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "height",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 41,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "host",
                    "type": "Selection<HTMLElement | ITemporalEntity | BaseType | ITemporalEntity>",
                    "optional": false,
                    "description": "",
                    "line": 38,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "htmlElement",
                    "type": "HTMLElement",
                    "optional": false,
                    "description": "",
                    "line": 37,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "margin",
                    "type": "ID3Margin",
                    "optional": false,
                    "description": "",
                    "line": 42,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "svg",
                    "type": "Selection<BaseType | ITemporalEntity | BaseType | ITemporalEntity>",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "width",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 40,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "x",
                    "type": "ScaleTime<number | number>",
                    "optional": false,
                    "description": "",
                    "line": 43,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "maybeDate",
                    "args": [
                        {
                            "name": "date",
                            "type": "string | Date | undefined"
                        }
                    ],
                    "optional": false,
                    "returnType": "Date",
                    "typeParameters": [],
                    "line": 169,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "date",
                            "type": "string | Date | undefined",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 50,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "literal type"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 62,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "literal type",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "normalizeAxis",
                    "args": [
                        {
                            "name": "axis",
                            "type": "\"x\" | \"y\""
                        },
                        {
                            "name": "value",
                            "type": "number"
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 192,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "axis",
                            "type": "\"x\" | \"y\"",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "value",
                            "type": "number",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "parseValue",
                    "args": [
                        {
                            "name": "value",
                            "type": "string | number"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 182,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string | number",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "plotData",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 69,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "setupD3",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 213,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChange, ViewChild, ViewEncapsulation} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs';\nimport {BaseType, select, Selection} from 'd3-selection';\nimport {scaleBand, scaleOrdinal, ScaleTime, scaleTime} from 'd3-scale';\nimport {axisBottom, axisLeft} from 'd3-axis';\nimport {schemeCategory10} from 'd3';\nimport {ID3Margin} from '../common';\nimport moment from 'moment';\nimport Base = moment.unitOfTime.Base;\n\nexport interface ITemporalEntity {\n  label: string;\n  start: Date;\n  end?: Date;\n  value: any;\n}\n\nexport interface IIndividualHistory {\n  entities: ITemporalEntity[];\n}\n\n@Component({\n  selector: 'history-graph',\n  templateUrl: './history-graph.component.html',\n  styleUrls: ['./history-graph.component.scss'],\n    encapsulation: ViewEncapsulation.None,\n})\nexport class HistoryGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('graph') public element: ElementRef;\n  @Input() public data: IIndividualHistory;\n  @Input() public graphHeight: number;\n  @Input() public minTime: Date;\n  @Input() public maxTime: Date;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, ITemporalEntity, BaseType, ITemporalEntity>;\n  private svg: Selection<BaseType, ITemporalEntity, BaseType, ITemporalEntity>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private x: ScaleTime<number, number>;\n  private dataChanges: BehaviorSubject<IIndividualHistory | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.dataChanges\n      .subscribe((value) => {\n        console.debug('Updating plot with:', this.data);\n        if (value !== undefined) {\n          this.plotData();\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const dataChange = changes['data'];\n    if (dataChange != null && (dataChange.previousValue !== dataChange.currentValue)) {\n      this.dataChanges.next(dataChange.currentValue);\n    }\n  }\n\n  private plotData(): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n\n    //    Build the domain values\n    console.debug('Building with data:', this.data);\n    const entityNames = this.data.entities.map((d) => d.label);\n    console.debug('Names:', entityNames);\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    const y = scaleBand()\n      .range([this.height, 0])\n      .domain(entityNames);\n    console.debug('Y values', y.range());\n    console.debug('Y values', y.domain());\n\n    const z = scaleOrdinal(schemeCategory10)\n      .domain(entityNames);\n\n    // Build the lane lines\n    this.svg.selectAll('.laneLine')\n      .data(this.data.entities.map((entity) => entity.label))\n      .enter().append('line')\n      .attr('class', 'laneLine')\n      .attr('x1', 0)\n      .attr('y1', (d) => y(d) || 0)\n      .attr('x2', this.width)\n      .attr('y2', (d) => y(d) || 0);\n\n    //    Build the Y-Axis\n    const ySelection = this.svg.selectAll('g.y-axis');\n    if (ySelection.empty()) {\n      this.svg\n        .append('g')\n        .attr('class', 'axis y-axis')\n        .call(axisLeft(y));\n    } else {\n      ySelection\n        .call(axisLeft(y));\n    }\n\n    // And the X-Axis\n    this.svg.select('.x-axis')\n      .call(axisBottom(this.x));\n\n    //    Add the data\n    const mainItems = this.svg.selectAll<SVGRectElement, Base>('.fact')\n      .data(this.data.entities, (entity: ITemporalEntity) => entity.label);\n\n    mainItems\n      .enter()\n      .append('rect')\n      .attr('class', 'fact')\n      .attr('x', (d) => this.normalizeAxis('x', this.x(d.start)))\n      .attr('y', (d) => y(d.label) || 0)\n      .attr('width',\n        (d) => {\n          const end = this.normalizeAxis('x',\n            this.x(this.maybeDate(d.end)));\n          const start = this.normalizeAxis('x',\n            this.x(d.start));\n          return end - start;\n        })\n      .attr('height', () => y.bandwidth())\n      // .style(\"fill\", (d: TrestleFact) => z(d.getName()))\n      .style('fill', (d) => z(d.label))\n      .style('fill-opacity', 0.7)\n      .merge(mainItems);\n\n    // Labels\n    const mainLabels = this.svg.selectAll<SVGTextElement, BaseType>('.mainLabels')\n      .data(this.data.entities, (d: ITemporalEntity) => d.label);\n\n    mainLabels\n      .enter()\n      .append('text')\n      .text((d) => HistoryGraphComponent.parseValue(d.value))\n      .attr('class', 'mainLabels')\n      .attr('x', (d) => {\n        const end = d.end;\n        const start = d.start;\n        const width = this.x(this.maybeDate(end)) - this.x(start);\n        return this.x(start) + width / 2;\n      })\n      .attr('y', (d) => (y(d.label) || 0) + y.bandwidth() - 5)\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.1ex')\n      .merge(mainLabels);\n\n    mainItems.exit().remove();\n    mainLabels.exit().remove();\n  }\n\n  private maybeDate(date: string | Date | undefined): Date {\n    if (date instanceof Date) {\n      return date;\n    }\n    if (date === undefined) {\n      return this.minTime;\n    }\n    if (date === '') {\n      return this.maxTime;\n    }\n    return new Date(date);\n  }\n\n  private static parseValue(value: string | number): string {\n    if (typeof value === 'number') {\n      return value.toString();\n    }\n    if (value.length > 20) {\n      return value.substring(0, 20) + '...';\n    }\n    return value;\n  }\n\n  private normalizeAxis(axis: 'x' | 'y', value: number): number {\n    // Normalize X Axis\n    if (axis === 'x') {\n      if (value < 0) {\n        return 0;\n      }\n      if (value > this.width) {\n        return this.width;\n      }\n      return value;\n    } else {\n      if (value < 0) {\n        return 0;\n      }\n      if (value > this.height) {\n        return this.height;\n      }\n      return value;\n    }\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, ITemporalEntity>(this.htmlElement);\n    this.margin = {top: 20, right: 30, bottom: 20, left: 150};\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = this.graphHeight - this.margin.top - this.margin.bottom;\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n\n    console.debug('D3 Initialized');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".laneLine {\n  fill: none;\n  stroke: steelblue;\n  stroke-width: 1.5px;\n}\n",
                    "styleUrl": "./history-graph.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 44
            },
            "implements": [
                "AfterViewInit",
                "OnChanges"
            ],
            "templateData": "<div #graph></div>"
        },
        {
            "name": "IndexComponent",
            "id": "component-IndexComponent-7664574c13a4b589cc99b2db716048a4",
            "file": "src/main/webapp/src/app/admin/indicies/index.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "index-root",
            "styleUrls": [
                "./index.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./index.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "dbHover",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "dbStats",
                    "type": "IIndexLeafStatistics[]",
                    "optional": false,
                    "description": "",
                    "line": 15,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "stats",
                    "type": "ICacheStatistics",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "validHover",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "validStats",
                    "type": "IIndexLeafStatistics[]",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "loadStatistics",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 77,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 24,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "openDialog",
                    "args": [
                        {
                            "name": "action",
                            "type": "\"Rebuild\" | \"Purge\""
                        },
                        {
                            "name": "object",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 42,
                    "description": "<p>Open modal to perform index maintenance</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1245,
                                "end": 1251,
                                "flags": 0,
                                "escapedText": "action"
                            },
                            "type": "\"Rebuild\" | \"Purge\"",
                            "tagName": {
                                "pos": 1217,
                                "end": 1222,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to perform</p>\n",
                            "typeExpression": {
                                "pos": 1223,
                                "end": 1244,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1224,
                                    "end": 1243,
                                    "flags": 2097152,
                                    "kind": 168,
                                    "types": [
                                        {
                                            "pos": 1224,
                                            "end": 1233,
                                            "flags": 2097152,
                                            "kind": 177,
                                            "literal": {
                                                "pos": 1224,
                                                "end": 1233,
                                                "flags": 2097152,
                                                "kind": 9,
                                                "text": "Rebuild"
                                            }
                                        },
                                        {
                                            "pos": 1235,
                                            "end": 1243,
                                            "flags": 2097152,
                                            "kind": 177,
                                            "literal": {
                                                "pos": 1235,
                                                "end": 1243,
                                                "flags": 2097152,
                                                "kind": 9,
                                                "text": "Purge"
                                            }
                                        }
                                    ]
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1286,
                                "end": 1292,
                                "flags": 0,
                                "escapedText": "object"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1271,
                                "end": 1276,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>which cache are we using</p>\n",
                            "typeExpression": {
                                "pos": 1277,
                                "end": 1285,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1278,
                                    "end": 1284,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "updateSelected",
                    "args": [
                        {
                            "name": "event",
                            "type": "string"
                        },
                        {
                            "name": "updateVariable",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 33,
                    "description": "<p>Update the currently selected triangle, in case we want to do something with it</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 990,
                                "end": 995,
                                "flags": 0,
                                "escapedText": "event"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 975,
                                "end": 980,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 981,
                                "end": 989,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 982,
                                    "end": 988,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 1019,
                                "end": 1033,
                                "flags": 0,
                                "escapedText": "updateVariable"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1004,
                                "end": 1009,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1010,
                                "end": 1018,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1011,
                                    "end": 1017,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { AfterViewInit, Component } from \"@angular/core\";\nimport { ICacheStatistics, IIndexLeafStatistics, IndexService } from \"./index.service\";\nimport { WarningDialogComponent } from \"./warning-dialog/warning-dialog-component\";\nimport {MatDialog} from '@angular/material/dialog';\n\n@Component({\n    selector: \"index-root\",\n    templateUrl: \"./index.component.html\",\n    styleUrls: [\"./index.component.scss\"]\n})\nexport class IndexComponent implements AfterViewInit {\n\n    public stats: ICacheStatistics;\n    public validStats: IIndexLeafStatistics[];\n    public dbStats: IIndexLeafStatistics[];\n    public validHover: string;\n    public dbHover: string;\n\n    public constructor(private is: IndexService, private dialog: MatDialog) {\n        this.validHover = \"\";\n        this.dbHover = \"\";\n    }\n\n    public ngAfterViewInit(): void {\n        this.loadStatistics();\n    }\n\n    /**\n     * Update the currently selected triangle, in case we want to do something with it\n     * @param {string} event\n     * @param {string} updateVariable\n     */\n    public updateSelected(event: string, updateVariable: string): void {\n        updateVariable = event;\n    }\n\n    /**\n     * Open modal to perform index maintenance\n     * @param {\"Rebuild\" | \"Purge\"} action to perform\n     * @param {string} object which cache are we using\n     */\n    public openDialog(action: \"Rebuild\" | \"Purge\", object: string): void {\n        const dialogRef = this.dialog.open(WarningDialogComponent, {\n            data: {\n                object,\n                action\n            }\n        });\n        dialogRef.afterClosed().subscribe((closed) => {\n            if (closed) {\n                console.debug(\"Closed\", closed);\n                // Rebuild the specified index\n                if (action === \"Rebuild\") {\n                    // Get the first word as the index type\n                    const indexName = object.split(\" \")[0];\n                    this.is.rebuildIndex(indexName)\n                        .subscribe(() => {\n                            console.debug(\"%s Index is rebuilt\", indexName);\n                            //    Finally, reload the data on the page\n                            this.loadStatistics();\n                        });\n                // Purge the cache, which drops the index\n                } else {\n                    const cacheName = object.split(\" \")[0];\n                    this.is.purgeCache(cacheName)\n                        .subscribe(() => {\n                            console.debug(\"%s Cache has been purged\", cacheName);\n                            //    Finally, reload the data on the page\n                            this.loadStatistics();\n                        });\n                }\n            }\n        });\n\n    }\n\n    private loadStatistics(): void {\n        this.is.getIndexStatistics()\n            .subscribe((data) => {\n                console.debug(\"Data:\", data);\n                this.stats = data;\n                this.validStats = data.validLeafStats;\n                this.dbStats = data.dbLeafStats;\n            });\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./index.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "is",
                        "type": "IndexService"
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog"
                    }
                ],
                "line": 17,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "is",
                        "type": "IndexService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "AfterViewInit"
            ],
            "templateData": "<div *ngIf=\"stats\">\n    <h4>Valid Index</h4>\n    <tree-graph #valid_graph\n                [data]=\"{maxValue: stats.maxValue, offsetValue: stats.offsetValue, leafs: stats.validLeafStats}\"\n                (hovered)=\"updateSelected($event, validHover)\"></tree-graph>\n    <button mat-raised-button color=\"accent\" (click)=\"openDialog('Rebuild', 'Valid Index')\">REBUILD INDEX</button>\n    <index-table #valid_table [data]=\"stats.validLeafStats\"></index-table>\n    <h3>DB Index</h3>\n    <tree-graph #db_graph\n                [data]=\"{maxValue: stats.maxValue, offsetValue: stats.offsetValue, leafs: stats.dbLeafStats}\"\n                (hovered)=\"updateSelected($event, dbHover)\"></tree-graph>\n    <button mat-raised-button color=\"accent\" (click)=\"openDialog('Rebuild', 'DB Index')\">REBUILD INDEX</button>\n    <index-table #db_table [data]=\"stats.dbLeafStats\"></index-table>\n    <button mat-raised-button color=\"warn\" (click)=\"openDialog('Purge', 'Object Cache')\">PURGE CACHE</button>\n</div>\n\n<div class=\"disabled_text light_gray_text\" *ngIf=\"!stats\">\n  Caching is disabled\n</div>\n"
        },
        {
            "name": "IndexTableComponent",
            "id": "component-IndexTableComponent-fe8e91ddde270ed22bf73830c8c8b17e",
            "file": "src/main/webapp/src/app/admin/indicies/index-table/index-table.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "index-table",
            "styleUrls": [
                "./index-table.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./index-table.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "data",
                    "line": 12,
                    "type": "IIndexLeafStatistics[]"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "displayedColumns",
                    "defaultValue": "[\"id\", \"binID\", \"type\", \"direction\", \"fillFactor\"]",
                    "type": "[]",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        114,
                        132
                    ]
                },
                {
                    "name": "sortedData",
                    "type": "IIndexLeafStatistics[]",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 18,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "printLeaf",
                    "args": [
                        {
                            "name": "leaf",
                            "type": "IIndexLeafStatistics"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 27,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "leaf",
                            "type": "IIndexLeafStatistics",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, Input, OnChanges, SimpleChanges } from \"@angular/core\";\nimport { IIndexLeafStatistics } from \"../index.service\";\n\n@Component({\n    selector: \"index-table\",\n    templateUrl: \"./index-table.component.html\",\n    styleUrls: [\"./index-table.component.scss\"]\n})\nexport class IndexTableComponent implements OnChanges {\n\n    @Input()\n    public data: IIndexLeafStatistics[];\n    public sortedData: IIndexLeafStatistics[];\n    public readonly displayedColumns = [\"id\", \"binID\", \"type\", \"direction\", \"fillFactor\"];\n\n    public constructor() { }\n\n    public ngOnChanges(changes: SimpleChanges): void {\n        const data = changes[\"data\"];\n        if (data.currentValue !== data.previousValue) {\n            console.debug(\"Tabling new data\");\n            this.sortedData = (data.currentValue as IIndexLeafStatistics[])\n                .sort((a, b) => a.leafID - b.leafID);\n        }\n    }\n\n    public printLeaf(leaf: IIndexLeafStatistics): void {\n        console.debug(leaf);\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".index-table {\n  width: 100%;\n  margin-top: 20px;\n  margin-bottom: 20px;\n}\n",
                    "styleUrl": "./index-table.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 14,
                "modifierKind": [
                    114
                ]
            },
            "implements": [
                "OnChanges"
            ],
            "templateData": "<table mat-table [dataSource]=\"sortedData\" class=\"mat-elevation-z1 index-table\">\n\n  <ng-container matColumnDef=\"id\">\n    <th id=\"leaf-id\" mat-header-cell *matHeaderCellDef>ID</th>\n    <td mat-cell *matCellDef=\"let leaf\">{{leaf.leafID}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"binID\">\n    <th id=\"leaf-bin-id\" mat-header-cell *matHeaderCellDef>Binary ID</th>\n    <td mat-cell *matCellDef=\"let leaf\">{{leaf.binaryID}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"type\">\n    <th idd=\"leaf-type\" mat-header-cell *matHeaderCellDef>Type</th>\n    <td mat-cell *matCellDef=\"let leaf\">{{leaf.type}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"direction\">\n    <th id=\"leaf-direction\" mat-header-cell *matHeaderCellDef>Direction</th>\n    <td mat-cell *matCellDef=\"let leaf\">{{leaf.direction}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"coordinates\">\n    <th id=\"leaf-coordinates\" mat-header-cell *matHeaderCellDef>Coordinates</th>\n    <td mat-cell *matCellDef=\"let leaf\">{{leaf.direction}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"fillFactor\">\n    <th id=\"leaf-fill\" mat-header-cell *matHeaderCellDef>Fill Factor</th>\n    <td mat-cell *matCellDef=\"let leaf\">{{leaf.records / 20}}</td>\n  </ng-container>\n\n  <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n  <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\n\n</table>\n"
        },
        {
            "name": "IndividualGraphComponent",
            "id": "component-IndividualGraphComponent-d838f5efb91e80799d08955b6677568c",
            "file": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
            "encapsulation": [
                "ViewEncapsulation.None"
            ],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "individual-graph",
            "styleUrls": [
                "./individual-graph.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./individual-graph.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "config",
                    "line": 73,
                    "type": "IIndividualConfig"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "color",
                    "type": "ScaleOrdinal<string | string>",
                    "optional": false,
                    "description": "",
                    "line": 86,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "dataChanges",
                    "type": "BehaviorSubject<IIndividualConfig | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 93,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "element",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 72,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'container'"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "factToggleName",
                    "defaultValue": "'fact-toggle'",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 75,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "forceTick",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 242,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "graphFacts",
                    "defaultValue": "true",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 77,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "graphRelations",
                    "defaultValue": "false",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 78,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "height",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 84,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "host",
                    "type": "Selection<HTMLElement | IFactNode | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 81,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "htmlElement",
                    "type": "HTMLElement",
                    "optional": false,
                    "description": "",
                    "line": 80,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "layout",
                    "type": "IGraphLayout",
                    "optional": false,
                    "description": "",
                    "line": 87,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "links",
                    "type": "Selection<BaseType | SimulationLinkDatum<IFactNode> | any | any>",
                    "optional": false,
                    "description": "",
                    "line": 88,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "margin",
                    "type": "ID3Margin",
                    "optional": false,
                    "description": "",
                    "line": 83,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "nodeClick",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 223,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "nodeMouseOut",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 234,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "nodeMouseOver",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 227,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "nodes",
                    "type": "Selection<any | IFactNode | any | any>",
                    "optional": false,
                    "description": "",
                    "line": 89,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "nodeSize",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 91,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "nodeSizeLarge",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 92,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "relationToggleName",
                    "defaultValue": "'relation-toggle'",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 76,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "simulation",
                    "type": "Simulation<IFactNode | any>",
                    "optional": false,
                    "description": "",
                    "line": 90,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "svg",
                    "type": "Selection<BaseType | IFactNode | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 82,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "width",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 85,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "buildGraph",
                    "args": [
                        {
                            "name": "config",
                            "type": "IIndividualConfig"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 253,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "config",
                            "type": "IIndividualConfig",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeGraphMembers",
                    "args": [
                        {
                            "name": "event",
                            "type": "MatSlideToggleChange"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 316,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "MatSlideToggleChange",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 99,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "literal type"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 121,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "literal type",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "parseColorGroup",
                    "args": [
                        {
                            "name": "group",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 338,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "group",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "parseIndividualID",
                    "args": [
                        {
                            "name": "id",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 353,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setupD3",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 130,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "update",
                    "args": [
                        {
                            "name": "data",
                            "type": "IGraphLayout"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 150,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "IGraphLayout",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  Input,\n  OnChanges,\n  SimpleChange,\n  ViewChild,\n  ViewEncapsulation\n} from \"@angular/core\";\nimport {BaseType, select, Selection} from \"d3-selection\";\nimport {ScaleOrdinal, scaleOrdinal} from \"d3-scale\";\nimport {schemeCategory10} from \"d3\";\nimport {\n  forceCenter,\n  forceLink,\n  forceManyBody,\n  forceSimulation,\n  Simulation,\n  SimulationLinkDatum,\n  SimulationNodeDatum\n} from \"d3-force\";\nimport * as moment from \"moment\";\nimport {TrestleIndividual} from \"../../../shared/individual/TrestleIndividual/trestle-individual\";\nimport {BehaviorSubject} from \"rxjs\";\nimport {MatSlideToggleChange} from \"@angular/material/slide-toggle\";\n\nexport interface IIndividualConfig {\n  data: TrestleIndividual;\n  validAt: moment.Moment;\n  dbAt?: moment.Moment;\n}\n\nconst enum NodeType {\n  INDIVIDUAL,\n  VTEMPORAL,\n  FACT,\n  RELATION\n}\n\ninterface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\ninterface IGraphLayout {\n  nodes: IFactNode[];\n  links: Array<SimulationLinkDatum<IFactNode>>;\n}\n\ninterface IFactNode extends SimulationNodeDatum {\n  id: string;\n  name: string;\n  valid: boolean;\n  group: number;\n}\n\n@Component({\n  selector: 'individual-graph',\n  templateUrl: './individual-graph.component.html',\n  styleUrls: ['./individual-graph.component.scss'],\n  encapsulation: ViewEncapsulation.None\n})\n\nexport class IndividualGraphComponent implements AfterViewInit, OnChanges {\n\n  @ViewChild('container') public element: ElementRef;\n  @Input() public config: IIndividualConfig;\n\n  public factToggleName = 'fact-toggle';\n  public relationToggleName = 'relation-toggle';\n  public graphFacts = true;\n  public graphRelations = false;\n\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IFactNode, null, undefined>;\n  private svg: Selection<BaseType, IFactNode, null, undefined>;\n  private margin: ID3Margin;\n  private height: number;\n  private width: number;\n  private color: ScaleOrdinal<string, string>;\n  private layout: IGraphLayout;\n  private links: Selection<BaseType, SimulationLinkDatum<IFactNode>, any, any>;\n  private nodes: Selection<any, IFactNode, any, any>;\n  private simulation: Simulation<IFactNode, any>;\n  private nodeSize: number;\n  private nodeSizeLarge: number;\n  private dataChanges: BehaviorSubject<IIndividualConfig | undefined>;\n\n  constructor() {\n    this.dataChanges = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    console.debug('graph view-init');\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n    //    Subscribe\n    this.dataChanges\n      .subscribe((value) => {\n        if (value !== undefined) {\n          this.buildGraph(value);\n          this.update({\n            nodes: [],\n            links: [],\n          });\n          this.update(this.layout);\n        }\n      });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const configChange = changes['config'];\n    console.debug('Changed', configChange);\n    if (configChange.currentValue !== configChange.previousValue) {\n      console.debug('Config changed', configChange);\n      this.dataChanges.next(configChange.currentValue);\n    }\n  }\n\n  private setupD3() {\n    this.host = select<HTMLElement, IFactNode>(this.htmlElement);\n    this.margin = {top: 10, right: 20, bottom: 10, left: 10};\n    console.debug('offsetWidth', this.htmlElement.offsetWidth);\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n    this.nodeSize = this.width / 75;\n    this.nodeSizeLarge = this.width / 50;\n    console.debug('Creating D3 graph with width/height', this.width + '/' + this.height);\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    this.color = scaleOrdinal(schemeCategory10);\n    console.debug('D3 initialized');\n  }\n\n  private update(data: IGraphLayout): void {\n    console.debug('Data in update function', data);\n    const force = forceManyBody();\n    force.strength(-1000);\n    this.simulation = forceSimulation<IFactNode>()\n      .force('link', forceLink().id((d: IFactNode) => d.id))\n      .force('charge', force)\n      .force('center', forceCenter(this.width / 2, this.height / 2));\n\n    const linkData = this.svg.selectAll('.link')\n      .data(data.links, (d: any) => d.source.id + '_' + d.target.id);\n\n    this.links = linkData.enter()\n      .append('line')\n      .attr('class', 'link');\n\n    const nodeData = this.svg.selectAll('.node')\n      .data(data.nodes, (d: IFactNode) => d.id);\n\n    this.nodes = nodeData\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .on('click', this.nodeClick)\n      .on('mouseover', this.nodeMouseOver)\n      .on('mouseout', this.nodeMouseOut);\n\n    this.nodes\n      .append('circle')\n      .attr('r', this.nodeSize)\n      .style('fill', (d) => this.color(d.group.toString(10)))\n      .style('opacity', (d) => d.valid ? 1.0 : 0.5);\n\n    this.nodes\n      .append('text')\n      .attr('x', 16)\n      .attr('dy', '.35em')\n      .text((d) => d.name);\n\n    //    Legend\n    const legend = this.svg.selectAll('.legend')\n      .data(this.color.domain())\n      .enter()\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', (d, i) => 'translate(0,' + (i * ((this.nodeSize) * 2) + 20) + ')');\n\n    legend.append('circle')\n      .attr('cx', this.width - 18)\n      .attr('r', this.nodeSize)\n      .attr('cy', this.nodeSize)\n      .style('fill', this.color);\n\n    legend\n      .append('text')\n      .attr('x', this.width - (this.nodeSize) * 2 - 12)\n      .attr('y', this.nodeSize)\n      .attr('dy', '0.35em')\n      .style('text-anchor', 'end')\n      .text((d) => IndividualGraphComponent.parseColorGroup(d));\n    // Force setup\n    this.simulation\n      .nodes(data.nodes)\n      .on('tick', this.forceTick);\n\n    // For some reason, the links() function doesn't exist on the simulation type, so we do a simple cast to get around it.\n    // Seems to work, and the only other option is to lose all type checking for the simulation object\n    (this.simulation.force('link') as any).links(data.links);\n\n    linkData.exit().remove();\n    nodeData.exit().remove();\n  }\n\n  private nodeClick = (d: IFactNode): void => {\n    console.debug('Clicked', d);\n  };\n\n  private nodeMouseOver = (event: any): void => {\n    select(event.currentTarget).select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSizeLarge);\n  };\n\n  private nodeMouseOut = (event: any): void => {\n    select(event.currentTarget)\n      .select('circle')\n      .transition()\n      .duration(750)\n      .attr('r', this.nodeSize);\n  };\n\n  private forceTick = (): void => {\n    this.nodes\n      .attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')');\n\n    this.links\n      .attr('x1', (d: any) => d.source.x)\n      .attr('y1', (d: any) => d.source.y)\n      .attr('x2', (d: any) => d.target.x)\n      .attr('y2', (d: any) => d.target.y);\n  };\n\n  private buildGraph(config: IIndividualConfig): void {\n    const individual = config.data;\n    this.layout = {\n      nodes: [],\n      links: []\n    };\n\n    //    Add the selection as node 0\n    const individualNode = {\n      id: individual.getID(),\n      name: IndividualGraphComponent.parseIndividualID(individual.getID()),\n      valid: true,\n      group: NodeType.INDIVIDUAL\n    };\n\n    const individualTemporal = {\n      id: individual.getTemporal().getID(),\n      name: 'selection-temporal',\n      valid: true,\n      group: NodeType.VTEMPORAL\n    };\n\n    this.layout.nodes.push(individualNode, individualTemporal);\n\n    this.layout.links.push({\n      source: individualNode,\n      target: individualTemporal\n    });\n\n    if (this.graphFacts) {\n      individual.getFacts().forEach(fact => {\n        const factNode = {\n          id: fact.getID(),\n          name: fact.getName(),\n          valid: fact.isActive(config.validAt, config.dbAt),\n          group: NodeType.FACT\n        };\n        this.layout.nodes.push(factNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: factNode\n        });\n      });\n    }\n\n    //    Relations\n    if (this.graphRelations) {\n      individual.getRelations().forEach(relation => {\n        const relationNode = {\n          id: relation.getObject(),\n          name: relation.getType().toString() + ': ' + IndividualGraphComponent.parseIndividualID(relation.getObject()),\n          valid: true,\n          group: NodeType.RELATION\n        };\n        this.layout.nodes.push(relationNode);\n        this.layout.links.push({\n          source: individualNode,\n          target: relationNode\n        });\n      });\n    }\n  }\n\n  public changeGraphMembers(event: MatSlideToggleChange): void {\n    if (event.source.id === this.factToggleName) {\n      console.debug('Graph facts?', event.checked);\n      this.graphFacts = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    } else if (event.source.id === this.relationToggleName) {\n      console.debug('Graph relations?', event.checked);\n      this.graphRelations = event.checked;\n      this.buildGraph(this.config);\n      this.update({\n        nodes: [],\n        links: [],\n      });\n      this.update(this.layout);\n    }\n  }\n\n  private static parseColorGroup(group: string): string {\n    switch (parseInt(group, 10)) {\n      case 0:\n        return 'Individual';\n      case 1:\n        return 'Valid Temporal';\n      case 2:\n        return 'Fact';\n      case 3:\n        return 'Relation';\n      default:\n        return 'unknown';\n    }\n  }\n\n  private static parseIndividualID(id: string): string {\n    const matches = id.match(/(#)(.*)/g);\n    if (matches) {\n      return matches[0].replace('#', '');\n    }\n    return id;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".node circle {\n  stroke: #999;\n  stroke-width: 3px;\n}\n\n.node text {\n  font: 12px sans-serif;\n  pointer-events: none;\n  color: black;\n}\n\n.link {\n  stroke: #999;\n  stroke-width: 2px;\n  stroke-opacity: 0.6;\n}\n\n.legend {\n  margin-bottom: 50px;\n}\n",
                    "styleUrl": "./individual-graph.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 93
            },
            "implements": [
                "AfterViewInit",
                "OnChanges"
            ],
            "templateData": "<!--<div #container class=\"container\" style=\"width: 100%\"></div>-->\n<div #container></div>\n<section>\n    <mat-slide-toggle [id]=\"factToggleName\" [checked]=\"graphFacts\" [color]=\"'accent'\" (change)=\"changeGraphMembers($event)\">Graph Facts</mat-slide-toggle>\n    <mat-slide-toggle [id]=\"relationToggleName\" [checked]=\"graphRelations\" [color]=\"'accent'\" (change)=\"changeGraphMembers($event)\">Graph Relationships</mat-slide-toggle>\n</section>"
        },
        {
            "name": "IndividualValueDialog",
            "id": "component-IndividualValueDialog-bf0e64b068ba29fd043a74abd93e972f",
            "file": "src/main/webapp/src/app/explore/visualize/individual-value.dialog.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "individual-value-dialog",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "name",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "value",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component} from '@angular/core';\n\n@Component({\n  selector: 'individual-value-dialog',\n  template: '<h3 mat-dialog-title>{{name}}</h3>' +\n    '<div mat-dialog-content>{{value}}</div> '\n})\nexport class IndividualValueDialog {\n\n  public name: string;\n  public value: string;\n\n  constructor() {\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 14
            }
        },
        {
            "name": "LoadingSpinnerComponent",
            "id": "component-LoadingSpinnerComponent-1b411a40381b06827df52a19f1891f79",
            "file": "src/main/webapp/src/app/ui/loading-spinner/loading-spinner.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "loading-spinner",
            "styleUrls": [
                "./loading-spinner.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./loading-spinner.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component} from \"@angular/core\";\n\n@Component({\n    selector: \"loading-spinner\",\n    templateUrl: \"./loading-spinner.component.html\",\n    styleUrls: [\"./loading-spinner.component.scss\"]\n})\nexport class LoadingSpinnerComponent {\n\n    public constructor() {\n    //    Not needed\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ":host {\n  position: absolute;\n  /*top: 0;*/\n  /*left: 0;*/\n  /*right: 0;*/\n  /*bottom: 0;*/\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: rgba(0,0,0,0.4);\n  color: white;\n  height: inherit;\n  width: inherit;\n\n  /*width: 100%;*/\n  /*height: 100%;*/\n  z-index: 99;\n}\n",
                    "styleUrl": "./loading-spinner.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 8,
                "modifierKind": [
                    114
                ]
            },
            "templateData": "<div class=\"wrapper\">\n    <h2>Loading!!!!</h2>\n</div>"
        },
        {
            "name": "LoginComponent",
            "id": "component-LoginComponent-b6a9028684b293f94093c8d322e3004a",
            "file": "src/main/webapp/src/app/navigation/login/login.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "login",
            "styleUrls": [
                "./login.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./login.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "errorMessage",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 40,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "errorState",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 41,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "errorSubscription",
                    "type": "Subscription",
                    "optional": false,
                    "description": "",
                    "line": 43,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "loginForm",
                    "type": "FormGroup",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "returnUrl",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 42,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "login",
                    "args": [
                        {
                            "name": "user",
                            "type": "IUserLogin"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 81,
                    "description": "<p>Attempt to login the given user</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2394,
                                "end": 2398,
                                "flags": 0,
                                "escapedText": "user"
                            },
                            "type": "IUserLogin",
                            "tagName": {
                                "pos": 2375,
                                "end": 2380,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2381,
                                "end": 2393,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2382,
                                    "end": 2392,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2382,
                                        "end": 2392,
                                        "flags": 2097152,
                                        "escapedText": "IUserLogin"
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 73,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 49,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "parseErrorMessage",
                    "args": [
                        {
                            "name": "error",
                            "type": "Error"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 85,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "error",
                            "type": "Error",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, OnDestroy, OnInit} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {FormBuilder, FormGroup, Validators} from '@angular/forms';\nimport {animate, state, style, transition, trigger} from '@angular/animations';\nimport {AuthService} from '../../user/authentication.service';\nimport {selectErrorFromUser, State} from '../../reducers';\nimport {select, Store} from '@ngrx/store';\nimport {Subscription} from 'rxjs';\nimport {login} from '../../actions/auth.actions';\nimport {HttpErrorResponse} from '@angular/common/http';\n\ninterface IUserLogin {\n  username: string;\n  password: string;\n}\n\n@Component({\n  selector: 'login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.scss'],\n  animations: [\n    trigger('errorMessage', [\n      state('inactive', style({\n        backgroundColor: 'white'\n      })),\n      state('active', style({\n        backgroundColor: 'red'\n      })),\n      transition('inactive => active', animate('100ms ease-in')),\n      transition('active => inactive', animate('100ms ease-out'))\n    ])\n  ]\n})\n\nexport class LoginComponent implements OnInit, OnDestroy {\n  public loginForm: FormGroup;\n  public errorMessage: string;\n  public errorState: string;\n  private returnUrl: string;\n  private errorSubscription: Subscription;\n\n  constructor(private fb: FormBuilder, private authService: AuthService, private route: ActivatedRoute, private router: Router, private store: Store<State>) {\n    // Not used\n  }\n\n  public ngOnInit(): void {\n\n    this.errorSubscription = this.store\n      .pipe(select(selectErrorFromUser))\n        .subscribe((result) => {\n          if (result) {\n            this.errorState = 'active';\n            this.errorMessage = LoginComponent.parseErrorMessage(result);\n          } else {\n            this.errorState = 'inactive';\n            this.errorMessage = '';\n          }\n        });\n\n    this.authService.logout();\n    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';\n    this.loginForm = this.fb.group({\n      username: [null, Validators.required],\n      password: [null, Validators.required]\n    });\n    this.errorMessage = '';\n    this.errorState = 'inactive';\n  }\n\n  public ngOnDestroy(): void {\n    this.errorSubscription.unsubscribe();\n  }\n\n  /**\n   * Attempt to login the given user\n   * @param {IUserLogin} user\n   */\n  public login(user: IUserLogin) {\n    this.store.dispatch(login({username: user.username, password: user.password, returnUrl: this.returnUrl}));\n  }\n\n  private static parseErrorMessage(error: Error): string {\n    if (error instanceof HttpErrorResponse && error.status == 401) {\n      return \"Incorrect Username or Password\";\n    }\n    return error.message;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "@mixin vertical-align($position: relative) {\n  position: $position;\n  top: 50%;\n  -webkit-transform: translateY(-50%) perspective(1px);\n  -ms-transform: translateY(-50%) perspective(1px);\n  transform: translateY(-50%) perspective(1px);\n}\n\n.login-input {\n  margin-left: 35%;\n  margin-right: 50%;\n  width: 500px;\n  top: 30%;\n  position: absolute;\n}\n\n.input-full-width {\n  width: 100%;\n}\n\n.login {\n  background-size: cover;\n  background: url(\"../../../assets/images/trestle-logo.jpg\") no-repeat;\n  height: 100vh;\n  text-align: center;\n  position: relative;\n}\n\n.login .img {\n  position: absolute;\n}\n.mat-card-footer {\n  height: 20px;\n  background-color: red;\n}\n",
                    "styleUrl": "./login.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "fb",
                        "type": "FormBuilder"
                    },
                    {
                        "name": "authService",
                        "type": "AuthService"
                    },
                    {
                        "name": "route",
                        "type": "ActivatedRoute"
                    },
                    {
                        "name": "router",
                        "type": "Router"
                    },
                    {
                        "name": "store",
                        "type": "Store<State>"
                    }
                ],
                "line": 43,
                "jsdoctags": [
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "route",
                        "type": "ActivatedRoute",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "store",
                        "type": "Store<State>",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "OnDestroy"
            ],
            "templateData": "<div class=\"login\">\n  <mat-card class=\"login-input z-depth-5\">\n    <mat-card-header>\n      <mat-card-title><h4>Login to Trestle</h4></mat-card-title>\n    </mat-card-header>\n    <form id=\"login-form\" [formGroup]=\"loginForm\" (ngSubmit)=\"login(loginForm.value)\">\n      <mat-card-content>\n        <table class=\"input-full-width\" cellspacing=\"0\">\n          <tr>\n            <td>\n              <mat-form-field class=\"input-full-width\">\n                <input matInput placeholder=\"Username\" formControlName=\"username\" name=\"username\">\n              </mat-form-field>\n            </td>\n            <td>\n              <mat-form-field class=\"input-full-width\">\n                <input type=\"password\" matInput placeholder=\"Password\" formControlName=\"password\"\n                       name=\"password\">\n              </mat-form-field>\n            </td>\n          </tr>\n        </table>\n      </mat-card-content>\n      <mat-card-actions>\n        <button mat-raised-button type=\"submit\" [disabled]=\"!loginForm.valid\">Submit</button>\n      </mat-card-actions>\n      <mat-card-footer [@errorMessage]=\"errorState\">{{errorMessage}}</mat-card-footer>\n    </form>\n  </mat-card>\n</div>\n"
        },
        {
            "name": "MetricsComponent",
            "id": "component-MetricsComponent-d0d14a44b94e5b3872fb7c182b7e9110",
            "file": "src/main/webapp/src/app/admin/metrics/metrics.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "metrics-root",
            "styleUrls": [
                "./metrics.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./metrics.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "disabled",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "exportAllMetrics",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "<p>Export all metrics as a CSV file</p>\n",
                    "line": 86,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "graph",
                    "type": "MetricsGraphComponent",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MetricsGraphComponent"
                        }
                    ],
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "loadingData",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "meters",
                    "defaultValue": "[]",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "nowTime",
                    "type": "Moment",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "oldValue",
                    "defaultValue": "''",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedData",
                    "type": "IMetricsData",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedValue",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "startTime",
                    "type": "Moment",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "upTime",
                    "type": "Duration",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "addData",
                    "args": [
                        {
                            "name": "metric",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 72,
                    "description": "<p>Add metrics data</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2215,
                                "end": 2221,
                                "flags": 0,
                                "escapedText": "metric"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 2200,
                                "end": 2205,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2206,
                                "end": 2214,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2207,
                                    "end": 2213,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "exportMetrics",
                    "args": [
                        {
                            "name": "metrics",
                            "type": "null | string[]"
                        },
                        {
                            "name": "start",
                            "type": "number"
                        },
                        {
                            "name": "end",
                            "type": "number"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 100,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "metrics",
                            "type": "null | string[]",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "start",
                            "type": "number",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "end",
                            "type": "number",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "exportVisibleMetrics",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 94,
                    "description": "<p>Export the currently selected and filtered metrics to a CSV file</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngDoCheck",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 58,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 33,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, DoCheck, OnInit, ViewChild} from '@angular/core';\nimport {saveAs} from 'file-saver';\nimport {MetricsGraphComponent} from '../metrics-graph/metrics-graph.component';\nimport {IMetricsData, MetricsService} from '../metrics-graph/metrics.service';\nimport {finalize} from 'rxjs/operators';\nimport moment, {duration, Duration, Moment} from 'moment';\n\n@Component({\n  selector: 'metrics-root',\n  templateUrl: './metrics.component.html',\n  styleUrls: ['./metrics.component.scss']\n})\n\nexport class MetricsComponent implements OnInit, DoCheck {\n  public meters: string[] = [];\n  public startTime: Moment;\n  public nowTime: Moment;\n  public upTime: Duration;\n  public selectedValue: string;\n  public oldValue = '';\n  public selectedData: IMetricsData;\n  public loadingData: boolean;\n  public disabled: boolean;\n  @ViewChild(MetricsGraphComponent) private graph: MetricsGraphComponent;\n\n  constructor(private ms: MetricsService) {\n    this.disabled = false;\n  }\n\n  public ngOnInit(): void {\n    this.ms.getMetrics()\n      .subscribe((metricsResponse) => {\n        this.meters = [];\n        Object.keys(metricsResponse.meters).forEach(key => {\n          this.meters.push(key);\n        });\n        console.debug('Uptime', metricsResponse.upTime);\n        console.debug('Startime', metricsResponse.startTime);\n        const upDuration = duration(metricsResponse.upTime);\n        console.debug('Duration', upDuration);\n        this.upTime = upDuration;\n        this.startTime = moment(metricsResponse.startTime);\n        this.nowTime = moment();\n      }, (error: Response) => {\n        // If we get a NOT_IMPLEMENTED response, that means metrics is disabled\n        if (error.status === 501) {\n          this.disabled = true;\n          console.debug('Metrician not enabled');\n        } else {\n          console.error(error);\n        }\n      });\n  };\n\n  public ngDoCheck() {\n    if (this.selectedValue !== this.oldValue) {\n      console.debug('Changed to:', this.selectedValue);\n      this.oldValue = this.selectedValue;\n      if (this.selectedValue != null) {\n        this.addData(this.selectedValue);\n      }\n    }\n  }\n\n  /**\n   * Add metrics data\n   * @param {string} metric\n   */\n  public addData(metric: string): void {\n    console.debug('Adding data:', metric);\n    this.loadingData = true;\n    this.ms.getMetricValues(metric, this.startTime.valueOf(), this.nowTime.valueOf())\n      .pipe(finalize(() => this.loadingData = false))\n      .subscribe((metricValues) => {\n        console.debug('Have metric values:', metricValues);\n        this.selectedData = metricValues;\n      });\n  }\n\n  /**\n   * Export all metrics as a CSV file\n   */\n  public exportAllMetrics = (): void => {\n    console.debug('Exporting all metrics');\n    this.exportMetrics(null, this.startTime.valueOf(), this.nowTime.valueOf());\n  };\n\n  /**\n   * Export the currently selected and filtered metrics to a CSV file\n   */\n  public exportVisibleMetrics(): void {\n    this.exportMetrics(this.graph.getVisibleMetrics(),\n      this.startTime.valueOf(),\n      this.nowTime.valueOf());\n  }\n\n  private exportMetrics(metrics: null | string[], start: number, end: number): void {\n    this.ms.exportMetricValues(metrics, start, end)\n      .subscribe((exportedBlob) => {\n        console.debug('Has blob of size: ', exportedBlob.size);\n        const fileName = 'trestle-metrics-' + start + '-' + (end || 'current') + '.csv';\n        saveAs(exportedBlob, fileName);\n      });\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".metrics-header {\n  display: flex;\n}\n.page-spacer {\n  flex: 1 1 auto;\n}\n\n.container {\n  width: 100%;\n  margin: 0;\n  max-width: 100%;\n}\n\n.mat-progress-spinner {\n  height: 30px;\n  width: 30px;\n}\n\n.mat-select {\n  width: 100%;\n}\n\n.mat-select-panel {\n  max-width: 100%;\n}\n",
                    "styleUrl": "./metrics.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "ms",
                        "type": "MetricsService"
                    }
                ],
                "line": 27,
                "jsdoctags": [
                    {
                        "name": "ms",
                        "type": "MetricsService",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "DoCheck"
            ],
            "templateData": "<div class=\"container disabled_text light_gray_text\" *ngIf=\"disabled\">\n    Metrics are currently disabled\n</div>\n<div class=\"container\" *ngIf=\"!disabled\">\n    <div class=\"section\">\n        <div class=\"metrics-header row\">\n            <span class=\"page-spacer\"></span>\n            <div *ngIf=\"startTime\">\n                Running since: {{startTime.format()}} <i>({{upTime.humanize()}})</i>\n            </div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col s8\">\n                <form>\n                    <mat-select placeholder=\"Metrics\" name=\"metrics\" [(ngModel)]=\"selectedValue\">\n                        <mat-option *ngFor=\"let meter of meters\" [value]=\"meter\">\n                            {{meter}}\n                        </mat-option>\n                    </mat-select>\n                </form>\n            </div>\n            <div class=\"col s1\">\n                <mat-progress-spinner *ngIf=\"loadingData\" [attr.color]=\"'primary'\"\n                                      [mode]=\"'indeterminate'\"></mat-progress-spinner>\n            </div>\n            <div class=\"col s3\">\n                <button mat-raised-button (click)=\"exportAllMetrics()\">Export All Metrics</button>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"section\" *ngIf=\"nowTime\">\n        <metrics-graph [data]=\"selectedData\" [minTime]=\"startTime.toDate()\"\n                       [maxTime]=\"nowTime.toDate()\"></metrics-graph>\n        <button mat-raised-button (click)=\"exportVisibleMetrics()\">Export Visible Metrics</button>\n    </div>\n</div>"
        },
        {
            "name": "MetricsGraphComponent",
            "id": "component-MetricsGraphComponent-2e6af61f3453851a2c05192ad406e122",
            "file": "src/main/webapp/src/app/admin/metrics-graph/metrics-graph.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "metrics-graph",
            "styleUrls": [
                "./metrics-graph.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./metrics-graph.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "data",
                    "line": 28,
                    "type": "IMetricsData"
                },
                {
                    "name": "maxTime",
                    "line": 30,
                    "type": "Date"
                },
                {
                    "name": "minTime",
                    "line": 29,
                    "type": "Date"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "element",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'container'"
                        }
                    ],
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "graphData",
                    "defaultValue": "[]",
                    "type": "IMetricsData[]",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "height",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 36,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "host",
                    "type": "Selection<HTMLElement | IMetricsData | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 33,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "htmlElement",
                    "type": "HTMLElement",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "legendClickHandler",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 182,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "margin",
                    "type": "ID3Margin",
                    "optional": false,
                    "description": "",
                    "line": 37,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "svg",
                    "type": "Selection<BaseType | IMetricsData | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 34,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "visible",
                    "defaultValue": "new Map()",
                    "type": "Map<string | boolean>",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "width",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 35,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "x",
                    "type": "ScaleTime<number | number>",
                    "optional": false,
                    "description": "",
                    "line": 38,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getVisibleMetrics",
                    "args": [],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 69,
                    "description": "<p>Get all metrics that aren&#39;t currently disabled</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2137,
                                "end": 2144,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "[]"
                        }
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 44,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "literal type"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 51,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "literal type",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "plotData",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 105,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "setupD3",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 79,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {AfterViewInit, Component, ElementRef, Input, OnChanges, SimpleChange, ViewChild} from '@angular/core';\nimport {BaseType, select, Selection} from 'd3-selection';\nimport {scaleLinear, scaleOrdinal, scaleTime, ScaleTime} from 'd3-scale';\nimport {curveBasis, line} from 'd3-shape';\nimport {max, min} from 'd3-array';\nimport {axisBottom, axisLeft} from 'd3-axis';\nimport {schemeCategory10} from 'd3';\nimport {IMetricsData} from './metrics.service';\n\ninterface ID3Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\n@Component({\n  selector: 'metrics-graph',\n  templateUrl: './metrics-graph.component.html',\n  styleUrls: ['./metrics-graph.component.scss']\n})\n\nexport class MetricsGraphComponent implements AfterViewInit, OnChanges {\n  @ViewChild('container') private element: ElementRef;\n  @Input() public data: IMetricsData;\n  @Input() public minTime: Date;\n  @Input() public maxTime: Date;\n  private graphData: IMetricsData[] = [];\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IMetricsData, null, undefined>;\n  private svg: Selection<BaseType, IMetricsData, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private x: ScaleTime<number, number>;\n  private visible: Map<string, boolean> = new Map();\n\n  constructor() {\n  }\n\n  public ngAfterViewInit(): void {\n    console.debug('Graph view-init');\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    const dataChange = changes['data'];\n    if (dataChange != null\n      && !dataChange.isFirstChange()\n      && (dataChange.currentValue !== dataChange.previousValue)) {\n      console.debug('Updated, plotting');\n      const currentValue: IMetricsData = changes['data'].currentValue;\n      this.graphData.push(currentValue);\n      console.debug('Adding as visible:', currentValue.metric);\n      this.visible.set(currentValue.metric, true);\n      this.plotData();\n    }\n  }\n\n  /**\n   * Get all metrics that aren't currently disabled\n   * @returns {string[]}\n   */\n  public getVisibleMetrics(): string[] {\n    const metrics = Array<string>();\n    this.visible.forEach((value, key) => {\n      if (value) {\n        metrics.push(key);\n      }\n    });\n    return metrics;\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IMetricsData>(this.htmlElement);\n    this.margin = {top: 20, right: 200, bottom: 20, left: 70};\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n    console.debug('Creating D3 graph with width/height', this.width + '/' + this.height);\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n\n    // Setup the x axis\n    this.x = scaleTime().range([0, this.width]);\n    this.x.domain([this.minTime, this.maxTime]);\n    this.svg\n      .append('g')\n      .attr('class', 'axis axis-x')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x));\n    // this.x.domain(extent(this.graphData[0].values, (d: IMetricsValue)=> d.timestamp));\n    console.debug('D3 initialized');\n\n  }\n\n  private plotData(): void {\n\n    const y = scaleLinear().range([this.height, 0]);\n    const z = scaleOrdinal(schemeCategory10);\n\n    const metricsLine = line()\n      .curve(curveBasis)\n      .x((d: any) => this.x(d.timestamp))\n      .y((d: any) => y(d.value));\n\n    // Build domain values\n    y.domain([\n      (min(this.graphData,\n        (d) => min(d.values,\n          (mv) => mv.value) || 0) || 0),\n      (max(this.graphData,\n        (d) => max(d.values,\n          (mv) => mv.value) || 0) || 0)\n    ]);\n\n    z.domain(this.graphData.map((d) => d.metric));\n    console.debug('Z-domain', z.domain());\n\n    this.svg\n      .append('g')\n      .attr('class', 'axis axis-y')\n      .call(axisLeft(y))\n      .append('text')\n      .attr('transform', 'rotate(-90)')\n      .attr('y', 6)\n      .attr('dy', '0.71em')\n      .attr('fill', '#000')\n      .text('Value');\n\n    const metric = this.svg.selectAll('.metric')\n      .data(this.graphData)\n      .enter().append('g')\n      .attr('class', 'metric');\n\n    metric\n      .append('path')\n      .attr('class', 'line')\n      .attr('id', (d) => d.metric.replace(/\\./g, '-'))\n      .attr('d', (d: any) => metricsLine(d.values))\n      // .attr(\"data-legend\", (d) => d.metric)\n      .style('stroke', (d) => z(d.metric));\n\n    //    Add the legend\n    const legend = this.svg.selectAll('.legend')\n      .data(z.domain())\n      .enter()\n      .append('g')\n      .attr('class', 'legend')\n      .attr('id', (d) => 'legend-' + d.replace(/\\./g, '-'))\n      .attr('transform',\n        (d, i) => 'translate('\n          + (this.width) + ','\n          + (i * ((this.width / 100) * 2) + 15) + ')')\n      .on('click', this.legendClickHandler);\n\n    legend\n      .append('circle')\n      .attr('cx', 30)\n      .attr('cy', 30)\n      .attr('r', this.width / 150)\n      .style('fill', z);\n\n    legend\n      .append('text')\n      .attr('x', 40)\n      .attr('y', 30)\n      .attr('dy', '0.25em')\n      .style('text-anchor', 'start')\n      .text(d => d);\n\n  }\n\n  private legendClickHandler = (d: string): void => {\n    console.debug('Clicked', d);\n    console.debug('Visible', this.visible);\n    const isVisible = this.visible.get(d);\n    console.debug('Metric: ' + d + ' is visible?', isVisible);\n    if (isVisible) {\n      console.debug('Going out');\n      this.svg.selectAll('#' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', 0);\n\n      // Fade the legend\n      this.svg.select('#legend-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', .2);\n\n      // Fade the y-axis\n      this.svg.select('#y-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', .2);\n\n      this.visible.set(d, false);\n    } else {\n      console.debug('Coming back');\n      this.svg.selectAll('#' + d.replace(/\\./g, '-'))\n        // .style(\"display\", \"block\")\n        .transition()\n        .duration(1000)\n        .style('opacity', 1);\n\n      // Fade the legend\n      this.svg.select('#legend-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', 1);\n\n      // Fade the y-axis\n      this.svg.select('#y-' + d.replace(/\\./g, '-'))\n        .transition()\n        .duration(1000)\n        .style('opacity', 1);\n\n      this.visible.set(d, true);\n    }\n  };\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ":host >>> .line {\n  fill: none;\n  stroke: steelblue;\n  stroke-width: 1.5px;\n}\n\n:host >>> .legend {\n  margin-bottom: 50px;\n}\n\n.container {\n  max-width: 100%;\n}\n",
                    "styleUrl": "./metrics-graph.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 39
            },
            "implements": [
                "AfterViewInit",
                "OnChanges"
            ],
            "templateData": "<h4>Metrics Chart</h4>\n<div #container class=\"container\" style=\"width: 100%\"></div>"
        },
        {
            "name": "NavigationComponent",
            "id": "component-NavigationComponent-bd2d2b41f400516a89c6511543e2a2df",
            "file": "src/main/webapp/src/app/navigation/navigation/navigation.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-navigation",
            "styleUrls": [
                "./navigation.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./navigation.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-navigation',\n  templateUrl: './navigation.component.html',\n  styleUrls: ['./navigation.component.scss']\n})\nexport class NavigationComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./navigation.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<p>navigation works!</p>\n"
        },
        {
            "name": "PageComponent",
            "id": "component-PageComponent-cca1a8911321fa17756ce90c90de65cc",
            "file": "src/stories/page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "storybook-page",
            "styleUrls": [
                "./page.css"
            ],
            "styles": [],
            "template": "<article>    <storybook-header\n      [user]=\"user\"\n      (onLogout)=\"onLogout.emit($event)\"\n      (onLogin)=\"onLogin.emit($event)\"\n      (onCreateAccount)=\"onCreateAccount.emit($event)\"\n    ></storybook-header>\n    <section>\n      <h2>Pages in Storybook</h2>\n      <p>\n        We recommend building UIs with a\n        <a href=\"https://componentdriven.org\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <strong>component-driven</strong>\n        </a>\n        process starting with atomic components and ending with pages.\n      </p>\n      <p>\n        Render pages with mock data. This makes it easy to build and review page states without\n        needing to navigate to them in your app. Here are some handy patterns for managing page data\n        in Storybook:\n      </p>\n      <ul>\n        <li>\n          Use a higher-level connected component. Storybook helps you compose such data from the\n          \"args\" of child component stories\n        </li>\n        <li>\n          Assemble data in the page component from your services. You can mock these services out\n          using Storybook.\n        </li>\n      </ul>\n      <p>\n        Get a guided tutorial on component-driven development at\n        <a href=\"https://www.learnstorybook.com\" target=\"_blank\" rel=\"noopener noreferrer\">\n          Learn Storybook\n        </a>\n        . Read more in the\n        <a href=\"https://storybook.js.org/docs\" target=\"_blank\" rel=\"noopener noreferrer\">\n          docs\n        </a>\n        .\n      </p>\n      <div class=\"tip-wrapper\">\n        <span class=\"tip\">Tip</span> Adjust the width of the canvas with the\n        <svg width=\"10\" height=\"10\" viewBox=\"0 0 12 12\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M1.5 5.2h4.8c.3 0 .5.2.5.4v5.1c-.1.2-.3.3-.4.3H1.4a.5.5 0 01-.5-.4V5.7c0-.3.2-.5.5-.5zm0-2.1h6.9c.3 0 .5.2.5.4v7a.5.5 0 01-1 0V4H1.5a.5.5 0 010-1zm0-2.1h9c.3 0 .5.2.5.4v9.1a.5.5 0 01-1 0V2H1.5a.5.5 0 010-1zm4.3 5.2H2V10h3.8V6.2z\"\n              id=\"a\"\n              fill=\"#999\"\n            />\n          </g>\n        </svg>\n        Viewports addon in the toolbar\n      </div>\n    </section>\n  </article>",
            "templateUrl": [],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "user",
                    "defaultValue": "null",
                    "line": 66,
                    "type": "unknown"
                }
            ],
            "outputsClass": [
                {
                    "name": "onCreateAccount",
                    "defaultValue": "new EventEmitter<Event>()",
                    "line": 75,
                    "type": "EventEmitter"
                },
                {
                    "name": "onLogin",
                    "defaultValue": "new EventEmitter<Event>()",
                    "line": 69,
                    "type": "EventEmitter"
                },
                {
                    "name": "onLogout",
                    "defaultValue": "new EventEmitter<Event>()",
                    "line": 72,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'storybook-page',\n  template: `<article>\n    <storybook-header\n      [user]=\"user\"\n      (onLogout)=\"onLogout.emit($event)\"\n      (onLogin)=\"onLogin.emit($event)\"\n      (onCreateAccount)=\"onCreateAccount.emit($event)\"\n    ></storybook-header>\n    <section>\n      <h2>Pages in Storybook</h2>\n      <p>\n        We recommend building UIs with a\n        <a href=\"https://componentdriven.org\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <strong>component-driven</strong>\n        </a>\n        process starting with atomic components and ending with pages.\n      </p>\n      <p>\n        Render pages with mock data. This makes it easy to build and review page states without\n        needing to navigate to them in your app. Here are some handy patterns for managing page data\n        in Storybook:\n      </p>\n      <ul>\n        <li>\n          Use a higher-level connected component. Storybook helps you compose such data from the\n          \"args\" of child component stories\n        </li>\n        <li>\n          Assemble data in the page component from your services. You can mock these services out\n          using Storybook.\n        </li>\n      </ul>\n      <p>\n        Get a guided tutorial on component-driven development at\n        <a href=\"https://www.learnstorybook.com\" target=\"_blank\" rel=\"noopener noreferrer\">\n          Learn Storybook\n        </a>\n        . Read more in the\n        <a href=\"https://storybook.js.org/docs\" target=\"_blank\" rel=\"noopener noreferrer\">\n          docs\n        </a>\n        .\n      </p>\n      <div class=\"tip-wrapper\">\n        <span class=\"tip\">Tip</span> Adjust the width of the canvas with the\n        <svg width=\"10\" height=\"10\" viewBox=\"0 0 12 12\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M1.5 5.2h4.8c.3 0 .5.2.5.4v5.1c-.1.2-.3.3-.4.3H1.4a.5.5 0 01-.5-.4V5.7c0-.3.2-.5.5-.5zm0-2.1h6.9c.3 0 .5.2.5.4v7a.5.5 0 01-1 0V4H1.5a.5.5 0 010-1zm0-2.1h9c.3 0 .5.2.5.4v9.1a.5.5 0 01-1 0V2H1.5a.5.5 0 010-1zm4.3 5.2H2V10h3.8V6.2z\"\n              id=\"a\"\n              fill=\"#999\"\n            />\n          </g>\n        </svg>\n        Viewports addon in the toolbar\n      </div>\n    </section>\n  </article>`,\n  styleUrls: ['./page.css'],\n})\nexport default class PageComponent {\n  @Input()\n  user: unknown = null;\n\n  @Output()\n  onLogin = new EventEmitter<Event>();\n\n  @Output()\n  onLogout = new EventEmitter<Event>();\n\n  @Output()\n  onCreateAccount = new EventEmitter<Event>();\n}\n\n// export const Page = ({ user, onLogin, onLogout, onCreateAccount }) => (\n//   <article>\n//     <Header user={user} onLogin={onLogin} onLogout={onLogout} onCreateAccount={onCreateAccount} />\n\n// );\n// Page.propTypes = {\n//   user: PropTypes.shape({}),\n//   onLogin: PropTypes.func.isRequired,\n//   onLogout: PropTypes.func.isRequired,\n//   onCreateAccount: PropTypes.func.isRequired,\n// };\n\n// Page.defaultProps = {\n//   user: null,\n// };\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "section {\n  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 24px;\n  padding: 48px 20px;\n  margin: 0 auto;\n  max-width: 600px;\n  color: #333;\n}\n\nh2 {\n  font-weight: 900;\n  font-size: 32px;\n  line-height: 1;\n  margin: 0 0 4px;\n  display: inline-block;\n  vertical-align: top;\n}\n\np {\n  margin: 1em 0;\n}\n\na {\n  text-decoration: none;\n  color: #1ea7fd;\n}\n\nul {\n  padding-left: 30px;\n  margin: 1em 0;\n}\n\nli {\n  margin-bottom: 8px;\n}\n\n.tip {\n  display: inline-block;\n  border-radius: 1em;\n  font-size: 11px;\n  line-height: 12px;\n  font-weight: 700;\n  background: #e7fdd8;\n  color: #66bf3c;\n  padding: 4px 12px;\n  margin-right: 10px;\n  vertical-align: top;\n}\n\n.tip-wrapper {\n  font-size: 13px;\n  line-height: 20px;\n  margin-top: 40px;\n  margin-bottom: 40px;\n}\n\n.tip-wrapper svg {\n  display: inline-block;\n  height: 12px;\n  width: 12px;\n  margin-right: 4px;\n  vertical-align: top;\n  margin-top: 3px;\n}\n\n.tip-wrapper svg path {\n  fill: #1ea7fd;\n}\n",
                    "styleUrl": "./page.css"
                }
            ],
            "stylesData": ""
        },
        {
            "name": "QueryComponent",
            "id": "component-QueryComponent-f31ef9f3a8557692b8fcabc278086ed0",
            "file": "src/main/webapp/src/app/explore/query/query.component.ts",
            "encapsulation": [
                "ViewEncapsulation.None"
            ],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "query-engine",
            "styleUrls": [
                "./query.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./query.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "errorMessage",
                    "defaultValue": "null",
                    "type": "string | null",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "loading",
                    "defaultValue": "false",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "prefixes",
                    "defaultValue": "\"\"",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "results",
                    "defaultValue": "null",
                    "type": "ITrestleResultSet | null",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "executeQuery",
                    "args": [
                        {
                            "name": "queryString",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 46,
                    "description": "<p>Execute SPARQL query against the databse</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1472,
                                "end": 1483,
                                "flags": 0,
                                "escapedText": "queryString"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1457,
                                "end": 1462,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1463,
                                "end": 1471,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1464,
                                    "end": 1470,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 25,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {\n    Component, ViewEncapsulation, OnInit\n} from \"@angular/core\";\nimport {QueryService, ITrestleResultSet} from \"./query.service\";\n\n@Component({\n    selector: \"query-engine\",\n    templateUrl: \"./query.component.html\",\n    styleUrls: [\"./query.component.scss\"],\n    encapsulation: ViewEncapsulation.None\n})\n\nexport class QueryComponent implements OnInit {\n\n    public prefixes: string = \"\";\n    public results: ITrestleResultSet | null = null;\n    public errorMessage: string | null = null;\n    public loading = false;\n\n    constructor(private queryService: QueryService) { }\n\n    public ngOnInit(): void {\n        this.queryService.getPrefixes()\n            .subscribe((prefixObject) => {\n                console.debug(\"has prefixObject:\", prefixObject);\n                const prefixString: string[] = [];\n                Object.keys(prefixObject).forEach(key => {\n                    console.debug(\"Key:\", key, \"Value:\", prefixObject[key]);\n                    if (key === \":\") {\n                        prefixString.push(\"BASE \", \"<\", prefixObject[key], \">\\n\");\n                    }\n                    prefixString.push(\"PREFIX \", key, \" <\", prefixObject[key], \">\\n\");\n                });\n                console.debug(\"Built string:\", prefixString.join(\"\"));\n                this.prefixes = prefixString.join(\"\");\n            });\n    }\n\n    /**\n     * Execute SPARQL query against the databse\n     * @param {string} queryString\n     */\n    public executeQuery(queryString: string) {\n        console.debug(\"Executing query:\", queryString);\n        this.loading = true;\n        this.errorMessage = null;\n        this.queryService.executeQuery(queryString)\n            .subscribe((result: ITrestleResultSet) => {\n                console.debug(\"Results:\", result);\n                this.loading = false;\n                this.results = result;\n            }, (error: Response) => {\n                console.error(error);\n                this.loading = false;\n                this.results = null;\n                this.errorMessage = error.toString();\n            });\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./query.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "queryService",
                        "type": "QueryService"
                    }
                ],
                "line": 21,
                "jsdoctags": [
                    {
                        "name": "queryService",
                        "type": "QueryService",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"section\">\n    <h4>SPARQL Editor</h4>\n    <codemirror [prefixes]=\"prefixes\" (query)=\"executeQuery($event)\"></codemirror>\n</div>\n<mat-progress-bar [color]=\"'primary'\" [mode]=\"'indeterminate'\" *ngIf=\"loading\"></mat-progress-bar>\n<div class=\"card-panel red lighten-2\" *ngIf=\"errorMessage\">\n    <!--<div *ngIf=\"errorMessage\">-->\n    {{errorMessage}}\n</div>\n<!--</div>-->\n<div class=\"divider\"></div>\n<div class=\"section\" *ngIf=\"results\">\n    <query-viewer [data]=\"results\"></query-viewer>\n</div>\n"
        },
        {
            "name": "QueryViewerComponent",
            "id": "component-QueryViewerComponent-4594e71590e5f454d382dedb678afa2c",
            "file": "src/main/webapp/src/app/explore/query/query-viewer/query-viewer.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "query-viewer",
            "styleUrls": [
                "./query-viewer.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./query-viewer.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "data",
                    "defaultValue": "{\n    rows: 0,\n    bindingNames: [],\n    results: []\n  }",
                    "line": 18,
                    "type": "ITrestleResultSet"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "dataSource",
                    "defaultValue": "new MatTableDataSource<ITrestleResultSet>([])",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "paginator",
                    "type": "MatPaginator",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatPaginator"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 35,
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 31
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges, ViewChild} from '@angular/core';\nimport {ITrestleResultSet} from '../query.service';\nimport {MatTableDataSource} from '@angular/material/table';\nimport {MatPaginator} from '@angular/material/paginator';\n\n@Component({\n  selector: 'query-viewer',\n  templateUrl: './query-viewer.component.html',\n  styleUrls: ['./query-viewer.component.scss']\n})\n\nexport class QueryViewerComponent implements OnInit, OnChanges {\n\n  @Input('data')\n  public queryData: ITrestleResultSet = {\n    rows: 0,\n    bindingNames: [],\n    results: []\n  };\n  @ViewChild(MatPaginator)\n  public paginator: MatPaginator;\n  public dataSource = new MatTableDataSource<ITrestleResultSet>([]);\n\n  constructor() {\n    // Not used\n  }\n\n  ngOnInit(): void {\n    this.dataSource.paginator = this.paginator;\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (!changes['queryData'].isFirstChange()) {\n      console.debug('Data changed to:', changes['queryData'].currentValue);\n      this.dataSource.data = changes['queryData'].currentValue.results;\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".mat-cell {\n  padding: 0 10px 0;\n}\n\n.mat-table {\n  width: 90%;\n}\n",
                    "styleUrl": "./query-viewer.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 25
            },
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<div class=\"mat-elevation-z1\">\n  <h4>Query results: {{queryData.results.length}}</h4>\n  <table mat-table [dataSource]=\"dataSource\">\n\n    <ng-container *ngFor=\"let col of queryData.bindingNames\" matColumnDef=\"{{col}}\">\n      <th mat-header-cell *matHeaderCellDef>{{col}}</th>\n      <td mat-cell *matCellDef=\"let row\">{{row.resultValues[col]}}</td>\n    </ng-container>\n\n    <tr mat-header-row *matHeaderRowDef=\"queryData.bindingNames\"></tr>\n    <tr mat-row *matRowDef=\"let row; columns: queryData.bindingNames\"></tr>\n  </table>\n  <mat-paginator [pageSizeOptions]=\"[5, 10, 20]\" showFirstLastButtons></mat-paginator>\n</div>\n"
        },
        {
            "name": "SearchComponent",
            "id": "component-SearchComponent-63c824f590c67075475daab4fe8a5968",
            "file": "src/main/webapp/src/app/ui/search/search.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "search",
            "styleUrls": [
                "./search.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./search.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "showError",
                    "defaultValue": "true",
                    "line": 17,
                    "type": "boolean"
                }
            ],
            "outputsClass": [
                {
                    "name": "selected",
                    "defaultValue": "new EventEmitter<string>()",
                    "line": 21,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "errorText",
                    "defaultValue": "''",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "individualName",
                    "defaultValue": "new FormControl()",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "options",
                    "type": "Observable<string[]>",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectHandler",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "<p>Selection handler</p>\n",
                    "line": 53,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "pos": 1571,
                            "end": 1618,
                            "flags": 0,
                            "kind": 292,
                            "atToken": {
                                "pos": 1571,
                                "end": 1572,
                                "flags": 0,
                                "kind": 57
                            },
                            "tagName": {
                                "pos": 1572,
                                "end": 1577,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "typeExpression": {
                                "pos": 1578,
                                "end": 1608,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1579,
                                    "end": 1607,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1579,
                                        "end": 1607,
                                        "flags": 2097152,
                                        "escapedText": "MatAutocompleteSelectedEvent"
                                    }
                                }
                            },
                            "name": {
                                "pos": 1609,
                                "end": 1614,
                                "flags": 0,
                                "escapedText": "event"
                            },
                            "isNameFirst": false,
                            "isBracketed": false,
                            "comment": ""
                        }
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "displayFn",
                    "args": [
                        {
                            "name": "name",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 45,
                    "description": "<p>Function to filter individual ID by extracting the suffix</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1405,
                                "end": 1409,
                                "flags": 0,
                                "escapedText": "name"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 1390,
                                "end": 1395,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1396,
                                "end": 1404,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1397,
                                    "end": 1403,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1416,
                                "end": 1423,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 26,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, Input, OnInit, Output} from '@angular/core';\nimport {MatAutocompleteSelectedEvent} from '@angular/material/autocomplete';\nimport {FormControl} from '@angular/forms';\nimport {catchError, debounceTime, switchMap, tap} from 'rxjs/operators';\nimport {Observable} from 'rxjs';\nimport {IndividualService} from '../../shared/individual/individual.service';\nimport {TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\n\n@Component({\n  selector: 'search',\n  templateUrl: './search.component.html',\n  styleUrls: ['./search.component.scss']\n})\nexport class SearchComponent implements OnInit {\n\n  @Input()\n  public showError: boolean = true;\n  public options: Observable<string[]>;\n  public individualName = new FormControl();\n  public errorText = '';\n  @Output() public selected = new EventEmitter<string>();\n\n  public constructor(private is: IndividualService) {\n  }\n\n  public ngOnInit(): void {\n    this.options = this.individualName\n      .valueChanges\n      .pipe(\n        debounceTime(400),\n        tap(() => this.errorText = ''),\n        switchMap((name) => this.is.searchForIndividual(name)\n          .pipe(\n            catchError(() => {\n              this.errorText = 'Cannot search for individual';\n              return [];\n            }))));\n  }\n\n  /**\n   * Function to filter individual ID by extracting the suffix\n   * @param {string} name\n   * @returns {string}\n   */\n  public displayFn(name: string): string {\n    return TrestleIndividual.extractSuffix(name);\n  }\n\n  /**\n   * Selection handler\n   * @param {MatAutocompleteSelectedEvent} event\n   */\n  public selectHandler = (event: MatAutocompleteSelectedEvent): void => {\n    this.selected.next(event.option.value);\n  };\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".search-form {\n  min-width: 150px;\n  /*max-width: 500px;*/\n  width: 95%;\n}\n\n.full-width {\n  width: 100%;\n}\n\n.search-error-text {\n  color: red;\n}\n\n///deep/ .mat-form-field-wrapper {\n//  padding-bottom: 0;\n//}\n",
                    "styleUrl": "./search.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "is",
                        "type": "IndividualService"
                    }
                ],
                "line": 21,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "is",
                        "type": "IndividualService",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<form class=\"search-form\">\n    <mat-form-field class=\"full-width app-input-no-underline\">\n        <input matInput placeholder=\"Search for Individual\"\n               aria-label=\"Search for Individual\"\n               [matAutocomplete]=\"auto\"\n               [formControl]=\"individualName\">\n        <mat-hint class=\"search-error-text\" *ngIf=\"showError && errorText !== ''\">{{errorText}}</mat-hint>\n        <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"selectHandler($event)\">\n            <mat-option *ngFor=\"let option of options | async\" [value]=\"option\">\n                {{displayFn(option)}}\n            </mat-option>\n        </mat-autocomplete>\n    </mat-form-field>\n</form>\n"
        },
        {
            "name": "SidebarComponent",
            "id": "component-SidebarComponent-022e4c2a097d8f02d60024e085b46305",
            "file": "src/main/webapp/src/app/navigation/sidebar/sidebar.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-sidebar",
            "styleUrls": [
                "./sidebar.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./sidebar.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "mobileQuery",
                    "type": "MediaQueryList",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mobileQueryListener",
                    "type": "function",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        112,
                        132
                    ]
                },
                {
                    "name": "Privileges",
                    "defaultValue": "Privileges",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "sideNav",
                    "type": "MatSidenav",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'sidenav'"
                        }
                    ],
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "user",
                    "type": "Observable<TrestleUser>",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 36
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 32
                },
                {
                    "name": "toggle",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<MatDrawerToggleResult>",
                    "typeParameters": [],
                    "line": 40,
                    "modifierKind": [
                        114,
                        120
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {ChangeDetectorRef, Component, OnDestroy, OnInit, ViewChild} from '@angular/core';\nimport {MediaMatcher} from '@angular/cdk/layout';\nimport {selectUserFromUser, State} from '../../reducers';\nimport {select, Store} from '@ngrx/store';\nimport {Observable} from 'rxjs';\nimport {TrestleUser, Privileges} from '../../user/trestle-user';\nimport {tap} from 'rxjs/operators';\nimport {MatDrawerToggleResult, MatSidenav} from '@angular/material/sidenav';\n\n@Component({\n  selector: 'app-sidebar',\n  templateUrl: './sidebar.component.html',\n  styleUrls: ['./sidebar.component.scss']\n})\nexport class SidebarComponent implements OnInit, OnDestroy {\n\n  // We need this in order to access the Privileges enum from the template\n  public Privileges = Privileges;\n  public user: Observable<TrestleUser>;\n  public mobileQuery: MediaQueryList;\n  private readonly mobileQueryListener: () => void;\n  @ViewChild(\"sidenav\")\n  private sideNav: MatSidenav;\n\n  constructor(changeDetectorRef: ChangeDetectorRef,\n              media: MediaMatcher, private store: Store<State>) {\n    this.mobileQuery = media.matchMedia('(max-width: 800px)');\n    this.mobileQueryListener = () => changeDetectorRef.detectChanges();\n    this.mobileQuery.addEventListener('change', this.mobileQueryListener);\n  }\n\n  ngOnInit(): void {\n    this.user = this.store.pipe(select(selectUserFromUser), tap(user => console.log(\"User: \", user)));\n  }\n\n  ngOnDestroy(): void {\n    this.mobileQuery.removeEventListener('change', this.mobileQueryListener);\n  }\n\n  public async toggle(): Promise<MatDrawerToggleResult> {\n    return this.sideNav.toggle();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".mat-sidenav {\n  width: 150px;\n}\n",
                    "styleUrl": "./sidebar.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "changeDetectorRef",
                        "type": "ChangeDetectorRef"
                    },
                    {
                        "name": "media",
                        "type": "MediaMatcher"
                    },
                    {
                        "name": "store",
                        "type": "Store<State>"
                    }
                ],
                "line": 23,
                "jsdoctags": [
                    {
                        "name": "changeDetectorRef",
                        "type": "ChangeDetectorRef",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "media",
                        "type": "MediaMatcher",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "store",
                        "type": "Store<State>",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "OnDestroy"
            ],
            "templateData": "<mat-sidenav #sidenav class=\"z-depth-3\" [mode]=\"'push'\"\n             [fixedInViewport]=\"mobileQuery.matches\" fixedTopGap=\"56\" [opened]=\"!mobileQuery.matches\">\n  <mat-nav-list *ngIf=\"user | async as user\">\n    <div id=\"user-actions\">\n      <h5 matSubheader>Explore</h5>\n      <mat-divider></mat-divider>\n      <a id=\"viewer\" mat-list-item [routerLink]=\"['explore/viewer']\" aria-label=\"dataset viewer link\">\n        <mat-icon>map</mat-icon>\n        VIEWER</a>\n      <a id=\"visualize\" mat-list-item [routerLink]=\"['explore/visualize']\" aria-label=\"visualizer link\">\n        <mat-icon>view_carousel</mat-icon>\n        VISUALIZER</a>\n      <a id=\"query\" mat-list-item [routerLink]=\"['explore/query']\" aria-label=\"query link\">\n        <mat-icon>query_builder</mat-icon>\n        QUERY</a>\n      <a id=\"compare\" mat-list-item [routerLink]=\"['explore/compare']\" aria-label=\"compare links\">\n        <mat-icon>compare</mat-icon>\n        COMPARE</a>\n      <a id=\"aggregate\" mat-list-item [routerLink]=\"['explore/aggregate']\" aria-label=\"aggregate links\">\n        <mat-icon>call_merge</mat-icon>\n        AGGREGATE</a>\n    </div>\n    <div id=\"admin-actions\" *ngIf=\"user.hasRequiredPrivileges([Privileges.ADMIN])\">\n      <mat-divider></mat-divider>\n      <h5 matSubheader>Admin</h5>\n      <mat-divider></mat-divider>\n      <a id=\"dashboard\" mat-list-item [routerLink]=\"['admin/dashboard']\" aria-label=\"dashboard link\">\n        <mat-icon>dashboard</mat-icon>\n        DASHBOARD</a>\n      <a id=\"metrics\" mat-list-item [routerLink]=\"['admin/metrics']\" aria-label=\"metrics link\">\n        <mat-icon>show_chart</mat-icon>\n        METRICS</a>\n      <a id=\"users\" mat-list-item [routerLink]=\"['admin/users']\" aria-label=\"users link\">\n        <mat-icon>supervisor_account</mat-icon>\n        USERS</a>\n    </div>\n    <div id=\"dba-actions\" *ngIf=\"user.hasRequiredPrivileges([Privileges.DBA])\">\n      <a id=\"index\" mat-list-item [routerLink]=\"['admin/index']\" aria-label=\"index link\">\n        <mat-icon>supervisor_account</mat-icon>\n        INDICIES</a>\n    </div>\n    <mat-divider></mat-divider>\n  </mat-nav-list>\n</mat-sidenav>\n"
        },
        {
            "name": "SpatialUnionComponent",
            "id": "component-SpatialUnionComponent-27d2ef04b3279f2b25d3a2d17b0af01c",
            "file": "src/main/webapp/src/app/ui/spatial-union/spatial-union.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "spatial-union",
            "styleUrls": [
                "./spatial-union.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./spatial-union.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "individual",
                    "line": 18,
                    "type": "TrestleIndividual"
                },
                {
                    "name": "maxDate",
                    "line": 22,
                    "type": "Date"
                },
                {
                    "name": "minDate",
                    "line": 20,
                    "type": "Date"
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "eventData",
                    "type": "IEventData",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "buildHistoryGraph",
                    "args": [
                        {
                            "name": "individual",
                            "type": "TrestleIndividual"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 46,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "individual",
                            "type": "TrestleIndividual",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "buildObjectEvents",
                    "args": [
                        {
                            "name": "individual",
                            "type": "TrestleIndividual"
                        },
                        {
                            "name": "entityName",
                            "type": "string"
                        },
                        {
                            "name": "relationType",
                            "type": "TrestleRelationType",
                            "optional": true
                        },
                        {
                            "name": "rootEvent",
                            "type": "IEventElement",
                            "optional": true
                        },
                        {
                            "name": "componentWith",
                            "type": "",
                            "defaultValue": "false"
                        }
                    ],
                    "optional": false,
                    "returnType": "literal type",
                    "typeParameters": [],
                    "line": 221,
                    "description": "<p>Build events for individual</p>\n",
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 9638,
                                "end": 9648,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "TrestleIndividual",
                            "tagName": {
                                "pos": 9612,
                                "end": 9617,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9618,
                                "end": 9637,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9619,
                                    "end": 9636,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 9619,
                                        "end": 9636,
                                        "flags": 2097152,
                                        "escapedText": "TrestleIndividual"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 9672,
                                "end": 9682,
                                "flags": 0,
                                "escapedText": "entityName"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 9657,
                                "end": 9662,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9663,
                                "end": 9671,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9664,
                                    "end": 9670,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 9719,
                                "end": 9731,
                                "flags": 0,
                                "escapedText": "relationType"
                            },
                            "type": "TrestleRelationType",
                            "optional": true,
                            "tagName": {
                                "pos": 9691,
                                "end": 9696,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9697,
                                "end": 9718,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9698,
                                    "end": 9717,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 9698,
                                        "end": 9717,
                                        "flags": 2097152,
                                        "escapedText": "TrestleRelationType"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 9762,
                                "end": 9771,
                                "flags": 0,
                                "escapedText": "rootEvent"
                            },
                            "type": "IEventElement",
                            "optional": true,
                            "tagName": {
                                "pos": 9740,
                                "end": 9745,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9746,
                                "end": 9761,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9747,
                                    "end": 9760,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 9747,
                                        "end": 9760,
                                        "flags": 2097152,
                                        "escapedText": "IEventElement"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 9796,
                                "end": 9809,
                                "flags": 0,
                                "escapedText": "componentWith"
                            },
                            "type": "",
                            "defaultValue": "false",
                            "tagName": {
                                "pos": 9780,
                                "end": 9785,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 9786,
                                "end": 9795,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 9787,
                                    "end": 9794,
                                    "flags": 2097152,
                                    "kind": 122
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 9818,
                                "end": 9825,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "literal type"
                        }
                    ]
                },
                {
                    "name": "filterLabel",
                    "args": [
                        {
                            "name": "input",
                            "type": "IEventElement"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 42,
                    "description": "<p>Filter individual label and only return the suffix</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1639,
                                "end": 1644,
                                "flags": 0,
                                "escapedText": "input"
                            },
                            "type": "IEventElement",
                            "tagName": {
                                "pos": 1617,
                                "end": 1622,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1623,
                                "end": 1638,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1624,
                                    "end": 1637,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1624,
                                        "end": 1637,
                                        "flags": 2097152,
                                        "escapedText": "IEventElement"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1653,
                                "end": 1660,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "invertRelationship",
                    "args": [
                        {
                            "name": "relationship",
                            "type": "\"MERGED_FROM\" | \"MERGED_INTO\" | \"SPLIT_FROM\" | \"SPLIT_INTO\""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 363,
                    "description": "<p>Invert the object relationship, because our event graphs works in reverse</p>\n",
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 15804,
                                "end": 15816,
                                "flags": 0,
                                "escapedText": "relationship"
                            },
                            "type": "\"MERGED_FROM\" | \"MERGED_INTO\" | \"SPLIT_FROM\" | \"SPLIT_INTO\"",
                            "tagName": {
                                "pos": 15736,
                                "end": 15741,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 15742,
                                "end": 15803,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 15743,
                                    "end": 15802,
                                    "flags": 2097152,
                                    "kind": 168,
                                    "types": [
                                        {
                                            "pos": 15743,
                                            "end": 15756,
                                            "flags": 2097152,
                                            "kind": 177,
                                            "literal": {
                                                "pos": 15743,
                                                "end": 15756,
                                                "flags": 2097152,
                                                "kind": 9,
                                                "text": "MERGED_FROM"
                                            }
                                        },
                                        {
                                            "pos": 15758,
                                            "end": 15772,
                                            "flags": 2097152,
                                            "kind": 177,
                                            "literal": {
                                                "pos": 15758,
                                                "end": 15772,
                                                "flags": 2097152,
                                                "kind": 9,
                                                "text": "MERGED_INTO"
                                            }
                                        },
                                        {
                                            "pos": 15774,
                                            "end": 15787,
                                            "flags": 2097152,
                                            "kind": 177,
                                            "literal": {
                                                "pos": 15774,
                                                "end": 15787,
                                                "flags": 2097152,
                                                "kind": 9,
                                                "text": "SPLIT_FROM"
                                            }
                                        },
                                        {
                                            "pos": 15789,
                                            "end": 15802,
                                            "flags": 2097152,
                                            "kind": 177,
                                            "literal": {
                                                "pos": 15789,
                                                "end": 15802,
                                                "flags": 2097152,
                                                "kind": 9,
                                                "text": "SPLIT_INTO"
                                            }
                                        }
                                    ]
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 15825,
                                "end": 15832,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<p>of inverted relationship</p>\n",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 27,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "sortEvents",
                    "args": [
                        {
                            "name": "events",
                            "type": "IEventElement[]"
                        },
                        {
                            "name": "links",
                            "type": "IEventLink[]"
                        },
                        {
                            "name": "individualID",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "IEventData",
                    "typeParameters": [],
                    "line": 156,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "events",
                            "type": "IEventElement[]",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "links",
                            "type": "IEventLink[]",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "individualID",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, Input, OnChanges, SimpleChanges } from \"@angular/core\";\nimport * as moment from \"moment\";\nimport {TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\nimport {IndividualService} from '../../shared/individual/individual.service';\nimport {IIndividualHistory} from '../history-graph/history-graph.component';\nimport {IEventData, IEventElement, IEventLink} from '../event-graph/event-graph.component';\nimport {forkJoin} from 'rxjs';\nimport {TrestleRelationType} from '../../shared/individual/TrestleIndividual/trestle-relation';\nimport {TrestleEvent} from '../../shared/individual/TrestleIndividual/trestle-event';\n\n@Component({\n    selector: \"spatial-union\",\n    templateUrl: \"./spatial-union.component.html\",\n    styleUrls: [\"./spatial-union.component.scss\"]\n})\nexport class SpatialUnionComponent implements OnChanges {\n    @Input()\n    public individual: TrestleIndividual;\n    @Input()\n    public minDate: Date;\n    @Input()\n    public maxDate: Date;\n    public eventData: IEventData;\n\n    public constructor(private vs: IndividualService) { }\n\n    public ngOnChanges(changes: SimpleChanges): void {\n        const changedData = changes[\"individual\"];\n        if (changedData !== undefined &&\n            changedData.currentValue !== changedData.previousValue) {\n            console.debug(\"has new data?\", changedData.currentValue !== changedData.previousValue);\n            this.individual = changedData.currentValue;\n            this.buildHistoryGraph(this.individual);\n        }\n    }\n\n    /**\n     * Filter individual label and only return the suffix\n     * @param {IEventElement} input\n     * @returns {string}\n     */\n    public filterLabel(input: IEventElement): string {\n        return TrestleIndividual.extractSuffix(input.entity);\n    }\n\n    private buildHistoryGraph(individual: TrestleIndividual): void {\n        console.debug(\"Individual has events\", individual.getEvents());\n        //    Get the split/merged/component relations\n        const additionalRelations = individual\n            .getRelations()\n            .filter((relation) => (relation.getType() === \"MERGED_FROM\")\n                || (relation.getType() === \"MERGED_INTO\")\n                || (relation.getType() === \"SPLIT_FROM\")\n                || (relation.getType() === \"SPLIT_INTO\")\n                || (relation.getType() === \"COMPONENT_WITH\"));\n        console.debug(\"Individual %s has relations %O\",\n            individual.getFilteredID(), additionalRelations);\n        const history: IIndividualHistory = {\n            entities: []\n        };\n        const filteredID = individual.getFilteredID();\n        history.entities.push({\n            label: filteredID,\n            start: individual.getTemporal().getFromAsDate(),\n            end: individual.getTemporal().getToAsDate(),\n            value: individual.getID()\n        });\n        // //    For all the other individuals, add them as well\n        //    Now, build the selection events\n        const individualEvents = SpatialUnionComponent.buildObjectEvents(individual, filteredID);\n        let events = individualEvents.events;\n        let links = individualEvents.links;\n\n        // Get all the related individuals, if necessary\n        // If we don't need any individuals, then just plot our own events\n        if (additionalRelations.length > 0) {\n            console.debug(\"Has some individuals:\", additionalRelations.length);\n            // Figure out what to link to.\n            let rootEvent: IEventElement;\n            const splitMergeType = additionalRelations[0].getType();\n\n            // If we have a COMPONENT_WITH relationship,\n            // then we need the individual being split/merged from/into\n            // const hasComponent = additionalRelations\n            //     .filter((relation) => relation.getType() === \"COMPONENT_WITH\");\n            // if (hasComponent) {\n            //     console.debug(\"Has component with relationship\");\n            //     rootEvent = events[0];\n            if ((splitMergeType === \"MERGED_FROM\") || (splitMergeType === \"SPLIT_FROM\")) {\n                // Link to the start event\n                rootEvent = events[0];\n            } else {\n                rootEvent = events[1];\n            }\n\n            const obsArray = additionalRelations.map((relation) => {\n                console.debug(\"Getting attributes for:\", relation.getObject());\n                return this.vs.getTrestleIndividual(relation.getObject());\n            });\n            forkJoin(obsArray)\n                .subscribe((objects) => {\n                    console.debug(\"Adding related events for:\", individual);\n                    console.debug(\"Have all observables:\", objects);\n\n                    // Do we have a component with relationship?\n                    // If so, find who we're supposed to split/merge with, and use that as the root event\n                    const hasComponent = additionalRelations\n                        .filter((relation) => relation.getType() === \"COMPONENT_WITH\");\n                    if (hasComponent.length > 0) {\n                        console.debug(\"has component with:\", hasComponent);\n                        const splitMergeID = additionalRelations[0].getObject();\n                        console.debug(\"Using %s as root individual\", splitMergeID);\n                        const splitMergeIndividual = objects\n                            .filter((obj) => obj.getID() === splitMergeID);\n                        console.debug(\"Found individual:\", splitMergeIndividual[0]);\n                        if (!splitMergeIndividual) {\n                            throw new Error(\"Can't find who to split/merge with during component_with\");\n                        }\n                        const smiEvents = SpatialUnionComponent.buildObjectEvents(splitMergeIndividual[0], splitMergeIndividual[0].getFilteredID(),\n                            undefined, undefined, true);\n                        if ((splitMergeType === \"MERGED_FROM\") || (splitMergeType === \"SPLIT_FROM\")) {\n                            // Link to the start event\n                            rootEvent = smiEvents.events[1];\n                        } else {\n                            rootEvent = smiEvents.events[0];\n                        }\n                        console.debug(\"Using as root event:\", rootEvent);\n                        //    Add the events\n                        events = events.concat(smiEvents.events);\n                        links = links.concat(smiEvents.links);\n                    }\n\n\n                    objects.forEach((object) => {\n                        // If you're the root event, don't process yourself\n                        if (object.getFilteredID() !== rootEvent.entity) {\n                            const relatedEvents = SpatialUnionComponent.buildObjectEvents(object,\n                                object.getFilteredID(),\n                                // If it's a component with relationship, don't deal with the split/merges\n                                splitMergeType,\n                                rootEvent,\n                                hasComponent.length > 0);\n                            events = events.concat(relatedEvents.events);\n                            links = links.concat(relatedEvents.links);\n                        }\n                    });\n                    const sortedEvents = this.sortEvents(events, links, filteredID);\n                    console.debug(\"Sorted events:\", sortedEvents);\n                    this.eventData = sortedEvents;\n                });\n        } else {\n            this.eventData = this.sortEvents(events, links, filteredID);\n        }\n    }\n\n    private sortEvents(events: IEventElement[], links: IEventLink[], individualID: string): IEventData {\n        console.debug(\"Sorting with %s in the middle\", individualID);\n\n        // Sort any merged events\n        let eventBins = events\n            .filter((event) => (event.value === \"from\") || (event.value === \"into\")).length;\n        // if we have an even number of merge events, add one, so that way\n        if ((eventBins % 2) === 0) {\n            eventBins += 1;\n        }\n\n        // We only have a single selection, add 2, just for giggles and spits\n        if (eventBins === 1) {\n            eventBins = 3;\n        }\n\n        // Set the selection equal to the middle value\n        console.debug(\"Sorting data into %s bins\", eventBins);\n        let currentBin = Math.ceil(eventBins / 2);\n\n        events\n            .filter((event) => event.entity === individualID)\n            .map((event) => {\n                event.bin = currentBin;\n            });\n        // Now, the merged events, alternating high/low\n        let sign = \"+\";\n        let step = 1;\n\n        events\n            .filter((event) => (event.value === \"from\") || (event.value === \"into\") || (event.value === \"component\"))\n            .map((event) => {\n                // Increment the current bin\n                currentBin = currentBin + Number.parseInt(sign + step);\n                event.bin = currentBin;\n\n                // And do so for all the other events of the given selection\n                events\n                    .filter((iEvent) => iEvent.entity === event.entity)\n                    .map((iEvent) => iEvent.bin = currentBin);\n\n                // Increment the step and flip the sign\n                step++;\n                sign = sign === \"+\" ? \"-\" : \"+\";\n            });\n\n        return {\n            nodes: events,\n            links,\n            bins: eventBins\n        };\n    }\n\n\n\n    /**\n     * Build events for individual\n     *\n     * @param {TrestleIndividual} individual\n     * @param {string} entityName\n     * @param {TrestleRelationType} relationType\n     * @param {IEventElement} rootEvent\n     * @param {boolean} componentWith\n     * @returns {{events: IEventElement[]; links: IEventLink[]}}\n     */\n    private static buildObjectEvents(individual: TrestleIndividual,\n                              entityName: string,\n                              relationType?: TrestleRelationType,\n                              rootEvent?: IEventElement,\n                              componentWith = false): {\n        events: IEventElement[],\n        links: IEventLink[]\n    } {\n        console.debug(\"Build events for selection: %s with relation type: %s\",\n            individual.getID(), relationType);\n        console.debug(\"Using root event:\", rootEvent);\n        // Split merge first,\n        // because it'll show us if we need to drop a created or destroyed event\n        const events: IEventElement[] = [];\n        const links: IEventLink[] = [];\n\n        // Get the start event\n        const startEvent = individual.getStartEvent();\n        const started = {\n            id: entityName + \"-\" + startEvent.getType(),\n            entity: entityName,\n            bin: 1,\n            value: \"data\",\n            temporal: startEvent.getTemporal().toDate()\n        };\n\n        // If the root selection is a merged_from or split_from,\n        // then we're looking for a link between the end event and an INTO relation\n        if ((relationType === \"MERGED_FROM\") || (relationType === \"SPLIT_FROM\")) {\n            console.debug(\"Has from\");\n            const adjustedTemporal = (individual.getTemporal().getTo() as moment.Moment)\n                .clone().add(-1, \"year\").toDate();\n            const fromEvent = {\n                id: entityName + \"-\" + SpatialUnionComponent.invertRelationship(relationType),\n                entity: entityName,\n                bin: 1,\n                value: \"into\",\n                // We can do this cast because if there's    a merge event, there is some end point\n                // We need to roll it back by 1 year, to make it look better\n                temporal: adjustedTemporal\n            };\n            events.push(started, fromEvent);\n            links.push({\n                source: started,\n                target: fromEvent\n            });\n            // If we also have a root event, draw a link between it and the split/merge event\n            if (rootEvent && !componentWith) {\n                console.debug(\"Writing link between %O and %O\", fromEvent, rootEvent);\n                links.push({\n                    source: fromEvent,\n                    target: rootEvent\n                });\n            }\n            // We want the split event and the ending event\n        } else if ((relationType === \"SPLIT_INTO\") || (relationType === \"MERGED_INTO\")) {\n            console.debug(\"Has into\");\n            const endEvent = (individual.getEndEvent() as TrestleEvent);\n            // We know that if there's a split going on, that there's an end event\n            const end = {\n                id: entityName + \"-\" + endEvent.getType(),\n                entity: entityName,\n                bin: 1,\n                value: \"data\",\n                temporal: endEvent.getTemporal().toDate()\n            };\n            const adjustedDate = startEvent.getTemporal().clone()\n                .add(1, \"year\").toDate();\n            const intoEvent = {\n                id: entityName + \"-\" + SpatialUnionComponent.invertRelationship(relationType),\n                entity: entityName,\n                bin: 1,\n                value: \"from\",\n                // We need to roll it forward by 1 year, for art's sake\n                temporal: adjustedDate\n            };\n            console.debug(\"Writing link between %O and %O\", end, intoEvent);\n            events.push(end, intoEvent);\n            links.push({\n                source: intoEvent,\n                target: end\n            });\n            // If we also have a root event, draw a link between it and the end event\n            if (rootEvent && !componentWith) {\n                console.debug(\"Writing link between %O and %O\", intoEvent, rootEvent);\n                links.push({\n                    source: intoEvent,\n                    target: rootEvent\n                });\n            }\n            //    Otherwise, link the start and end events\n        } else {\n            const endEvent = individual.getEndEvent();\n            // If there is no end event, create a fake one and link it to the start event\n            if (endEvent === null) {\n                const destroyed = {\n                    id: entityName + \"-DESTROYED\",\n                    entity: entityName,\n                    bin: 1,\n                    value: \"data\",\n                    temporal: new Date(\"3001-01-01\")\n                };\n                events.push(started, destroyed);\n                links.push({\n                    source: started,\n                    target: destroyed\n                });\n                //    Otherwise, create the end event and move on\n            } else {\n                console.debug(\"Something else:\", relationType);\n                const ended = {\n                    id: entityName + \"-\" + (endEvent as TrestleEvent).getType(),\n                    entity: entityName,\n                    bin: 1,\n                    value: componentWith === true ? \"component\" : \"data\",\n                    temporal: (endEvent as TrestleEvent).getTemporal().toDate()\n                };\n                events.push(started, ended);\n                links.push({\n                    source: started,\n                    target: ended\n                });\n\n                //    Add root event?\n                if (rootEvent) {\n                    console.debug(\"Should add root event link\");\n                }\n            }\n        }\n        console.debug(\"Events for %s\", individual.getID(), events);\n        return {\n            events,\n            links\n        };\n    }\n\n\n    /**\n     * Invert the object relationship, because our event graphs works in reverse\n     * @param {\"MERGED_FROM\" | \"MERGED_INTO\" | \"SPLIT_FROM\" | \"SPLIT_INTO\"} relationship\n     * @returns {string} of inverted relationship\n     */\n    private static invertRelationship(relationship: \"MERGED_FROM\" | \"MERGED_INTO\" | \"SPLIT_FROM\" | \"SPLIT_INTO\"): string {\n        switch (relationship) {\n            case \"MERGED_FROM\":\n                return \"MERGED_INTO\";\n            case \"MERGED_INTO\":\n                return \"MERGED_FROM\";\n            case \"SPLIT_INTO\":\n                return \"SPLIT_FROM\";\n            case \"SPLIT_FROM\":\n                return \"SPLIT_INTO\";\n        }\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./spatial-union.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "vs",
                        "type": "IndividualService"
                    }
                ],
                "line": 23,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "vs",
                        "type": "IndividualService",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnChanges"
            ],
            "templateData": "<div *ngIf=\"individual\">\n    <event-graph [graphHeight]=\"300\"\n                 [minDate]=\"minDate\"\n                 [maxDate]=\"maxDate\"\n                 [data]=\"eventData\"\n                 [filterLabel]=\"filterLabel\"\n                 [selectedIndividual]=\"individual.getFilteredID()\"></event-graph>\n</div>\n"
        },
        {
            "name": "TopNavComponent",
            "id": "component-TopNavComponent-de33ead5dc1cd4f3e4cf4911760b14dc",
            "file": "src/main/webapp/src/app/navigation/top-nav/top-nav.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "top-nav",
            "styleUrls": [
                "./top-nav.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./top-nav.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "headerClicked",
                    "defaultValue": "new EventEmitter<void>()",
                    "line": 16,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "user",
                    "type": "Observable<TrestleUser>",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 21
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, OnInit, Output} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {TrestleUser} from '../../user/trestle-user';\nimport {select, Store} from '@ngrx/store';\nimport {selectUserFromUser, State} from '../../reducers';\n\n@Component({\n  selector: 'top-nav',\n  templateUrl: './top-nav.component.html',\n  styleUrls: ['./top-nav.component.scss']\n})\nexport class TopNavComponent implements OnInit {\n  public user: Observable<TrestleUser>;\n\n  @Output()\n  public headerClicked = new EventEmitter<void>();\n\n  constructor(private store: Store<State>) {\n  }\n\n  ngOnInit(): void {\n    this.user = this.store.pipe(select(selectUserFromUser));\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".toolbar-spacer {\n  flex: 1 1 auto;\n}\n\n.top-layout {\n  height: 50px;\n  vertical-align: middle;\n}\n",
                    "styleUrl": "./top-nav.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "store",
                        "type": "Store<State>"
                    }
                ],
                "line": 16,
                "jsdoctags": [
                    {
                        "name": "store",
                        "type": "Store<State>",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<mat-toolbar color=\"primary\" class=\"top-layout z-depth-4\">\n  <h4 (click)=\"headerClicked.emit()\">TRESTLE</h4>\n  <span class=\"toolbar-spacer\"></span>\n  <user-icon></user-icon>\n\n</mat-toolbar>\n"
        },
        {
            "name": "TreeGraphComponent",
            "id": "component-TreeGraphComponent-4bbe3c61bc8ee2fd14063cc86d055136",
            "file": "src/main/webapp/src/app/admin/indicies/tree-graph/tree-graph.component.ts",
            "encapsulation": [
                "ViewEncapsulation.None"
            ],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "tree-graph",
            "styleUrls": [
                "./tree-graph.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./tree-graph.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "data",
                    "line": 40,
                    "type": "IGraphHeader"
                }
            ],
            "outputsClass": [
                {
                    "name": "hovered",
                    "line": 42,
                    "type": "EventEmitter<string>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "colorScale",
                    "type": "function",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "dataSubject",
                    "type": "Subject<IGraphHeader | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "element",
                    "type": "ElementRef",
                    "optional": false,
                    "description": "",
                    "line": 38,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'graph'"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "height",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 47,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "host",
                    "type": "Selection<HTMLElement | IIndexLeafStatistics | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 44,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "hoverHandler",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 165,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "htmlElement",
                    "type": "HTMLElement",
                    "optional": false,
                    "description": "",
                    "line": 43,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "margin",
                    "type": "ID3Margin",
                    "optional": false,
                    "description": "",
                    "line": 48,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "maxTime",
                    "type": "Moment",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "rounder",
                    "type": "RoundingPipe",
                    "optional": false,
                    "description": "",
                    "line": 54,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "svg",
                    "type": "Selection<BaseType | IIndexLeafStatistics | null | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 45,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "width",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 46,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "x",
                    "type": "ScaleLinear<number | number>",
                    "optional": false,
                    "description": "",
                    "line": 50,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "y",
                    "type": "ScaleLinear<number | number>",
                    "optional": false,
                    "description": "",
                    "line": 51,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "adjustTemporals",
                    "args": [
                        {
                            "name": "domain",
                            "type": "any"
                        },
                        {
                            "name": "offsetValue",
                            "type": "number"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 188,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "domain",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "offsetValue",
                            "type": "number",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 64,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 78,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "normalizeTriangle",
                    "args": [
                        {
                            "name": "coordinates",
                            "type": "number[]"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 175,
                    "description": "<p>Normalize coordinates (represented as millis from UTC epoch) into D3 coordinates</p>\n",
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 5463,
                                "end": 5474,
                                "flags": 0,
                                "escapedText": "coordinates"
                            },
                            "type": "number[]",
                            "tagName": {
                                "pos": 5446,
                                "end": 5451,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 5452,
                                "end": 5462,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 5453,
                                    "end": 5461,
                                    "flags": 2097152,
                                    "kind": 166,
                                    "elementType": {
                                        "pos": 5453,
                                        "end": 5459,
                                        "flags": 2097152,
                                        "kind": 134
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 5481,
                                "end": 5488,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "plotData",
                    "args": [
                        {
                            "name": "data",
                            "type": "IGraphHeader"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 86,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "IGraphHeader",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setupD3",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 192,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {\n  AfterViewInit,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  Output,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation\n} from '@angular/core';\nimport {ScaleLinear, scaleLinear} from 'd3-scale';\nimport {BaseType, select, Selection} from 'd3-selection';\nimport moment, {Moment} from 'moment';\nimport {axisBottom, axisLeft} from 'd3-axis';\nimport {IIndexLeafStatistics} from '../index.service';\nimport {interpolateHsl} from 'd3-interpolate';\nimport {ID3Margin} from '../../../ui/common';\nimport {BehaviorSubject, Subject} from 'rxjs';\nimport {RoundingPipe} from '../../../shared/pipes/rounding-pipe.pipe';\n\nexport interface IGraphHeader {\n  maxValue: number;\n  offsetValue: number;\n  leafs: IIndexLeafStatistics[];\n}\n\n@Component({\n  selector: 'tree-graph',\n  templateUrl: './tree-graph.component.html',\n  styleUrls: ['./tree-graph.component.scss'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class TreeGraphComponent implements AfterViewInit, OnChanges {\n\n  @ViewChild('graph')\n  public element: ElementRef;\n  @Input()\n  public data: IGraphHeader;\n  @Output()\n  public hovered: EventEmitter<string>;\n  private htmlElement: HTMLElement;\n  private host: Selection<HTMLElement, IIndexLeafStatistics, null, undefined>;\n  private svg: Selection<BaseType, IIndexLeafStatistics, null, undefined>;\n  private width: number;\n  private height: number;\n  private margin: ID3Margin;\n  private maxTime: Moment;\n  private x: ScaleLinear<number, number>;\n  private y: ScaleLinear<number, number>;\n  private colorScale: (value: number) => string;\n  private dataSubject: Subject<IGraphHeader | undefined>;\n  private rounder: RoundingPipe;\n\n  public constructor() {\n    this.maxTime = moment('5000-01-01').startOf('year');\n    this.colorScale = interpolateHsl('steelblue', 'brown');\n    this.rounder = new RoundingPipe();\n    this.hovered = new EventEmitter<string>();\n    this.dataSubject = new BehaviorSubject(undefined);\n  }\n\n  public ngAfterViewInit(): void {\n    this.htmlElement = this.element.nativeElement;\n    this.setupD3();\n\n    //    Subscribe\n    this.dataSubject\n      .subscribe((value) => {\n        if (value !== undefined) {\n          this.plotData(value);\n          this.data = value;\n        }\n      });\n  }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    const dataChanges = changes['data'];\n    if (dataChanges.currentValue !== dataChanges.previousValue) {\n      console.debug('Plotting new changes');\n      this.dataSubject.next(dataChanges.currentValue);\n    }\n  }\n\n  private plotData(data: IGraphHeader): void {\n    // Nuke everything, because I can't figure out the update pattern\n    this.svg.selectAll('*').remove();\n    // Calculate the max time, which need to adjust from the cache values\n    this.maxTime = moment(data.maxValue - data.offsetValue);\n\n    console.debug('Plotting with max: %s and offset: %s', data.maxValue, data.offsetValue);\n\n    // Set the X/Y scales\n    this.x = scaleLinear().range([0, this.width]);\n    this.x.domain([0, data.maxValue]);\n    // We need to invert this, in order to get the triangles to draw in the correct direction\n    this.y = scaleLinear().range([this.height, 0]);\n    this.y.domain([0, data.maxValue]);\n\n    // Add the axises\n    this.svg\n      .append('g')\n      .attr('class', 'axis x-axis')\n      .attr('transform', 'translate(0,' + this.height + ')')\n      .call(axisBottom(this.x)\n        .tickFormat((d) => TreeGraphComponent.adjustTemporals(d, data.offsetValue)))\n      .selectAll('text')\n      .attr('y', 0)\n      .attr('x', 9)\n      .attr('dy', '.35em')\n      .attr('transform', 'rotate(45)')\n      .style('text-anchor', 'start');\n\n    this.svg\n      .append('g')\n      .attr('class', 'axis axis-y')\n      .call(axisLeft(this.y)\n        .tickFormat((d) => TreeGraphComponent.adjustTemporals(d, data.offsetValue)))\n      .selectAll('text')\n      .attr('y', 0)\n      .attr('x', -10)\n      .attr('dy', '.35em')\n      .style('text-anchor', 'end');\n\n    //    Draw a line\n    // this.svg\n    //     .append(\"g\")\n    //     .attr(\"class\", \"dividing-line\")\n    //     .append(\"line\")\n    //     .attr(\"x1\", 0)\n    //     .attr(\"x2\", this.x(data.maxValue))\n    //     // .attr(\"y1\", this.height)\n    //     .attr(\"y1\", this.height)\n    //     .attr(\"y2\", 0)\n    //     .attr(\"stroke-width\", 3)\n    //     .attr(\"stroke\", \"black\");\n\n\n    //    For each, leaf, draw the triangle\n    const leafData = this.svg\n      .selectAll<SVGPolygonElement, BaseType>('.leaf')\n      // This index function needs to be a string, for some reason\n      .data(data.leafs, (d: IIndexLeafStatistics) => d.binaryID);\n\n    leafData\n      .enter()\n      .append('polygon')\n      .attr('id', (d) => d.binaryID)\n      .attr('direction', (d) => d.direction.toString())\n      .attr('coords', (d) => d.coordinates.join(','))\n      .attr('class', 'leaf')\n      .attr('points', (d) => this.normalizeTriangle(d.coordinates))\n      .attr('stroke-width', 1)\n      .attr('stroke', 'black')\n      // .attr(\"fill\", (d) => this.colorScale((d.records / 20) + 0.01))\n      .attr('fill', 'blue')\n      .style('fill-opacity', 0.7)\n      // Hover handlers\n      .on('mouseover', this.hoverHandler)\n      .merge(leafData);\n\n  }\n\n  private hoverHandler = (d: IIndexLeafStatistics): void => {\n    console.debug('Hovered', d.leafID.toString());\n    this.hovered.next(d.leafID.toString());\n  };\n\n  /**\n   * Normalize coordinates (represented as millis from UTC epoch) into D3 coordinates\n   * @param {number[]} coordinates\n   * @returns {string}\n   */\n  private normalizeTriangle(coordinates: number[]): string {\n    const size = coordinates.length;\n    const normalized = new Array(size);\n    let isX = true;\n    for (let idx = 0; idx < size; idx++) {\n      // console.debug(\"Rounding %s to %s\", coordinates[idx], this.rounder.transform(coordinates[idx], 0));\n      const rounded = this.rounder.transform(coordinates[idx], 0);\n      normalized[idx] = isX ? this.x(rounded) : this.y(rounded);\n      isX = !isX;\n    }\n    return normalized.join(',');\n  }\n\n  private static adjustTemporals(domain: any, offsetValue: number): string {\n    return new Date(domain - offsetValue).toISOString();\n  }\n\n  private setupD3(): void {\n    this.host = select<HTMLElement, IIndexLeafStatistics>(this.htmlElement);\n    this.margin = this.margin = {top: 20, right: 30, bottom: 100, left: 150};\n    this.width = this.htmlElement.offsetWidth - this.margin.left - this.margin.right;\n    this.height = 500 - this.margin.top - this.margin.bottom;\n\n    this.svg = this.host.html('')\n      .append('svg')\n      .attr('width', this.width + this.margin.left + this.margin.right)\n      .attr('height', this.height + this.margin.top + this.margin.bottom)\n      .append('g')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./tree-graph.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 54,
                "modifierKind": [
                    114
                ]
            },
            "implements": [
                "AfterViewInit",
                "OnChanges"
            ],
            "templateData": "<div #graph></div>"
        },
        {
            "name": "TrestleMapComponent",
            "id": "component-TrestleMapComponent-54855aecfb83d63a7c98aaef81713297",
            "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "trestle-map",
            "styleUrls": [
                "./trestle-map.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./trestle-map.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "attributeChanges",
                    "line": 94,
                    "type": "Subject<IMapAttributeChange>"
                },
                {
                    "name": "clickLayerSuffix",
                    "line": 90,
                    "type": "string"
                },
                {
                    "name": "config",
                    "line": 92,
                    "type": "MapboxOptions"
                },
                {
                    "name": "data",
                    "line": 87,
                    "type": "MapSource"
                },
                {
                    "name": "dataChanges",
                    "line": 93,
                    "type": "Subject<MapSource | undefined>"
                },
                {
                    "name": "handlers",
                    "line": 95,
                    "type": "IMapEventHandler[]"
                },
                {
                    "name": "multiSelect",
                    "line": 89,
                    "type": "boolean"
                },
                {
                    "name": "single",
                    "line": 88,
                    "type": "boolean"
                },
                {
                    "name": "zoomOnLoad",
                    "line": 91,
                    "type": "boolean"
                }
            ],
            "outputsClass": [
                {
                    "name": "clicked",
                    "defaultValue": "new EventEmitter()",
                    "line": 97,
                    "type": "EventEmitter<string>"
                },
                {
                    "name": "mapBounds",
                    "defaultValue": "new EventEmitter()",
                    "line": 96,
                    "type": "EventEmitter<LngLatBounds>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "baseConfig",
                    "type": "MapboxOptions",
                    "optional": false,
                    "description": "",
                    "line": 99,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "centerMapOnLoad",
                    "type": "BehaviorSubject<boolean>",
                    "optional": false,
                    "description": "",
                    "line": 98,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "filteredIDs",
                    "type": "string[]",
                    "optional": false,
                    "description": "",
                    "line": 103,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "layerClick",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 642,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "map",
                    "type": "MapboxMap",
                    "optional": false,
                    "description": "",
                    "line": 100,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "mapSources",
                    "type": "Map<string | string[]>",
                    "optional": false,
                    "description": "",
                    "line": 101,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "mouseOut",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 712,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "mouseOver",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 708,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "moveHandler",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 716,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "previousValue",
                    "type": "MapSource",
                    "optional": false,
                    "description": "",
                    "line": 104,
                    "modifierKind": [
                        112
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "addSource",
                    "args": [
                        {
                            "name": "inputLayer",
                            "type": "MapSource"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 506,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "inputLayer",
                            "type": "MapSource",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "buildFilterID",
                    "args": [
                        {
                            "name": "individual",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 742,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "individual",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "centerMap",
                    "args": [
                        {
                            "name": "geom",
                            "type": "FeatureCollection<GeometryObject> | Feature<GeometryObject>"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 326,
                    "description": "<p>Center the map on the given input set, computes the bounding box if one doesn&#39;t exist</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 10706,
                                "end": 10710,
                                "flags": 0,
                                "escapedText": "geom"
                            },
                            "type": "FeatureCollection<GeometryObject> | Feature<GeometryObject>",
                            "tagName": {
                                "pos": 10638,
                                "end": 10643,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 10644,
                                "end": 10705,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 10645,
                                    "end": 10704,
                                    "flags": 2097152,
                                    "kind": 168,
                                    "types": [
                                        {
                                            "pos": 10645,
                                            "end": 10678,
                                            "flags": 2097152,
                                            "kind": 161,
                                            "typeName": {
                                                "pos": 10645,
                                                "end": 10662,
                                                "flags": 2097152,
                                                "escapedText": "FeatureCollection"
                                            },
                                            "typeArguments": [
                                                {
                                                    "pos": 10663,
                                                    "end": 10677,
                                                    "flags": 2097152,
                                                    "kind": 161,
                                                    "typeName": {
                                                        "pos": 10663,
                                                        "end": 10677,
                                                        "flags": 2097152,
                                                        "escapedText": "GeometryObject"
                                                    }
                                                }
                                            ]
                                        },
                                        {
                                            "pos": 10680,
                                            "end": 10704,
                                            "flags": 2097152,
                                            "kind": 161,
                                            "typeName": {
                                                "pos": 10680,
                                                "end": 10688,
                                                "flags": 2097152,
                                                "escapedText": "Feature"
                                            },
                                            "typeArguments": [
                                                {
                                                    "pos": 10689,
                                                    "end": 10703,
                                                    "flags": 2097152,
                                                    "kind": 161,
                                                    "typeName": {
                                                        "pos": 10689,
                                                        "end": 10703,
                                                        "flags": 2097152,
                                                        "escapedText": "GeometryObject"
                                                    }
                                                }
                                            ]
                                        }
                                    ]
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "change3DOffset",
                    "args": [
                        {
                            "name": "height",
                            "type": "number"
                        },
                        {
                            "name": "offset",
                            "type": "number"
                        },
                        {
                            "name": "individual",
                            "type": "string",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 371,
                    "description": "<p>Change the 3D offset of the individual, or all sources that are currently at the input height</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 11980,
                                "end": 11986,
                                "flags": 0,
                                "escapedText": "height"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 11965,
                                "end": 11970,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 11971,
                                "end": 11979,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 11972,
                                    "end": 11978,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 12008,
                                "end": 12014,
                                "flags": 0,
                                "escapedText": "offset"
                            },
                            "type": "number",
                            "tagName": {
                                "pos": 11993,
                                "end": 11998,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 11999,
                                "end": 12007,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 12000,
                                    "end": 12006,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 12036,
                                "end": 12046,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "string",
                            "optional": true,
                            "tagName": {
                                "pos": 12021,
                                "end": 12026,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 12027,
                                "end": 12035,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 12028,
                                    "end": 12034,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "changeIndividualAttribute",
                    "args": [
                        {
                            "name": "attributeChange",
                            "type": "IMapAttributeChange"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 235,
                    "description": "<p>Modify the specified attribute for the given individual</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 7166,
                                "end": 7181,
                                "flags": 0,
                                "escapedText": "attributeChange"
                            },
                            "type": "IMapAttributeChange",
                            "tagName": {
                                "pos": 7138,
                                "end": 7143,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 7144,
                                "end": 7165,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7145,
                                    "end": 7164,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 7145,
                                        "end": 7164,
                                        "flags": 2097152,
                                        "escapedText": "IMapAttributeChange"
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "clearMap",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 314,
                    "description": "<p>Clear all the layers and sources from the map</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getMapBounds",
                    "args": [],
                    "optional": false,
                    "returnType": "LngLatBounds",
                    "typeParameters": [],
                    "line": 212,
                    "description": "<p>Get the current map bounds</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 6509,
                                "end": 6516,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": ""
                        }
                    ]
                },
                {
                    "name": "is3D",
                    "args": [
                        {
                            "name": "x",
                            "type": "any"
                        }
                    ],
                    "optional": false,
                    "returnType": "I3DMapSource",
                    "typeParameters": [],
                    "line": 730,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "x",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isCollection",
                    "args": [
                        {
                            "name": "x",
                            "type": "any"
                        }
                    ],
                    "optional": false,
                    "returnType": "FeatureCollection<GeometryObject>",
                    "typeParameters": [],
                    "line": 738,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "x",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isGeoJSON",
                    "args": [
                        {
                            "name": "x",
                            "type": "any"
                        }
                    ],
                    "optional": false,
                    "returnType": "GeoJSONDataSource",
                    "typeParameters": [],
                    "line": 734,
                    "modifierKind": [
                        112,
                        115
                    ],
                    "jsdoctags": [
                        {
                            "name": "x",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "literal type"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 174,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "literal type",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 115,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "removeIndividual",
                    "args": [
                        {
                            "name": "individual",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 220,
                    "description": "<p>Remove individual from the map, which clears the source and linked layers</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 6731,
                                "end": 6741,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 6716,
                                "end": 6721,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 6722,
                                "end": 6730,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 6723,
                                    "end": 6729,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "removeSource",
                    "args": [
                        {
                            "name": "source",
                            "type": "MapSource | string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 482,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "source",
                            "type": "MapSource | string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setMapStyle",
                    "args": [
                        {
                            "name": "style",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 345,
                    "description": "<p>Change the map base layer\nWARNING: This will cause all the sources and layers to be removed and added again, which is slow</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 11433,
                                "end": 11438,
                                "flags": 0,
                                "escapedText": "style"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 11418,
                                "end": 11423,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>New base layer URL</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 11424,
                                "end": 11432,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 11425,
                                    "end": 11431,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "setPitchBearing",
                    "args": [
                        {
                            "name": "pitch",
                            "type": "number",
                            "optional": true
                        },
                        {
                            "name": "bearing",
                            "type": "number",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 355,
                    "description": "<p>Update the map view angle</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 11624,
                                "end": 11629,
                                "flags": 0,
                                "escapedText": "pitch"
                            },
                            "type": "number",
                            "optional": true,
                            "tagName": {
                                "pos": 11609,
                                "end": 11614,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 11615,
                                "end": 11623,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 11616,
                                    "end": 11622,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 11651,
                                "end": 11658,
                                "flags": 0,
                                "escapedText": "bearing"
                            },
                            "type": "number",
                            "optional": true,
                            "tagName": {
                                "pos": 11636,
                                "end": 11641,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 11642,
                                "end": 11650,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 11643,
                                    "end": 11649,
                                    "flags": 2097152,
                                    "kind": 134
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "setupDefaults",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 720,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "toggleIndividualVisibility",
                    "args": [
                        {
                            "name": "individual",
                            "type": "string"
                        },
                        {
                            "name": "setVisible",
                            "type": "boolean"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 259,
                    "description": "<p>Toggle the visibility of the layers for the given individual\nThis changes all registered layers for the given source</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 8003,
                                "end": 8013,
                                "flags": 0,
                                "escapedText": "individual"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 7988,
                                "end": 7993,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 7994,
                                "end": 8002,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 7995,
                                    "end": 8001,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 8036,
                                "end": 8046,
                                "flags": 0,
                                "escapedText": "setVisible"
                            },
                            "type": "boolean",
                            "tagName": {
                                "pos": 8020,
                                "end": 8025,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 8026,
                                "end": 8035,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 8027,
                                    "end": 8034,
                                    "flags": 2097152,
                                    "kind": 122
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "toggleSourceVisibility",
                    "args": [
                        {
                            "name": "source",
                            "type": "string"
                        },
                        {
                            "name": "setVisible",
                            "type": "boolean"
                        },
                        {
                            "name": "individual",
                            "type": "string",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 427,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "source",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "setVisible",
                            "type": "boolean",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "individual",
                            "type": "string",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChange} from \"@angular/core\";\nimport {Feature, FeatureCollection, GeometryObject} from \"geojson\";\nimport {BehaviorSubject, Subject} from \"rxjs\";\nimport {TrestleIndividual} from \"../../shared/individual/TrestleIndividual/trestle-individual\";\nimport extent from \"@mapbox/geojson-extent\";\nimport {\n  FillExtrusionLayer,\n  FillLayer,\n  FillPaint,\n  GeoJSONSource,\n  GeoJSONSourceRaw,\n  ImageSource,\n  LineLayer,\n  LngLatBounds,\n  Map as MapboxMap,\n  MapboxOptions,\n  MapMouseEvent,\n  RasterSource,\n  VectorSource,\n  VideoSource\n} from \"mapbox-gl\";\n\nexport interface IMapFillLayer extends FillLayer {\n  type: 'fill';\n}\n\nexport interface IMapLineLayer extends LineLayer {\n  type: 'line';\n}\n\nexport interface IMapHoverLayer extends FillLayer {\n  type: 'fill';\n  filter: ['==', 'name', ''];\n}\n\nexport interface ITrestleMapLayers {\n  fill?: IMapFillLayer;\n  line?: IMapLineLayer;\n  hover?: IMapHoverLayer;\n}\n\nexport interface ITrestleMapSource {\n  id: string;\n  idField?: string;\n  data: FeatureCollection<GeometryObject> | Feature<GeometryObject>;\n  layers?: ITrestleMapLayers;\n  labelField?: string;\n  labelFunction?: (label: string) => string;\n  labelValue?: string;\n}\n\nexport interface I3DMapSource extends ITrestleMapSource {\n  extrude: FillExtrusionLayer;\n}\n\ninterface GeoJSONDataSource extends GeoJSONSource {\n  _data: Feature<GeometryObject> | FeatureCollection<GeometryObject>;\n}\n\nexport interface IMapAttributeChange {\n  individual: string;\n  changes: Array<{ attribute: string, value: any }>;\n  // attribute: string;\n  // value: any;\n}\n\nexport interface IMapEventHandler {\n  event: MapEvent;\n  handler: (event: any) => void;\n}\n\nexport type MapEvent = 'mousemove' | 'mouseleave' | 'click' | 'moveend';\nexport type MapSource = I3DMapSource | ITrestleMapSource;\nexport type MapBoxSource = GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw;\n\n@Component({\n  selector: 'trestle-map',\n  templateUrl: './trestle-map.component.html',\n  styleUrls: ['./trestle-map.component.scss']\n})\n\nexport class TrestleMapComponent implements OnInit, OnChanges {\n\n  @Input() public data: MapSource;\n  @Input() public single: boolean;\n  @Input() public multiSelect: boolean;\n  @Input() public clickLayerSuffix: string;\n  @Input() public zoomOnLoad?: boolean;\n  @Input() public config?: MapboxOptions;\n  @Input() public dataChanges: Subject<MapSource | undefined>;\n  @Input() public attributeChanges: Subject<IMapAttributeChange>;\n  @Input() public handlers: IMapEventHandler[];\n  @Output() public mapBounds: EventEmitter<LngLatBounds> = new EventEmitter();\n  @Output() public clicked: EventEmitter<string> = new EventEmitter();\n  private centerMapOnLoad: BehaviorSubject<boolean>;\n  private baseConfig: MapboxOptions;\n  private map: MapboxMap;\n  private mapSources: Map<string, string[]>;\n  // This has to be integers, in order to match against the numeric IDs\n  private filteredIDs: string[];\n  private previousValue: MapSource;\n\n  constructor() {\n\n    this.mapSources = new Map();\n    this.filteredIDs = [];\n\n    //    Set defaults\n    this.setupDefaults();\n  }\n\n  public ngOnInit(): void {\n    if (this.zoomOnLoad === undefined) {\n      this.centerMapOnLoad = new BehaviorSubject(true);\n    } else {\n      this.centerMapOnLoad = new BehaviorSubject(this.zoomOnLoad);\n    }\n\n    console.debug('Creating map, ' +\n      'singleSelect?', this.single,\n      'mulitSelect?', this.multiSelect,\n      'zoom?', this.centerMapOnLoad.getValue());\n\n    // Merge the map configs together\n    const mergedConfig = Object.assign(this.baseConfig, this.config);\n    this.map = new MapboxMap(mergedConfig);\n\n    this.map.on('click', this.layerClick);\n    this.map.on('mouseover', this.mouseOver);\n    this.map.on('mouseleave', this.mouseOut);\n    this.map.on('moveend', this.moveHandler);\n\n    // Register any additional handlers\n    if (this.handlers) {\n      this.handlers.forEach((h) => {\n        this.map.on(h.event, h.handler);\n      });\n    }\n\n    // Once the map is loaded, setup the subscriptions\n    this.map.on('style.load', () => {\n      // If it's null, create a dummy one\n      if (this.dataChanges === undefined) {\n        console.debug('Creating dummy data changes subscription');\n        this.dataChanges = new Subject();\n      }\n      console.debug('Subscribing to data changes observable');\n      this.dataChanges.subscribe((data) => {\n        console.debug('Map has new data to load', data);\n        if (data !== undefined) {\n          if (this.single && this.previousValue) {\n            this.removeSource(this.previousValue);\n          }\n          this.addSource(data);\n          this.previousValue = data;\n        }\n      });\n\n      if (this.attributeChanges === undefined) {\n        console.debug('Creating dummy attribute subscription');\n        this.attributeChanges = new Subject();\n      }\n      console.debug('Subscribing to attribute changes observable');\n      this.attributeChanges.subscribe((change) => {\n        this.changeIndividualAttribute(change);\n      });\n      this.mapBounds.emit(this.map.getBounds());\n    });\n  }\n\n  public ngOnChanges(changes: { [propKey: string]: SimpleChange }): void {\n    // Individual changes\n    const inputChanges = changes['data'];\n    if (inputChanges != null\n      && !inputChanges.isFirstChange()\n      && (inputChanges.currentValue !== inputChanges.previousValue)) {\n      console.debug('New change, updating', inputChanges);\n      if (inputChanges.previousValue != null && this.single) {\n        // mapChanges.previousValue= inputChanges.previousValue;\n        this.removeSource(inputChanges.previousValue);\n      }\n      // this.dataChanges.next(mapChanges);\n      this.addSource(inputChanges.currentValue);\n    }\n\n    //    Zoom On Load changes\n    const zoomChanges = changes['zoomOnLoad'];\n    if (zoomChanges != null\n      && !zoomChanges.isFirstChange()) {\n      console.debug('Changing zoom value');\n      this.centerMapOnLoad.next(zoomChanges.currentValue);\n    }\n\n    // Event handlers\n    // const handlerChanges = changes[\"handlers\"];\n    // if (handlerChanges != null\n    //     && (handlerChanges.currentValue !== handlerChanges.previousValue)) {\n    //     console.debug(\"Registering event handlers\");\n    //     (handlerChanges.currentValue as IMapEventHandler[]).forEach((e) => {\n    //         this.map.on(e.event, e.handler);\n    //     });\n    // }\n  }\n\n  /**\n   * Get the current map bounds\n   * @returns {mapboxgl.LngLatBounds}\n   */\n  public getMapBounds(): LngLatBounds {\n    return this.map.getBounds();\n  }\n\n  /**\n   * Remove individual from the map, which clears the source and linked layers\n   * @param {string} individual\n   */\n  public removeIndividual(individual: string): void {\n    console.debug('Removing selection %s from the map', individual);\n\n    // Is the data a source?\n    if (this.mapSources.has(individual)) {\n      this.removeSource(individual);\n    } else {\n      //    Otherwise find the matching layer and remove it\n    }\n  }\n\n  /**\n   * Modify the specified attribute for the given individual\n   * @param {IMapAttributeChange} attributeChange\n   */\n  public changeIndividualAttribute(attributeChange: IMapAttributeChange): void {\n    console.debug('Changing attribute:', attributeChange);\n\n    //    Try to get the source first\n    const layers = this.mapSources.get(attributeChange.individual);\n    if (layers !== undefined) {\n      console.debug('Changing layers:', layers);\n      layers.filter((layer) => !layer.startsWith('label'))\n        .forEach((layer) => {\n          attributeChange.changes.forEach((change) => {\n            this.map.setPaintProperty(layer, change.attribute, change.value);\n          });\n\n        });\n    }\n    //    I don't think we can do this with individuals yet, but maybe?\n  }\n\n  /**\n   * Toggle the visibility of the layers for the given individual\n   * This changes all registered layers for the given source\n   * @param {string} individual\n   * @param {boolean} setVisible\n   */\n  public toggleIndividualVisibility(individual: string, setVisible: boolean): void {\n    console.debug('setting visible?', setVisible);\n    //    See if the data is a source\n    const layers = this.mapSources.get(individual);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          if (setVisible) {\n            this.map.setLayoutProperty(layer, 'visibility', 'visible');\n          } else {\n            this.map.setLayoutProperty(layer, 'visibility', 'none');\n          }\n        });\n      //    If not, figure out which layers have the data\n    } else {\n      console.debug('Looking for matching individual id:',\n        TrestleMapComponent.buildFilterID(individual));\n      for (const source of Array.from(this.mapSources.keys())) {\n        const mapSource = this.map.getSource(source);\n        if (TrestleMapComponent.isGeoJSON(mapSource)) {\n          console.debug('Checking source:', mapSource);\n          console.debug('Has data:', (mapSource as any)._data);\n          const data = mapSource._data;\n          // If it's a feature collection, dive into it\n          if (TrestleMapComponent.isCollection(data)) {\n            for (const feature of data.features) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              if ((feature.properties as any).id === TrestleMapComponent\n                .buildFilterID(individual)) {\n                console.debug('Source %s matches individual %s',\n                  source, individual);\n                this.toggleSourceVisibility(source, setVisible, individual);\n                break;\n              }\n            }\n          } else {\n            // TODO(nickrobison): This will fail if the features don't have an ID property\n            if ((data.properties as any).id === TrestleMapComponent\n              .buildFilterID(individual)) {\n              console.debug('Source feature %s matches individual %s',\n                source, individual);\n              this.toggleSourceVisibility(source, setVisible, individual);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all the layers and sources from the map\n   */\n  public clearMap(): void {\n    console.debug('Clearing map');\n    this.mapSources.forEach((_, source) => {\n      console.debug('removing:', source);\n      this.removeSource(source);\n    });\n  }\n\n  /**\n   * Center the map on the given input set, computes the bounding box if one doesn't exist\n   * @param {FeatureCollection<GeometryObject> | Feature<GeometryObject>} geom\n   */\n  public centerMap(geom: FeatureCollection<GeometryObject> | Feature<GeometryObject>): void {\n    // We have to lock the map in order to avoid sending out a notice that the move happened.\n    if (geom.bbox) {\n      // FIXME(nrobison): This is garbage. Fix it.\n      this.map.fitBounds(LngLatBounds.convert(geom.bbox as any));\n    } else {\n      const bbox = extent(geom);\n      if (bbox) {\n        // This works, but it seems to confuse the type system, so any for the win!\n        this.map.fitBounds(LngLatBounds.convert(bbox as any));\n      }\n    }\n  }\n\n  /**\n   * Change the map base layer\n   * WARNING: This will cause all the sources and layers to be removed and added again, which is slow\n   * @param {string} style - New base layer URL\n   */\n  public setMapStyle(style: string): void {\n    this.clearMap();\n    this.map.setStyle(style);\n  }\n\n  /**\n   * Update the map view angle\n   * @param {number} pitch\n   * @param {number} bearing\n   */\n  public setPitchBearing(pitch?: number, bearing?: number): void {\n    if (pitch) {\n      this.map.setPitch(pitch);\n    }\n\n    if (bearing) {\n      this.map.setBearing(bearing);\n    }\n  }\n\n  /**\n   * Change the 3D offset of the individual, or all sources that are currently at the input height\n   * @param {number} height\n   * @param {number} offset\n   * @param {string} individual\n   */\n  public change3DOffset(height: number, offset: number, individual?: string): void {\n\n    if (individual) {\n      this.mapSources.forEach((layers, key) => {\n        // If we have the individual's source, change its layers\n        if (key === individual) {\n          layers.forEach((layer) => {\n            // You can't get properties that don't exist on layers,\n            // that's an error not a null, because of course\n            // But I'm sure it'll still return a null\n            if (!layer.startsWith('label')) {\n              const layerHeight = this.map.getPaintProperty(layer,\n                'fill-extrusion-height');\n              if (layerHeight) {\n                this.map.setPaintProperty(layer,\n                  'fill-extrusion-height',\n                  layerHeight + offset);\n                const layerBase = this.map.getPaintProperty(layer,\n                  'fill-extrusion-base');\n                if (layerBase) {\n                  this.map.setPaintProperty(layer,\n                    'fill-extrusion-base',\n                    layerBase + offset);\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      //    Find all the individuals that have the same property\n      //    For each layer, get its height\n      this.mapSources.forEach((layers) => {\n        layers.forEach((layer) => {\n          const layerHeight = this.map.getPaintProperty(layer,\n            'fill-extrusion-height');\n          // If it matches the height of the layer, increase it\n          if (layerHeight === height) {\n            console.debug('Changing individuals');\n            const layerBase = this.map.getPaintProperty(layer,\n              'fill-extrusion-base');\n            if (layerBase) {\n              this.map.setPaintProperty(layer,\n                'fill-extrusion-base',\n                layerBase + offset);\n            }\n            this.map.setPaintProperty(layer,\n              'fill-extrusion-height',\n              layerHeight + offset);\n          }\n        });\n      });\n    }\n\n  }\n\n  private toggleSourceVisibility(source: string, setVisible: boolean, individual?: string): void {\n    const layers = this.mapSources.get(source);\n    if (layers !== undefined) {\n      console.debug('Has layers:', layers);\n      //    If we're a source, turn off all the layers\n      layers\n        .forEach((layer) => {\n          // If we're filtering a layer and not a source,\n          // set a filter to remove the individual\n          if (individual) {\n            // If we're setting the layer visible again,\n            // remove it from the list and update the filter\n            const filteredID = TrestleMapComponent.buildFilterID(individual);\n            if (setVisible) {\n              const idx = this.filteredIDs\n                .indexOf(filteredID);\n              if (idx > -1) {\n                this.filteredIDs.splice(idx, 1);\n              }\n              //   If we're setting the layer invisible,\n              // add the individual to the list of filtered IDs\n            } else {\n              console.debug('Removing individual %s from layer %s',\n                individual, layer);\n              this.filteredIDs.push(filteredID);\n            }\n            // If we have items to filter, add them,\n            // otherwise remove the filter\n            if (this.filteredIDs.length > 0) {\n              // TODO(nickrobison): This will fail if the features don't have an ID property\n              const filterValues = ['!in', 'id'].concat(this.filteredIDs);\n\n              console.debug('Filtered Features:', this.map.querySourceFeatures(source,\n                {\n                  sourceLayer: layer,\n                  filter: filterValues\n                }));\n              console.debug('Setting filter of %O on layer:', filterValues, layer);\n              this.map.setFilter(layer, filterValues);\n            } else {\n              console.debug('Removing filter from layer:', layer);\n              (this.map as any).setFilter(layer, null);\n            }\n          } else {\n            if (setVisible) {\n              this.map.setLayoutProperty(layer, 'visibility', 'visible');\n            } else {\n              this.map.setLayoutProperty(layer, 'visibility', 'none');\n            }\n          }\n        });\n    }\n\n  }\n\n  private removeSource(source: MapSource | string): void {\n    let sourceID;\n    if (typeof source === 'string') {\n      sourceID = source;\n    } else {\n      sourceID = source.id;\n    }\n\n    if (this.mapSources.has(sourceID)) {\n      console.debug('Removing source %s from map', sourceID);\n      // Remove all the layers for each source\n      const layers = this.mapSources.get(sourceID);\n      if (layers !== undefined) {\n        layers\n          .forEach((layer) => {\n            this.map.removeLayer(layer);\n          });\n      }\n\n      this.map.removeSource(sourceID);\n      this.mapSources.delete(sourceID);\n    }\n  }\n\n  private addSource(inputLayer: MapSource): void {\n    console.debug('Adding source data:', inputLayer.data);\n\n    // Merge the new source with the default layers\n    // But only if we don't already have that layer\n    if (this.mapSources.has(inputLayer.id)) {\n      console.debug('Map already has source:', inputLayer.id);\n      return;\n    }\n\n    this.map.addSource(inputLayer.id, {\n      type: 'geojson',\n      data: inputLayer.data\n    });\n\n    const attributeLayers: string[] = [];\n\n    // If it's a 3D layer, add the extrusion, otherwise add the normal layers\n    if (TrestleMapComponent.is3D(inputLayer)) {\n      console.debug('Adding 3D layer:', inputLayer.extrude);\n      this.map.addLayer(inputLayer.extrude);\n      attributeLayers.push(inputLayer.extrude.id);\n    } else {\n      // Add fill layer\n      const fillID = inputLayer.id + '-fill';\n      this.map.addLayer({\n        id: fillID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 0.7,\n        } as FillPaint)\n      });\n      // Add polygon line changes\n      const lineId = inputLayer.id + '-line';\n      this.map.addLayer({\n        id: lineId,\n        type: 'line',\n        source: inputLayer.id,\n        paint: {\n          'line-color': 'white',\n          'line-width': 2\n        }\n      });\n      // Add hover layer\n      const hoverID = inputLayer.id + '-hover';\n      this.map.addLayer({\n        id: hoverID,\n        type: 'fill',\n        source: inputLayer.id,\n        paint: ({\n          'fill-color': '#627BC1',\n          'fill-opacity': 1,\n          // Repaint the lines so that they're still visible\n        } as FillPaint),\n        filter: ['==', 'name', '']\n      });\n      attributeLayers.push(fillID, lineId, hoverID);\n    }\n\n    // Labels\n    const labelField = inputLayer.labelField;\n    const labelValue = inputLayer.labelValue;\n    if (labelField || labelValue) {\n      // If it's a collection for each entity, add the label\n      const iData = inputLayer.data;\n      if (TrestleMapComponent.isCollection(iData)) {\n        // Collections only support field labels, since we need to know how to filter each one\n        if (labelField == null) {\n          throw new Error('Geometry collections only support label Fields, not values');\n        }\n        iData.features.forEach((feature) => {\n          const labelLayerID = 'label-' + feature.id;\n          // This is terrible, but so is the web, so who blinks first?\n          // If we have a field, use it, otherwise, use the provided value\n          const labelText: string = labelField ? (feature.properties as any)[(labelField as any)] : labelValue;\n          this.map.addLayer({\n            id: labelLayerID,\n            type: 'symbol',\n            source: inputLayer.id,\n            layout: {\n              // For the text field, if the label function exists, call it, otherwise just place the label\n              'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n              'text-size': 11,\n              'text-transform': 'uppercase',\n              'text-letter-spacing': 0.05,\n              'text-offset': [0, 1.5],\n              'text-allow-overlap': true\n              // \"text-ignore-placement\": true\n            },\n            paint: {\n              'text-color': '#202',\n              'text-halo-color': '#fff',\n              'text-halo-width': 2\n            },\n            filter: ['==', labelField, labelText]\n          });\n          attributeLayers.push(labelLayerID);\n        });\n      } else {\n        const labelLayerID = 'label-' + iData.id;\n        // This is terrible, but so is the web, so who blinks first?\n        const labelText: string = labelField ? (iData.properties as any)[(labelField as any)] : labelValue;\n        this.map.addLayer({\n          id: labelLayerID,\n          type: 'symbol',\n          source: inputLayer.id,\n          layout: {\n            // For the text field, if the label function exists, call it, otherwise just place the label\n            'text-field': inputLayer.labelFunction ? inputLayer.labelFunction(labelText) : labelText,\n            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],\n            'text-size': 11,\n            'text-transform': 'uppercase',\n            'text-letter-spacing': 0.05,\n            'text-offset': [0, 1.5]\n          },\n          paint: {\n            'text-color': '#202',\n            'text-halo-color': '#fff',\n            'text-halo-width': 2\n          }\n        });\n        attributeLayers.push(labelLayerID);\n      }\n    }\n    // Add the map sources\n    this.mapSources.set(inputLayer.id, attributeLayers);\n\n    //    Center map\n    if (this.centerMapOnLoad.getValue()) {\n      this.centerMap(inputLayer.data);\n    }\n  }\n\n  private layerClick = (e: MapMouseEvent): void => {\n    console.debug('Clicked:', e);\n    // FIXME(nrobison): Get rid of this type cast.\n    // Get all the fill fillLayers\n    let fillLayers: string[] = [];\n    this.mapSources.forEach((values) => {\n      fillLayers = fillLayers\n        .concat((values\n          // If we have a clickLayerSuffix, filter on that, otherwise, just find the fill ¬layers\n          .filter((val) => val.includes(this.clickLayerSuffix ? this.clickLayerSuffix : '-fill'))));\n    });\n    console.debug('Querying on fillLayers:', fillLayers);\n    const features: any[] = this.map.queryRenderedFeatures(e.point, {\n      layers: fillLayers\n    });\n    // Set the hover filter using either the provided id field, or a default property\n    console.debug('Filtering with data:', this.data);\n    // const idField = this.data.idField === undefined ? \"id\" : this.data.idField;\n    const idField = 'id';\n    console.debug('Accessing ID field:', idField);\n\n    // If we don't filter on anything, deselect it all\n    if (!this.multiSelect && !(features.length > 0)) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((layers) => {\n        hoverLayers = hoverLayers\n          .concat(layers\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting', hoverLayers);\n      hoverLayers.forEach((layer) => {\n        this.map.setFilter(layer, ['==', idField, '']);\n      });\n      return;\n    }\n    console.debug('Filtered features', features);\n\n    const feature: any = features[0];\n    let layerID = features[0].layer.id;\n    // Emit the clicked layer\n    const featureID = feature.properties[idField];\n    this.clicked.emit(featureID);\n    layerID = layerID.replace('-fill', '');\n    console.debug('Filtering on layer:', layerID + '-hover');\n    this.map.setFilter(layerID + '-hover', ['==', idField, featureID]);\n    // If multi-select is not enabled, deselect everything else\n    if (!this.multiSelect) {\n      let hoverLayers: string[] = [];\n      this.mapSources.forEach((values) => {\n        hoverLayers = hoverLayers\n          .concat(values\n            .filter((val) => val.includes('-hover')));\n      });\n      console.debug('Deselecting:', hoverLayers);\n      // Add hover back to the layerID, otherwise nothing will match\n      layerID = layerID + '-hover';\n      hoverLayers\n        .forEach((layer) => {\n          if (layer !== layerID) {\n            this.map.setFilter(layer, ['==', idField, '']);\n          }\n        });\n    }\n  };\n\n\n  private mouseOver = (e: MapMouseEvent): void => {\n    console.debug('Moused over:', e);\n  };\n\n  private mouseOut = (e: MapMouseEvent): void => {\n    console.debug('Mouse out:', e);\n  };\n\n  private moveHandler = () => {\n    this.mapBounds.emit(this.map.getBounds());\n  };\n\n  private setupDefaults(): void {\n    this.baseConfig = {\n      container: 'map',\n      style: 'mapbox://styles/mapbox/light-v9',\n      center: {lng: 32.3558991, lat: -25.6854313},\n      zoom: 8,\n      accessToken: 'pk.eyJ1IjoibnJvYmlzb24iLCJhIjoiY2ozdDd5dmd2MDA3bTMxcW1kdHZrZ3ppMCJ9.YcJMRphQAfmZ0H8X9HnoKA'\n    };\n  }\n\n  private static is3D(x: any): x is I3DMapSource {\n    return (x as I3DMapSource).extrude !== undefined;\n  }\n\n  private static isGeoJSON(x: any): x is GeoJSONDataSource {\n    return (x as GeoJSONSource).type === 'geojson';\n  }\n\n  private static isCollection(x: any): x is FeatureCollection<GeometryObject> {\n    return (x as FeatureCollection<GeometryObject>).type === 'FeatureCollection';\n  }\n\n  private static buildFilterID(individual: string): string {\n    console.debug('Filtering:', individual);\n    return TrestleIndividual.filterID(individual)\n      .replace(/-/g, ' ')\n      .replace(':', '-');\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "#map {\n  width: 100%;\n  height: 100%;\n}\n",
                    "styleUrl": "./trestle-map.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [],
                "line": 104
            },
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<div id=\"map\"></div>"
        },
        {
            "name": "UserDialogComponent",
            "id": "component-UserDialogComponent-595593fc6ebf0bd9a187ba0022f5426c",
            "file": "src/main/webapp/src/app/admin/users/users.dialog.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": "UserService"
                }
            ],
            "selector": "user-add-dialog",
            "styleUrls": [
                "./users.dialog.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./users.dialog.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "dialogRef",
                    "type": "MatDialogRef<UserDialogComponent>",
                    "optional": false,
                    "description": "",
                    "line": 36,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "maxPasswordLength",
                    "defaultValue": "60",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 34,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "privileges",
                    "defaultValue": "new Map()",
                    "type": "Map<string | number>",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "registerForm",
                    "type": "FormGroup",
                    "optional": false,
                    "description": "",
                    "line": 33,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "updateMode",
                    "defaultValue": "true",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "user",
                    "type": "ITrestleUser",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "validatePasswordLength",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 226,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "validateUser",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 205,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "alterPermissionLevel",
                    "args": [
                        {
                            "name": "level",
                            "type": "Privileges"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 144,
                    "description": "<p>Change permission level of the user to the given values</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 3964,
                                "end": 3969,
                                "flags": 0,
                                "escapedText": "level"
                            },
                            "type": "Privileges",
                            "tagName": {
                                "pos": 3945,
                                "end": 3950,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 3951,
                                "end": 3963,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 3952,
                                    "end": 3962,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 3952,
                                        "end": 3962,
                                        "flags": 2097152,
                                        "escapedText": "Privileges"
                                    }
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "delete",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 119,
                    "description": "<p>Delete the specified user from the database</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "dismiss",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 136,
                    "description": "<p>Dismiss modal, without saving any changes</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getEmailErrorMessage",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 159,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getPasswordErrorMessage",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 183,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "getUsernameErrorMessage",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 195,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "isSelected",
                    "args": [
                        {
                            "name": "privilage",
                            "type": "Privileges"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 154,
                    "description": "<p>Does the user currently have the given permission?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 4225,
                                "end": 4234,
                                "flags": 0,
                                "escapedText": "privilage"
                            },
                            "type": "Privileges",
                            "tagName": {
                                "pos": 4206,
                                "end": 4211,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<p>to check</p>\n",
                            "typeExpression": {
                                "pos": 4212,
                                "end": 4224,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 4213,
                                    "end": 4223,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 4213,
                                        "end": 4223,
                                        "flags": 2097152,
                                        "escapedText": "Privileges"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 4250,
                                "end": 4257,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "isUpdate",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 88,
                    "description": "<p>Are we currently set to update the user?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 2560,
                                "end": 2567,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 48,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "save",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 95,
                    "description": "<p>Save the new/updated user to the database</p>\n",
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "showLengthHint",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 169,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AbstractControl, FormBuilder, FormGroup, ValidationErrors, Validators} from '@angular/forms';\nimport {ITrestleUser} from '../../user/authentication.service';\nimport {UserService} from '../../user/users.service';\nimport {MatDialogRef} from '@angular/material/dialog';\nimport {Observable, of, timer} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\nimport {Privileges} from '../../user/trestle-user';\n\nexport enum UserDialogResponseType {\n  ADD,\n  DELETE\n}\n\nexport interface IUserDialogResponse {\n  type: UserDialogResponseType;\n  user: ITrestleUser;\n}\n\n@Component({\n  selector: 'user-add-dialog',\n  templateUrl: './users.dialog.component.html',\n  styleUrls: ['./users.dialog.component.scss'],\n  providers: [UserService]\n})\nexport class UserDialogComponent implements OnInit {\n  public privileges: Map<string, number> = new Map();\n  public user: ITrestleUser;\n  public updateMode = true;\n  public registerForm: FormGroup;\n  public maxPasswordLength = 60;\n\n  constructor(public dialogRef: MatDialogRef<UserDialogComponent>,\n              private userService: UserService,\n              private formBuilder: FormBuilder) {\n//    Try to list all the enum keys\n    for (const priv in Privileges) {\n      if (parseInt(priv, 10) >= 0) {\n        console.debug('Privs:', priv, Privileges[priv]);\n        this.privileges.set(Privileges[priv], parseInt(priv, 10));\n      }\n    }\n  }\n\n  public ngOnInit(): void {\n    // Merge the user object (which might be null) with a blank default\n    const mergedUser = {\n      ...{\n        firstName: '',\n        lastName: '',\n        username: '',\n        password: '',\n        email: '',\n        privileges: 1\n      }, ...this.user\n    };\n\n    console.debug('Merged user:', mergedUser);\n    //    Create the form\n    this.registerForm = this.formBuilder.group({\n      firstName: mergedUser.firstName,\n      lastName: mergedUser.lastName,\n      username: [mergedUser.username, undefined, this.validateUser],\n      password: [mergedUser.password, this.validatePasswordLength],\n      email: [mergedUser.email, Validators.email]\n    });\n    if (this.user == undefined || this.user.id === undefined) {\n      this.updateMode = false;\n      console.debug('Passed null user, creating blank instance');\n      this.user = {\n        username: '',\n        password: '',\n        firstName: '',\n        lastName: '',\n        email: '',\n        privileges: 1\n      };\n    }\n  }\n\n  /**\n   * Are we currently set to update the user?\n   * @returns {boolean}\n   */\n  public isUpdate(): boolean {\n    return this.updateMode;\n  }\n\n  /**\n   * Save the new/updated user to the database\n   */\n  public save() {\n    if (this.registerForm.valid) {\n      // Construct a new user object\n      const mergedUser = {\n        ...this.user,\n        ...this.registerForm.value\n      };\n      this.userService.modifyUser(mergedUser).subscribe(data => {\n        console.debug('Response to add:', data);\n        const responseID = parseInt(data, 10);\n        if (!this.isUpdate()) {\n          mergedUser.id = responseID;\n        }\n        this.dialogRef.close({\n          type: UserDialogResponseType.ADD,\n          user: mergedUser\n        });\n      }, (err: Error) => console.error(err));\n    }\n  }\n\n  /**\n   * Delete the specified user from the database\n   */\n  public delete() {\n    if (this.user.id !== undefined) {\n      this.userService\n        .deleteUser(this.user.id)\n        .subscribe(() => this.dialogRef.close({\n            type: UserDialogResponseType.DELETE,\n            user: this.user\n          }),\n          (err: Error) => console.error(err));\n    } else {\n      console.error('Tried to save a user, but the ID was null');\n    }\n  }\n\n  /**\n   * Dismiss modal, without saving any changes\n   */\n  public dismiss() {\n    this.dialogRef.close(null);\n  }\n\n  /**\n   * Change permission level of the user to the given values\n   * @param {Privileges} level\n   */\n  public alterPermissionLevel(level: Privileges): void {\n    // eslint-disable-next-line no-bitwise\n    this.user.privileges = this.user.privileges ^ level;\n  }\n\n  /**\n   * Does the user currently have the given permission?\n   * @param {Privileges} privilage to check\n   * @returns {boolean}\n   */\n  public isSelected(privilage: Privileges): boolean {\n    // eslint-disable-next-line no-bitwise\n    return (this.user.privileges & privilage) > 0;\n  }\n\n  public getEmailErrorMessage(): string {\n    if (this.registerForm.controls['email'].hasError('required')) {\n      return 'Value is required';\n    }\n    if (this.registerForm.controls['email'].hasError('email')) {\n      return 'Not a valid email address';\n    }\n    return '';\n  }\n\n  public showLengthHint(value?: string): boolean {\n    if (value) {\n      if (this.isUpdate() && value.length === 60) {\n        return false;\n      }\n      // Warn at 70% length\n      if ((value.length / this.maxPasswordLength) > 0.7) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public getPasswordErrorMessage(): string {\n    if (this.registerForm.controls['password'].hasError('maxLength')) {\n      return 'Password too long';\n    }\n\n    if (this.registerForm.controls['password'].hasError('required')) {\n      return 'Value is required';\n    }\n\n    return '';\n  }\n\n  public getUsernameErrorMessage(): string {\n    if (this.registerForm.controls['username'].hasError('required')) {\n      return 'Value is required';\n    }\n    if (this.registerForm.controls['username'].hasError('userExists')) {\n      return 'Username taken';\n    }\n    return '';\n  }\n\n  public validateUser = (c: AbstractControl): Observable<ValidationErrors | null> => {\n    if (this.isUpdate() || c.value === null || c.value === '') {\n      console.debug('Returning');\n      return of(null);\n    }\n    return timer(500)\n      .pipe(\n        switchMap(() => {\n          return this.userService.userExists(c.value)\n            .pipe(\n              map((exists) => {\n                console.debug('User exists?', exists);\n                return exists ? ({\n                  userExists: {\n                    value: c.value\n                  }\n                } as ValidationErrors) : null;\n              }));\n        }));\n  };\n\n  public validatePasswordLength = (c: AbstractControl): null | ValidationErrors => {\n    if (c.value === null || c.value === '') {\n      return null;\n    }\n\n    // If we're update and the password length is max, that's fine\n    if (this.isUpdate() && c.value.length === this.maxPasswordLength) {\n      return null;\n    }\n\n    //    Finally, validate it\n    return c.value.length <= this.maxPasswordLength ? null : {\n      maxLength: {\n        value: true\n      }\n    };\n  };\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".register-form {\n    width: 100%;\n}\n\n.element-full-width {\n    width: 100%;\n}\n",
                    "styleUrl": "./users.dialog.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<UserDialogComponent>"
                    },
                    {
                        "name": "userService",
                        "type": "UserService"
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder"
                    }
                ],
                "line": 34,
                "jsdoctags": [
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<UserDialogComponent>",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "userService",
                        "type": "UserService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<h3 *ngIf=\"!isUpdate()\" md-dialog-title>Add User</h3>\n<h3 *ngIf=\"isUpdate()\" md-dialog-title>Modify {{user.username}}</h3>\n<mat-dialog-content>\n    <form class=\"register-form\" [formGroup]=\"registerForm\">\n        <mat-form-field class=\"element-full-width\">\n            <input matInput type=\"text\"\n                   placeholder=\"First Name\"\n                   formControlName=\"firstName\" required>\n            <mat-error *ngIf=\"registerForm.controls.firstName.invalid\">Value is required</mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"element-full-width\">\n            <input matInput type=\"text\"\n                   placeholder=\"Last Name\"\n                   formControlName=\"lastName\" required>\n            <mat-error *ngIf=\"registerForm.controls.lastName.invalid\">Value is required</mat-error>\n        </mat-form-field>\n        <table class=\"element-full-width\" cellspacing=\"0\">\n            <tr>\n                <td>\n                    <mat-form-field class=\"element-full-width\">\n                        <input matInput type=\"text\"\n                               placeholder=\"Username\"\n                               formControlName=\"username\" required>\n                        <mat-error *ngIf=\"registerForm.controls.username.invalid\">{{getUsernameErrorMessage()}}\n                        </mat-error>\n                    </mat-form-field>\n                </td>\n                <td>\n                    <mat-form-field class=\"element-full-width\">\n                        <input #password matInput type=\"password\"\n                               placeholder=\"Password\"\n                               formControlName=\"password\" required>\n                        <mat-error *ngIf=\"registerForm.controls.password.invalid\">{{getPasswordErrorMessage()}}\n                        </mat-error>\n                        <mat-hint class=\"mat-error\" *ngIf=\"showLengthHint(password.value)\" align=\"end\">\n                            {{password.value?.length || 0}}/{{maxPasswordLength}}\n                        </mat-hint>\n                    </mat-form-field>\n                </td>\n            </tr>\n        </table>\n        <mat-form-field class=\"element-full-width\">\n            <input matInput type=\"text\"\n                   placeholder=\"Email\"\n                   formControlName=\"email\">\n            <mat-error *ngIf=\"registerForm.controls.email.invalid\">{{getEmailErrorMessage()}}</mat-error>\n        </mat-form-field>\n        <mat-button-toggle-group multiple>\n            <mat-button-toggle\n                    *ngFor=\"let item of privileges | mapValues\"\n                    [checked]=\"isSelected(item.value)\"\n                    (change)=\"alterPermissionLevel(item.value)\">{{item.key}}\n            </mat-button-toggle>\n        </mat-button-toggle-group>\n    </form>\n</mat-dialog-content>\n<mat-dialog-actions>\n    <button [disabled]=\"!registerForm.valid\" mat-button type=\"submit\" (click)=\"save()\" *ngIf=\"!isUpdate()\">Add User\n    </button>\n    <button [disabled]=\"!registerForm.valid\" mat-button type=\"submit\" (click)=\"save()\" *ngIf=\"isUpdate()\">Update User\n    </button>\n    <button mat-button type=\"submit\" (click)=\"delete()\" *ngIf=\"isUpdate()\" color=\"warn\">Delete User</button>\n    <button mat-button type=\"cancel\" (click)=\"dismiss()\">Cancel</button>\n</mat-dialog-actions>\n"
        },
        {
            "name": "UserIconComponent",
            "id": "component-UserIconComponent-72ee9f31c886e2bdab66ff61dc7b1332",
            "file": "src/main/webapp/src/app/navigation/user-icon/user-icon.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "user-icon",
            "styleUrls": [
                "./user-icon.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./user-icon.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "iconSize",
                    "defaultValue": "'lg'",
                    "type": "SizeProp",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        114,
                        132
                    ]
                },
                {
                    "name": "loginIcon",
                    "defaultValue": "faSignInAlt",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        114,
                        132
                    ]
                },
                {
                    "name": "logoutIcon",
                    "defaultValue": "faSignOutAlt",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        114,
                        132
                    ]
                },
                {
                    "name": "user",
                    "type": "Observable<TrestleUser>",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getGravatarURL",
                    "args": [
                        {
                            "name": "user",
                            "type": "TrestleUser"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 36,
                    "description": "<p>Get the Gravitar URL of the user</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "user",
                            "type": "TrestleUser",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1001,
                                "end": 1008,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "logout",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 27
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {SizeProp} from '@fortawesome/fontawesome-svg-core';\nimport {faSignInAlt, faSignOutAlt} from '@fortawesome/free-solid-svg-icons';\nimport {select, Store} from '@ngrx/store';\nimport {selectUserFromUser, State} from '../../reducers';\nimport {Observable} from 'rxjs';\nimport {TrestleUser} from '../../user/trestle-user';\nimport {logout} from '../../actions/auth.actions';\nimport {MD5} from 'crypto-js';\n\n@Component({\n  selector: 'user-icon',\n  templateUrl: './user-icon.component.html',\n  styleUrls: ['./user-icon.component.scss']\n})\nexport class UserIconComponent implements OnInit {\n\n  public readonly iconSize: SizeProp = 'lg';\n  public readonly loginIcon = faSignInAlt;\n  public readonly logoutIcon = faSignOutAlt;\n\n  public user: Observable<TrestleUser>;\n\n  constructor(private store: Store<State>) {\n  }\n\n  ngOnInit(): void {\n    this.user = this.store.pipe(select(selectUserFromUser));\n  }\n\n\n  /**\n   * Get the Gravitar URL of the user\n   * @returns {string}\n   */\n  public getGravatarURL(user: TrestleUser): string {\n    const hash = MD5(user.email.trim().toLowerCase()).toString();\n    return 'https://www.gravatar.com/avatar/' + hash + '?d=identicon' + '&s=36';\n  }\n\n  public logout(): void {\n    this.store.dispatch(logout());\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".img-circle {\n  height: 36px;\n  border-radius: 50%;\n}\n\n.action-buttons * {\n  vertical-align: middle;\n  padding: 0;\n}\n\n.menu-button {\n  width: 100%;\n}\n",
                    "styleUrl": "./user-icon.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "store",
                        "type": "Store<State>"
                    }
                ],
                "line": 22,
                "jsdoctags": [
                    {
                        "name": "store",
                        "type": "Store<State>",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<!--User login specific functions-->\n<div class=\"action-buttons\" *ngIf=\"user | async as user; else loginDiv\">\n    <img id=\"user-icon\" class=\"img-circle\" [matMenuTriggerFor]=\"userMenu\" [src]=\"getGravatarURL(user)\" alt=\"User profile picture\">\n  <mat-menu #userMenu=\"matMenu\" yPosition=\"below\">\n    <button class=\"menu-button\" id=\"logout\" mat-button (click)=\"logout()\" aria-label=\"Logout\">\n      Logout\n    </button>\n  </mat-menu>\n\n\n</div>\n<ng-template #loginDiv>\n  <button id=\"login\" mat-button class=\"toolbar-button\" routerLink=\"/login\" aria-label=\"Login\">\n    Login\n  </button>\n</ng-template>\n"
        },
        {
            "name": "UsersComponent",
            "id": "component-UsersComponent-b143222526bcf2d820a8028d45810242",
            "file": "src/main/webapp/src/app/admin/users/users.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "admin-users",
            "styleUrls": [
                "./users.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./users.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "dialog",
                    "type": "MatDialog",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "dialogRef",
                    "type": "MatDialogRef<any> | null",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "displayedColumns",
                    "defaultValue": "[\"username\", \"firstName\", \"lastName\", \"email\"]",
                    "type": "[]",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        114,
                        132
                    ]
                },
                {
                    "name": "privileges",
                    "type": "Privileges",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "subscription",
                    "type": "Subscription",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "table",
                    "type": "MatTable<ITrestleUser>",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatTable"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "users",
                    "type": "ITrestleUser[]",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "viewContainerRef",
                    "type": "ViewContainerRef",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "isAdmin",
                    "args": [
                        {
                            "name": "user",
                            "type": "ITrestleUser"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 50,
                    "description": "<p>Is the user an admin?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1514,
                                "end": 1518,
                                "flags": 0,
                                "escapedText": "user"
                            },
                            "type": "ITrestleUser",
                            "tagName": {
                                "pos": 1493,
                                "end": 1498,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1499,
                                "end": 1513,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1500,
                                    "end": 1512,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1500,
                                        "end": 1512,
                                        "flags": 2097152,
                                        "escapedText": "ITrestleUser"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1525,
                                "end": 1532,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "isDBA",
                    "args": [
                        {
                            "name": "user",
                            "type": "ITrestleUser"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 60,
                    "description": "<p>Is the user a DBA?</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1755,
                                "end": 1759,
                                "flags": 0,
                                "escapedText": "user"
                            },
                            "type": "ITrestleUser",
                            "tagName": {
                                "pos": 1734,
                                "end": 1739,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 1740,
                                "end": 1754,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 1741,
                                    "end": 1753,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 1741,
                                        "end": 1753,
                                        "flags": 2097152,
                                        "escapedText": "ITrestleUser"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 1766,
                                "end": 1773,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 34,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "openUserModal",
                    "args": [
                        {
                            "name": "user",
                            "type": "ITrestleUser | null"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 70,
                    "description": "<p>Open the user modal and pass in the selected user\nWhen the modal closes, perform the required action against the database</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2107,
                                "end": 2111,
                                "flags": 0,
                                "escapedText": "user"
                            },
                            "type": "ITrestleUser | null",
                            "tagName": {
                                "pos": 2079,
                                "end": 2084,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2085,
                                "end": 2106,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2086,
                                    "end": 2105,
                                    "flags": 2097152,
                                    "kind": 168,
                                    "types": [
                                        {
                                            "pos": 2086,
                                            "end": 2098,
                                            "flags": 2097152,
                                            "kind": 161,
                                            "typeName": {
                                                "pos": 2086,
                                                "end": 2098,
                                                "flags": 2097152,
                                                "escapedText": "ITrestleUser"
                                            }
                                        },
                                        {
                                            "pos": 2100,
                                            "end": 2105,
                                            "flags": 2097152,
                                            "kind": 95
                                        }
                                    ]
                                }
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, OnDestroy, OnInit, ViewChild, ViewContainerRef} from '@angular/core';\nimport {IUserDialogResponse, UserDialogComponent, UserDialogResponseType} from './users.dialog.component';\nimport {ITrestleUser} from '../../user/authentication.service';\nimport {MatDialog, MatDialogConfig, MatDialogRef} from '@angular/material/dialog';\nimport {UserService} from '../../user/users.service';\nimport {Privileges} from '../../user/trestle-user';\nimport {Subscription} from 'rxjs';\nimport {MatTable} from '@angular/material/table';\n\n@Component({\n  selector: 'admin-users',\n  templateUrl: './users.component.html',\n  styleUrls: ['./users.component.scss'],\n})\n\nexport class UsersComponent implements OnInit, OnDestroy {\n\n  public users: ITrestleUser[];\n  public dialogRef: MatDialogRef<any> | null;\n  public privileges: Privileges;\n  private subscription: Subscription;\n  @ViewChild(MatTable)\n  public table: MatTable<ITrestleUser>;\n  public readonly displayedColumns = [\"username\", \"firstName\", \"lastName\", \"email\"];\n\n  constructor(private userService: UserService,\n              public dialog: MatDialog,\n              public viewContainerRef: ViewContainerRef) {\n  }\n\n  public ngOnInit(): void {\n    this.subscription = this.userService.getUsers().subscribe(users => {\n      console.debug('Has users');\n      this.users = users;\n    });\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n  }\n\n  /**\n   * Is the user an admin?\n   * @param {ITrestleUser} user\n   * @returns {boolean}\n   */\n  public isAdmin(user: ITrestleUser): boolean {\n    // eslint-disable-next-line no-bitwise\n    return (user.privileges & Privileges.ADMIN) > 0;\n  }\n\n  /**\n   * Is the user a DBA?\n   * @param {ITrestleUser} user\n   * @returns {boolean}\n   */\n  public isDBA(user: ITrestleUser): boolean {\n    // eslint-disable-next-line no-bitwise\n    return (user.privileges & Privileges.DBA) > 0;\n  }\n\n  /**\n   * Open the user modal and pass in the selected user\n   * When the modal closes, perform the required action against the database\n   * @param {ITrestleUser | null} user\n   */\n  public openUserModal(user: ITrestleUser | null) {\n    const config = new MatDialogConfig();\n    config.viewContainerRef = this.viewContainerRef;\n    this.dialogRef = this.dialog.open(UserDialogComponent, config);\n    // Clone the user so that we don't modify properties in the original table\n    this.dialogRef.componentInstance.user = {...user};\n    this.dialogRef.afterClosed().subscribe((result: IUserDialogResponse) => {\n      console.debug('Dialog closed');\n      console.debug('Result:', result);\n      if (result != null) {\n        const userIdx = this.users.findIndex((tableUser) => tableUser.id === result.user.id);\n        switch (result.type) {\n          case UserDialogResponseType.ADD:\n            console.debug('User idx:', userIdx);\n            if (userIdx < 0) {\n              this.users.push(result.user);\n            } else {\n              this.users[userIdx] = result.user;\n              console.debug('Users:', this.users);\n            }\n            break;\n          case UserDialogResponseType.DELETE:\n            if (userIdx > -1) {\n              console.debug('Splicing out user at location:', userIdx);\n              this.users.splice(userIdx, 1);\n            }\n            break;\n        }\n        this.table.renderRows();\n      }\n      this.dialogRef = null;\n    });\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".user-table {\n  width: 600px;\n  margin-left:auto;\n  margin-right:auto;\n  margin-top: 50px;\n}\n\n.button-add {\n  display: flex;\n  justify-content: flex-end;\n  padding-right: 70px;\n  padding-top: 30px;\n}\n",
                    "styleUrl": "./users.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "userService",
                        "type": "UserService"
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog"
                    },
                    {
                        "name": "viewContainerRef",
                        "type": "ViewContainerRef"
                    }
                ],
                "line": 27,
                "jsdoctags": [
                    {
                        "name": "userService",
                        "type": "UserService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "viewContainerRef",
                        "type": "ViewContainerRef",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "OnDestroy"
            ],
            "templateData": "<table mat-table [dataSource]=\"users\" class=\"user-table mat-elevation-z8\">\n\n  <ng-container matColumnDef=\"firstName\">\n    <th id=\"fn-header\" mat-header-cell *matHeaderCellDef>First Name</th>\n    <td mat-cell *matCellDef=\"let user\">{{user.firstName}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"lastName\">\n    <th id=\"ln-header\" mat-header-cell *matHeaderCellDef>Last Name</th>\n    <td mat-cell *matCellDef=\"let user\">{{user.lastName}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"email\">\n    <th id=\"e-header\" mat-header-cell *matHeaderCellDef>Email</th>\n    <td mat-cell *matCellDef=\"let user\">{{user.email}}</td>\n  </ng-container>\n\n  <ng-container matColumnDef=\"username\">\n    <th id=\"un-header\" mat-header-cell *matHeaderCellDef>Username</th>\n    <td mat-cell *matCellDef=\"let user\">{{user.username}}</td>\n  </ng-container>\n\n  <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n  <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\" (click)=\"openUserModal(row)\"></tr>\n  </table>\n  <span></span>\n  <div class=\"button-add\">\n    <button id=\"add-user\" mat-fab color=\"primary\" (click)=\"openUserModal(null)\">\n      <mat-icon>add</mat-icon>\n    </button>\n  </div>\n"
        },
        {
            "name": "ViewerComponent",
            "id": "component-ViewerComponent-6fa726ac636353c5cf4028cf8eafec10",
            "file": "src/main/webapp/src/app/explore/viewer/viewer.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "dataset-viewer",
            "styleUrls": [
                "./viewer.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./viewer.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "availableDatasets",
                    "defaultValue": "[]",
                    "type": "IDatasetState[]",
                    "optional": false,
                    "description": "",
                    "line": 45,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "dataChanges",
                    "type": "Subject<MapSource>",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "DatasetState",
                    "defaultValue": "DatasetState",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 46,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "exportIndividuals",
                    "type": "IDataExport[]",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "map",
                    "type": "TrestleMapComponent",
                    "optional": false,
                    "description": "",
                    "line": 55,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'map'"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mapBounds",
                    "type": "LngLatBounds",
                    "optional": false,
                    "description": "",
                    "line": 56,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "mapClicked",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "<p>Map click handler, which currently fetches the object as a {TrestleIndividual}</p>\n",
                    "line": 166,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "pos": 5487,
                            "end": 5512,
                            "flags": 0,
                            "kind": 292,
                            "atToken": {
                                "pos": 5487,
                                "end": 5488,
                                "flags": 0,
                                "kind": 57
                            },
                            "tagName": {
                                "pos": 5488,
                                "end": 5493,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "typeExpression": {
                                "pos": 5494,
                                "end": 5502,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 5495,
                                    "end": 5501,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            },
                            "name": {
                                "pos": 5503,
                                "end": 5508,
                                "flags": 0,
                                "escapedText": "event"
                            },
                            "isNameFirst": false,
                            "isBracketed": false,
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "maxTime",
                    "defaultValue": "moment('2016-01-01')",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 48,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "minTime",
                    "defaultValue": "moment('1990-01-01')",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 47,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "objectHistory",
                    "type": "IIndividualHistory",
                    "optional": false,
                    "description": "",
                    "line": 51,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "selectedIndividual",
                    "type": "TrestleIndividual",
                    "optional": false,
                    "description": "",
                    "line": 50,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "sliderChanged",
                    "defaultValue": "() => {...}",
                    "type": "",
                    "optional": false,
                    "description": "<p>Handler to update time slider, and fetch new data</p>\n",
                    "line": 151,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "pos": 4980,
                            "end": 5014,
                            "flags": 0,
                            "kind": 292,
                            "atToken": {
                                "pos": 4980,
                                "end": 4981,
                                "flags": 0,
                                "kind": 57
                            },
                            "tagName": {
                                "pos": 4981,
                                "end": 4986,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "typeExpression": {
                                "pos": 4987,
                                "end": 5004,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 4988,
                                    "end": 5003,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 4988,
                                        "end": 5003,
                                        "flags": 2097152,
                                        "escapedText": "MatSliderChange"
                                    }
                                }
                            },
                            "name": {
                                "pos": 5005,
                                "end": 5010,
                                "flags": 0,
                                "escapedText": "event"
                            },
                            "isNameFirst": false,
                            "isBracketed": false,
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "sliderValue",
                    "defaultValue": "2013",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "getError",
                    "args": [
                        {
                            "name": "ds",
                            "type": "IDatasetState"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 180,
                    "description": "<p>Get error from {IDatasetState}</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 5843,
                                "end": 5845,
                                "flags": 0,
                                "escapedText": "ds"
                            },
                            "type": "IDatasetState",
                            "tagName": {
                                "pos": 5821,
                                "end": 5826,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 5827,
                                "end": 5842,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 5828,
                                    "end": 5841,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 5828,
                                        "end": 5841,
                                        "flags": 2097152,
                                        "escapedText": "IDatasetState"
                                    }
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 5852,
                                "end": 5859,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "loadDataset",
                    "args": [
                        {
                            "name": "dataset",
                            "type": "IDatasetState"
                        },
                        {
                            "name": "keepLoaded",
                            "type": "",
                            "defaultValue": "false"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 86,
                    "description": "<p>Load new data (or an entirely new dataset)\nIf one&#39;s already loaded, unload it, unless we mark the keep flag</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2562,
                                "end": 2569,
                                "flags": 0,
                                "escapedText": "dataset"
                            },
                            "type": "IDatasetState",
                            "tagName": {
                                "pos": 2540,
                                "end": 2545,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>dataset to load</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 2546,
                                "end": 2561,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2547,
                                    "end": 2560,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 2547,
                                        "end": 2560,
                                        "flags": 2097152,
                                        "escapedText": "IDatasetState"
                                    }
                                }
                            }
                        },
                        {
                            "name": {
                                "pos": 2610,
                                "end": 2620,
                                "flags": 0,
                                "escapedText": "keepLoaded"
                            },
                            "type": "",
                            "defaultValue": "false",
                            "tagName": {
                                "pos": 2594,
                                "end": 2599,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>true if we need to keep the dataset loaded, false to unload it</li>\n</ul>\n",
                            "typeExpression": {
                                "pos": 2600,
                                "end": 2609,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2601,
                                    "end": 2608,
                                    "flags": 2097152,
                                    "kind": 122
                                }
                            }
                        }
                    ]
                },
                {
                    "name": "needNewData",
                    "args": [
                        {
                            "name": "newBounds",
                            "type": "mapboxgl.LngLatBounds"
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 184,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "newBounds",
                            "type": "mapboxgl.LngLatBounds",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 65,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "updateBounds",
                    "args": [
                        {
                            "name": "bounds",
                            "type": "LngLatBounds"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 127,
                    "description": "<p>Update map bounds, and fetch new data, if necessary</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 4202,
                                "end": 4208,
                                "flags": 0,
                                "escapedText": "bounds"
                            },
                            "type": "LngLatBounds",
                            "tagName": {
                                "pos": 4172,
                                "end": 4177,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 4178,
                                "end": 4201,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 4179,
                                    "end": 4200,
                                    "flags": 2097152,
                                    "kind": 161,
                                    "typeName": {
                                        "pos": 4179,
                                        "end": 4200,
                                        "flags": 2097152,
                                        "kind": 145,
                                        "left": {
                                            "pos": 4179,
                                            "end": 4187,
                                            "flags": 2097152,
                                            "escapedText": "mapboxgl"
                                        },
                                        "right": {
                                            "pos": 4188,
                                            "end": 4200,
                                            "flags": 2097152,
                                            "escapedText": "LngLatBounds"
                                        }
                                    }
                                }
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {Component, OnInit, ViewChild} from '@angular/core';\nimport {MapService} from './map.service';\nimport {animate, style, transition, trigger} from '@angular/animations';\nimport moment from \"moment\";\nimport {TrestleIndividual} from '../../shared/individual/TrestleIndividual/trestle-individual';\nimport {Subject} from 'rxjs';\nimport {LngLatBounds} from 'mapbox-gl';\nimport {IndividualService} from '../../shared/individual/individual.service';\nimport {MatSliderChange} from '@angular/material/slider';\nimport {DatasetService} from '../../shared/dataset/dataset.service';\nimport {IIndividualHistory} from '../../ui/history-graph/history-graph.component';\nimport {IDataExport} from '../exporter/exporter.component';\nimport {MapSource, TrestleMapComponent} from '../../ui/trestle-map/trestle-map.component';\n\nenum DatasetState {\n  UNLOADED,\n  LOADING,\n  LOADED,\n  ERROR\n}\n\ninterface IDatasetState {\n  name: string;\n  state: DatasetState;\n  error?: string;\n}\n\n@Component({\n  selector: 'dataset-viewer',\n  templateUrl: './viewer.component.html',\n  styleUrls: ['./viewer.component.scss'],\n  animations: [\n    trigger('fadeInOut', [\n      transition(':enter', [\n        style({transform: 'scale(0)', opacity: 0}),\n        animate('500ms', style({transform: 'scale(1)', opacity: 1}))\n      ]),\n    ])\n  ]\n})\nexport class ViewerComponent implements OnInit {\n  public availableDatasets: IDatasetState[] = [];\n  public DatasetState = DatasetState;\n  public minTime = moment('1990-01-01');\n  public maxTime = moment('2016-01-01');\n  public sliderValue = 2013;\n  public selectedIndividual: TrestleIndividual;\n  public objectHistory: IIndividualHistory;\n  public dataChanges: Subject<MapSource>;\n  public exportIndividuals: IDataExport[];\n  @ViewChild('map')\n  public map: TrestleMapComponent;\n  private mapBounds: LngLatBounds;\n\n  constructor(private mapService: MapService,\n              private is: IndividualService,\n              private ds: DatasetService) {\n    this.dataChanges = new Subject();\n    this.exportIndividuals = [];\n  }\n\n  public ngOnInit(): void {\n    this.objectHistory = {\n      entities: []\n    };\n    this.ds.getAvailableDatasets()\n      .subscribe((results: string[]) => {\n        results.forEach((ds) => {\n          this.availableDatasets.push({\n            name: ds,\n            state: DatasetState.UNLOADED\n          });\n        });\n      });\n  }\n\n  /**\n   * Load new data (or an entirely new dataset)\n   * If one's already loaded, unload it, unless we mark the keep flag\n   * @param {IDatasetState} dataset - dataset to load\n   * @param {boolean} keepLoaded - true if we need to keep the dataset loaded, false to unload it\n   */\n  public loadDataset(dataset: IDatasetState, keepLoaded = false): void {\n    if (dataset.state === DatasetState.LOADED && !keepLoaded) {\n      console.debug('Unloading dataset:', dataset.name);\n      this.map.removeIndividual('intersection-query');\n      dataset.state = DatasetState.UNLOADED;\n    } else {\n      console.debug('Loading:', dataset.name);\n      dataset.state = DatasetState.LOADING;\n      this.mapService.stIntersect(dataset.name,\n        this.mapBounds, moment()\n          .year(this.sliderValue)\n          .startOf('year'))\n        .subscribe((data) => {\n          dataset.state = DatasetState.LOADED;\n          console.debug('Data:', data);\n          // Get the list of individuals, for exporting\n          this.exportIndividuals.push({\n            dataset: this.availableDatasets[0].name,\n            individuals: (data.features\n              .filter((feature) => feature.id)\n              // We can do this cast, because we filter to make sure the features have an id\n              .map((feature) => feature.id) as string[])\n          });\n          this.dataChanges.next({\n            id: 'intersection-query',\n            idField: 'id',\n            labelField: 'objectName',\n            data\n          });\n        }, (error) => {\n          console.error('Error loading dataset:', error);\n          dataset.state = DatasetState.ERROR;\n          dataset.error = error;\n        });\n    }\n  }\n\n  /**\n   * Update map bounds, and fetch new data, if necessary\n   * @param {mapboxgl.LngLatBounds} bounds\n   */\n  public updateBounds(bounds: LngLatBounds): void {\n    console.debug('Moving, updating bounds', bounds);\n    // If we haven't loaded any datasets, keep resetting the map bounds\n    if (!this.availableDatasets.some((ds) => ds.state === DatasetState.LOADED)) {\n      this.mapBounds = bounds;\n    }\n\n    // If we've moved outside of the current bounds, get new data\n    if (this.needNewData(bounds)) {\n      this.mapBounds = bounds;\n      this.availableDatasets\n        .filter((ds) => ds.state === DatasetState.LOADED)\n        .forEach((ds) => this.loadDataset(ds, true));\n    }\n    // On the first time around, set the map bounds\n    if (!this.mapBounds) {\n      this.mapBounds = bounds;\n    }\n  }\n\n  /**\n   * Handler to update time slider, and fetch new data\n   * @param {MatSliderChange} event\n   */\n  public sliderChanged = (event: MatSliderChange): void => {\n    console.debug('Value changed to:', event);\n    if (event.value) {\n      this.sliderValue = event.value;\n      //    Reload all the currently loaded datasets\n      this.availableDatasets\n        .filter((ds) => ds.state === DatasetState.LOADED)\n        .forEach((ds) => this.loadDataset(ds, true));\n    }\n  };\n\n  /**\n   * Map click handler, which currently fetches the object as a {TrestleIndividual}\n   * @param {string} event\n   */\n  public mapClicked = (event: string): void => {\n    console.debug('Clicked:', event);\n    this.is.getTrestleIndividual(event)\n      .subscribe((data) => {\n        console.debug('Has selection', data);\n        this.selectedIndividual = data;\n      });\n  };\n\n  /**\n   * Get error from {IDatasetState}\n   * @param {IDatasetState} ds\n   * @returns {string}\n   */\n  public getError(ds: IDatasetState): string {\n    return ds.error === undefined ? 'Error' : ds.error;\n  }\n\n  private needNewData(newBounds: mapboxgl.LngLatBounds) {\n    console.debug('Need new data', newBounds, 'old Data', this.mapBounds);\n    // This short circuits the checks to avoid loading data on the first go 'round.\n    if (newBounds === null || this.mapBounds === undefined) {\n      return false;\n    }\n    // Moved up/down\n    if ((newBounds.getNorth() > this.mapBounds.getNorth())\n      || (newBounds.getSouth() < this.mapBounds.getSouth())) {\n      console.debug(newBounds.getNorth() + ', ' + this.mapBounds.getNorth());\n      console.debug(newBounds.getSouth() + ', ' + this.mapBounds.getSouth());\n      console.debug('Moved north/south, so true');\n      return true;\n      //    Moved east/west\n    } else if ((newBounds.getEast() > this.mapBounds.getEast())\n      || (newBounds.getWest() < this.mapBounds.getWest())) {\n      console.debug(newBounds.getEast() + ', ' + this.mapBounds.getEast());\n      console.debug(newBounds.getWest() + ', ' + this.mapBounds.getWest());\n      console.debug('Moved east/west, so true');\n    }\n    return false;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".dataset-container {\n  height: inherit;\n  padding: 0;\n}\n.map-container {\n  height: 300px;\n}\n.map-container #map {\n  height: 400px;\n}\n\n.mat-icon {\n  vertical-align: middle;\n}\n\n.material-icons.orange600 { color: #FB8C00; }\n\n.material-icons.selected { color: green; }\n\n.loading-spinner {\n  height: 24px;\n  width: 24px;\n  vertical-align: middle;\n  display: inline-block;\n}\n\n.mat-slider-horizontal {\n  min-width: 90%;\n}\n",
                    "styleUrl": "./viewer.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "mapService",
                        "type": "MapService"
                    },
                    {
                        "name": "is",
                        "type": "IndividualService"
                    },
                    {
                        "name": "ds",
                        "type": "DatasetService"
                    }
                ],
                "line": 56,
                "jsdoctags": [
                    {
                        "name": "mapService",
                        "type": "MapService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "is",
                        "type": "IndividualService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "ds",
                        "type": "DatasetService",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"section\">\n    <h4>Dataset Viewer</h4>\n    <div class=\"row\">\n        <div class=\"col s10 map-container\">\n            <trestle-map #map [single]=\"true\"\n                         [dataChanges]=\"dataChanges\"\n                         [multiSelect]=\"false\"\n                         [zoomOnLoad]=\"false\"\n                         (mapBounds)=\"updateBounds($event)\" (clicked)=\"mapClicked($event)\"></trestle-map>\n        </div>\n        <div class=\"col s2 z-depth-2 dataset-container\">\n            <h6>Available Datasets</h6>\n            <ul class=\"collection\">\n                <li class=\"collection-item\" *ngFor=\"let ds of availableDatasets\" (click)=\"loadDataset(ds)\">\n                    <mat-icon *ngIf=\"(ds.state == DatasetState.UNLOADED)\" [@fadeInOut]>check_circle</mat-icon>\n                    <mat-spinner class=\"loading-spinner\" *ngIf=\"ds.state == DatasetState.LOADING\"\n                                 [@fadeInOut] [diameter]=\"24\" [strokeWidth]=\"3\"></mat-spinner>\n                    <mat-icon *ngIf=\"(ds.state == DatasetState.LOADED)\" class=\"selected\" [@fadeInOut]>check_circle\n                    </mat-icon>\n                    <mat-icon *ngIf=\"(ds.state == DatasetState.ERROR)\"\n                              class=\"orange600\"\n                              [matTooltip]=\"getError(ds)\"\n                              [@fadeInOut]>error\n                    </mat-icon>\n                    {{ds.name}}\n                </li>\n            </ul>\n        </div>\n    </div>\n    <div class=\"section\">\n        <div class=\"row light_gray_text\">\n            Select year to map\n        </div>\n        <div class=\"row\">\n            <div class=\"col s10 horizontal\">\n                {{minTime.year()}}\n                <mat-slider thumbLabel tickInterval=\"1\" [max]=\"maxTime.year()\" [min]=\"minTime.year()\"\n                            [value]=\"sliderValue\"\n                            (change)=\"sliderChanged($event)\">\n                </mat-slider>\n                {{maxTime.year()}}\n            </div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col s7 l4\">\n                <data-exporter [dataExport]=\"exportIndividuals\"></data-exporter>\n            </div>\n        </div>\n    </div>\n</div>\n<div class=\"section\">\n    <h4>Event History</h4>\n    <div class=\"row\">\n        <spatial-union\n                [minDate]=\"minTime\"\n                [maxDate]=\"maxTime\"\n                [individual]=\"selectedIndividual\"></spatial-union>\n    </div>\n</div>\n"
        },
        {
            "name": "VisualizeComponent",
            "id": "component-VisualizeComponent-114aa841de3a0b3944251b5b61ee6b62",
            "file": "src/main/webapp/src/app/explore/visualize/visualize.component.ts",
            "encapsulation": [
                "ViewEncapsulation.None"
            ],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "visualize",
            "styleUrls": [
                "./visualize.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./visualize.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "selectedOption",
                    "args": [
                        {
                            "name": "value",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 19,
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, ViewEncapsulation } from \"@angular/core\";\nimport { Router } from \"@angular/router\";\n\n@Component({\n    selector: \"visualize\",\n    templateUrl: \"./visualize.component.html\",\n    styleUrls: [\"./visualize.component.scss\"],\n    encapsulation: ViewEncapsulation.None\n})\n\nexport class VisualizeComponent {\n\n    constructor(private router: Router) {\n    }\n\n    public selectedOption(value: string) {\n        // Using a static method from TrestleIndividual will cause Angular to explode, so don't do it, even though it seems to make perfect sense\n        this.router.navigate([\"/explore/visualize\", value]);\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./visualize.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "router",
                        "type": "Router"
                    }
                ],
                "line": 14,
                "jsdoctags": [
                    {
                        "name": "router",
                        "type": "Router",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "templateData": "<div class=\"section\">\n    <search (selected)=\"selectedOption($event)\"></search>\n</div>\n<router-outlet></router-outlet>\n\n"
        },
        {
            "name": "VisualizeDetailsComponent",
            "id": "component-VisualizeDetailsComponent-030cedf9d7376469b30c829dd34fdb26",
            "file": "src/main/webapp/src/app/explore/visualize/visualize-details/visualize-details.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "visualize-details",
            "styleUrls": [
                "./visualize-details.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./visualize-details.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "dbAt",
                    "type": "Moment",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "individual",
                    "type": "TrestleIndividual",
                    "optional": false,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "individualFactHistory",
                    "type": "IIndividualHistory",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "mapIndividual",
                    "type": "BehaviorSubject<MapSource | undefined>",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "maxGraphDate",
                    "defaultValue": "new Date(\"2017-01-01\")",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "maxTime",
                    "type": "Moment",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "minGraphDate",
                    "defaultValue": "new Date(\"1990-01-01\")",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "minTime",
                    "type": "Moment",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "routeObservable",
                    "type": "Observable<IRouteObservable>",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "modifierKind": [
                        112
                    ]
                },
                {
                    "name": "validAt",
                    "type": "Moment",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "displayFn",
                    "args": [
                        {
                            "name": "name",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 67,
                    "description": "<p>Display function to filter down individual IDs</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2441,
                                "end": 2445,
                                "flags": 0,
                                "escapedText": "name"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 2426,
                                "end": 2431,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2432,
                                "end": 2440,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2433,
                                    "end": 2439,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2454,
                                "end": 2461,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "getPrefix",
                    "args": [
                        {
                            "name": "object",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 85,
                    "description": "<p>Gets the IRI hostname, since we can&#39;t access static methods in the Angular template</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2972,
                                "end": 2978,
                                "flags": 0,
                                "escapedText": "object"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 2957,
                                "end": 2962,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2963,
                                "end": 2971,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2964,
                                    "end": 2970,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2987,
                                "end": 2994,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "getSuffix",
                    "args": [
                        {
                            "name": "object",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 76,
                    "description": "<p>Gets the IRI suffix, since we can&#39;t access static methods in the Angular template</p>\n",
                    "modifierKind": [
                        114
                    ],
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2700,
                                "end": 2706,
                                "flags": 0,
                                "escapedText": "object"
                            },
                            "type": "string",
                            "tagName": {
                                "pos": 2685,
                                "end": 2690,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "",
                            "typeExpression": {
                                "pos": 2691,
                                "end": 2699,
                                "flags": 0,
                                "kind": 277,
                                "type": {
                                    "pos": 2692,
                                    "end": 2698,
                                    "flags": 2097152,
                                    "kind": 137
                                }
                            }
                        },
                        {
                            "tagName": {
                                "pos": 2715,
                                "end": 2722,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "",
                            "returnType": "string"
                        }
                    ]
                },
                {
                    "name": "loadIndividual",
                    "args": [
                        {
                            "name": "value",
                            "type": "string"
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 89,
                    "modifierKind": [
                        112
                    ],
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 44,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import {AfterViewInit, Component} from \"@angular/core\";\nimport moment, {Moment} from \"moment\";\nimport {ActivatedRoute, Params} from '@angular/router';\nimport {TrestleIndividual} from '../../../shared/individual/TrestleIndividual/trestle-individual';\nimport {BehaviorSubject, combineLatest, Observable} from 'rxjs';\nimport {MapSource} from '../../../ui/trestle-map/trestle-map.component';\nimport {IIndividualHistory} from '../../../ui/history-graph/history-graph.component';\nimport {IndividualService} from '../../../shared/individual/individual.service';\nimport {map} from 'rxjs/operators';\n\ninterface IRouteObservable {\n    route: Params;\n    query: Params;\n}\n\n@Component({\n    selector: \"visualize-details\",\n    templateUrl: \"./visualize-details.component.html\",\n    styleUrls: [\"./visualize-details.component.scss\"]\n})\nexport class VisualizeDetailsComponent implements AfterViewInit {\n\n    public individual: TrestleIndividual;\n    public mapIndividual: BehaviorSubject<MapSource | undefined>;\n    public individualFactHistory: IIndividualHistory;\n    public minTime: Moment;\n    public maxTime: Moment;\n    public minGraphDate = new Date(\"1990-01-01\");\n    public maxGraphDate = new Date(\"2017-01-01\");\n    public validAt: Moment;\n    public dbAt: Moment;\n    private routeObservable: Observable<IRouteObservable>;\n\n    constructor(private is: IndividualService,\n                private route: ActivatedRoute) {\n        this.mapIndividual = new BehaviorSubject(undefined);\n        this.minTime = moment().year(1990).startOf(\"year\");\n        this.maxTime = moment().year(2016).endOf(\"year\");\n        const now = moment();\n        this.validAt = now;\n        this.dbAt = now;\n    }\n\n    public ngAfterViewInit(): void {\n        this.routeObservable = combineLatest([this.route.params, this.route.queryParams]).pipe(map((results) => {\n          return {\n            route: results[0],\n            query: results[1]\n          }\n        }));\n        this.routeObservable\n            .subscribe((combined) => {\n                console.debug(\"has params: %O %O\", combined.route, combined.query);\n                if (combined.query[\"root\"]) {\n                    this.loadIndividual(combined.query[\"root\"] + combined.route[\"id\"]);\n                } else {\n                    this.loadIndividual(combined.route[\"id\"]);\n                }\n            });\n    }\n\n    /**\n     * Display function to filter down individual IDs\n     * @param {string} name\n     * @returns {string}\n     */\n    public displayFn(name: string): string {\n        return TrestleIndividual.filterID(name);\n    }\n\n    /**\n     * Gets the IRI suffix, since we can't access static methods in the Angular template\n     * @param {string} object\n     * @returns {string}\n     */\n    public getSuffix(object: string): string {\n        return TrestleIndividual.extractSuffix(object);\n    }\n\n    /**\n     * Gets the IRI hostname, since we can't access static methods in the Angular template\n     * @param {string} object\n     * @returns {string}\n     */\n    public getPrefix(object: string): string {\n        return TrestleIndividual.extractPrefix(object);\n    }\n\n    private loadIndividual(value: string): void {\n        console.debug(\"Loading individual:\", value);\n        this.is.getTrestleIndividual(value)\n            .subscribe((results: TrestleIndividual) => {\n                console.debug(\"has selection\", results);\n                this.individual = results;\n\n                // Build fact history\n                this.individualFactHistory = {\n                    entities: results\n                        .getFacts()\n                        .filter((fact) => fact.getDatabaseTemporal().isContinuing())\n                        .map((fact) => {\n                            return {\n                                label: fact.getName(),\n                                start: fact.getValidTemporal().getFromAsDate(),\n                                end: fact.getValidTemporal().getToAsDate(),\n                                value: fact.getValue()\n                            };\n                        })\n                };\n                console.debug(\"Sending individual to map\");\n                this.mapIndividual.next({\n                    id: results.getID(),\n                    data: {\n                        type: \"Feature\",\n                        geometry: results.getSpatialValue(),\n                        id: results.getIDAsInteger().toString(),\n                        properties: results.getFactValues()\n                    }\n                });\n            });\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".container {\n  width: 100%;\n}\n\n.ui-row {\n  height: 530px;\n}\n",
                    "styleUrl": "./visualize-details.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "is",
                        "type": "IndividualService"
                    },
                    {
                        "name": "route",
                        "type": "ActivatedRoute"
                    }
                ],
                "line": 32,
                "jsdoctags": [
                    {
                        "name": "is",
                        "type": "IndividualService",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "route",
                        "type": "ActivatedRoute",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "AfterViewInit"
            ],
            "templateData": "<div *ngIf=\"individual\">\n  <div class=\"section\">\n    <h4>{{individual.getID()}}</h4>\n    <div class=\"row\">\n      <div class=\"col s12 l7 ui-row\">\n        <trestle-map [dataChanges]=\"mapIndividual\" [single]=\"true\" [multiSelect]=\"false\"></trestle-map>\n      </div>\n      <div class=\"col s12 l5 ui-row\">\n        <individual-graph [config]=\"{data: individual,\n            validAt: validAt,\n            dbAt: dbAt}\"></individual-graph>\n      </div>\n    </div>\n  </div>\n  <div class=\"section\">\n    <a mat-raised-button [routerLink]=\"['/explore', 'compare']\"\n       [queryParams]=\"{id: individual.getID()}\" color=\"primary\">Add to Compare</a>\n    <button mat-raised-button color=\"warn\">DELETE</button>\n  </div>\n  <div class=\"section\">\n    <mat-tab-group>\n      <mat-tab label=\"Fact History\">\n        <div class=\"section\">\n          <history-graph id=\"fact-history\" [data]=\"individualFactHistory\" [minTime]=\"minTime\"\n                         [maxTime]=\"maxTime\"\n                         [graphHeight]=\"300\"></history-graph>\n        </div>\n        <div class=\"section\">\n\n          <visualize-fact-table [facts]=\"individual.getFacts()\"></visualize-fact-table>\n        </div>\n      </mat-tab>\n      <mat-tab label=\"Object Relations\">\n        <div class=\"section\" *ngIf=\"individual\">\n          <table class=\"responsive-table highlight\">\n            <thead>\n            <tr>\n              <th>Relation</th>\n              <th>From</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr *ngFor=\"let relation of individual.getRelations()\">\n              <td>{{relation.getType()}}</td>\n              <td>{{displayFn(relation.getObject())}}\n                <a\n                  matTooltip=\"Visualize individual\"\n                  [routerLink]=\"['/explore',\n                                'visualize',\n                                getSuffix(relation.getObject())]\"\n                  [queryParams]=\"{root: getPrefix(relation.getObject())}\">\n                  <mat-icon>link</mat-icon>\n                </a></td>\n            </tr>\n            </tbody>\n          </table>\n        </div>\n      </mat-tab>\n      <mat-tab label=\"Spatial Union\" *ngIf=\"individual.isUnion()\">\n        <spatial-union\n          [minDate]=\"minGraphDate\"\n          [maxDate]=\"maxGraphDate\"\n          [individual]=\"individual\"></spatial-union>\n      </mat-tab>\n    </mat-tab-group>\n  </div>\n</div>\n"
        },
        {
            "name": "WarningDialogComponent",
            "id": "component-WarningDialogComponent-be2c435e2331ff907307d3a64de50f0a",
            "file": "src/main/webapp/src/app/admin/indicies/warning-dialog/warning-dialog-component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "styleUrls": [
                "./warning-dialog-component.css"
            ],
            "styles": [],
            "templateUrl": [
                "./warning-dialog-component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "action",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "closeValue",
                    "defaultValue": "\"Ok\"",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "data",
                    "type": "any",
                    "optional": false,
                    "description": "",
                    "line": 14,
                    "decorators": [
                        {
                            "name": "Inject",
                            "stringifiedArguments": "MAT_DIALOG_DATA"
                        }
                    ],
                    "modifierKind": [
                        114
                    ]
                },
                {
                    "name": "object",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        114
                    ]
                }
            ],
            "methodsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "",
            "type": "component",
            "sourceCode": "import { Component, Inject } from \"@angular/core\";\nimport {MAT_DIALOG_DATA} from '@angular/material/dialog';\n\n@Component({\n    templateUrl: \"./warning-dialog-component.html\",\n    styleUrls: [\"./warning-dialog-component.css\"]\n})\nexport class WarningDialogComponent {\n\n    public closeValue = \"Ok\";\n    public object: string;\n    public action: string;\n\n    public constructor(@Inject(MAT_DIALOG_DATA) public data: any) {\n        this.object = data.object;\n        this.action = data.action;\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./warning-dialog-component.css"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "args": [
                    {
                        "name": "data",
                        "type": "any"
                    }
                ],
                "line": 12,
                "modifierKind": [
                    114
                ],
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "any",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "templateData": "<mat-dialog-content>\n    Are you sure you want to {{action}} the {{object}}?\n    <br>\n    This will lock the cache for all users\n</mat-dialog-content>\n<mat-dialog-actions>\n    <button mat-button mat-dialog-close>No</button>\n    <button mat-button [mat-dialog-close]=\"closeValue\" color=\"warn\">Yes</button>\n</mat-dialog-actions>"
        }
    ],
    "modules": [
        {
            "name": "AdminModule",
            "children": [
                {
                    "type": "providers",
                    "elements": [
                        {
                            "name": "IndexService"
                        },
                        {
                            "name": "MetricsService"
                        }
                    ]
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "AdminComponent"
                        },
                        {
                            "name": "DashboardComponent"
                        },
                        {
                            "name": "IndexComponent"
                        },
                        {
                            "name": "IndexTableComponent"
                        },
                        {
                            "name": "MetricsComponent"
                        },
                        {
                            "name": "MetricsGraphComponent"
                        },
                        {
                            "name": "TreeGraphComponent"
                        },
                        {
                            "name": "UserDialogComponent"
                        },
                        {
                            "name": "UsersComponent"
                        },
                        {
                            "name": "WarningDialogComponent"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": [
                        {
                            "name": "MaterialModule"
                        },
                        {
                            "name": "NavigationModule"
                        },
                        {
                            "name": "SharedModule"
                        },
                        {
                            "name": "UserModule"
                        },
                        {
                            "name": "UserModule"
                        }
                    ]
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "AppModule",
            "children": [
                {
                    "type": "providers",
                    "elements": []
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "AppComponent"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": [
                        {
                            "name": "!environment"
                        },
                        {
                            "name": "AppRoutingModule"
                        },
                        {
                            "name": "MaterialModule"
                        },
                        {
                            "name": "NavigationModule"
                        },
                        {
                            "name": "UserModule"
                        }
                    ]
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": [
                        {
                            "name": "AppComponent"
                        }
                    ]
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "AppRoutingModule",
            "children": [
                {
                    "type": "providers",
                    "elements": []
                },
                {
                    "type": "declarations",
                    "elements": []
                },
                {
                    "type": "imports",
                    "elements": []
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "ExploreModule",
            "children": [
                {
                    "type": "providers",
                    "elements": [
                        {
                            "name": "AggregationService"
                        },
                        {
                            "name": "ExporterService"
                        },
                        {
                            "name": "IndividualService"
                        },
                        {
                            "name": "MapService"
                        },
                        {
                            "name": "QueryService"
                        }
                    ]
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "AggregateComponent"
                        },
                        {
                            "name": "CodeMirrorComponent"
                        },
                        {
                            "name": "CompareComponent"
                        },
                        {
                            "name": "ExporterComponent"
                        },
                        {
                            "name": "FactTableComponent"
                        },
                        {
                            "name": "IndividualGraphComponent"
                        },
                        {
                            "name": "IndividualValueDialog"
                        },
                        {
                            "name": "QueryComponent"
                        },
                        {
                            "name": "QueryViewerComponent"
                        },
                        {
                            "name": "ViewerComponent"
                        },
                        {
                            "name": "VisualizeComponent"
                        },
                        {
                            "name": "VisualizeDetailsComponent"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": [
                        {
                            "name": "MaterialModule"
                        },
                        {
                            "name": "NavigationModule"
                        },
                        {
                            "name": "SharedModule"
                        },
                        {
                            "name": "UiModule"
                        },
                        {
                            "name": "UserModule"
                        }
                    ]
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "MaterialModule",
            "children": [
                {
                    "type": "providers",
                    "elements": []
                },
                {
                    "type": "declarations",
                    "elements": []
                },
                {
                    "type": "imports",
                    "elements": []
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "NavigationModule",
            "children": [
                {
                    "type": "providers",
                    "elements": []
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "LoginComponent"
                        },
                        {
                            "name": "NavigationComponent"
                        },
                        {
                            "name": "SidebarComponent"
                        },
                        {
                            "name": "TopNavComponent"
                        },
                        {
                            "name": "UserIconComponent"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": [
                        {
                            "name": "MaterialModule"
                        }
                    ]
                },
                {
                    "type": "exports",
                    "elements": [
                        {
                            "name": "LoginComponent"
                        },
                        {
                            "name": "NavigationComponent"
                        },
                        {
                            "name": "SidebarComponent"
                        },
                        {
                            "name": "TopNavComponent"
                        }
                    ]
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "SharedModule",
            "children": [
                {
                    "type": "providers",
                    "elements": [
                        {
                            "name": "CacheService"
                        },
                        {
                            "name": "ColorService"
                        },
                        {
                            "name": "DatasetService"
                        },
                        {
                            "name": "IndividualService"
                        }
                    ]
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "ArraySortPipe"
                        },
                        {
                            "name": "MapValuesPipe"
                        },
                        {
                            "name": "RoundingPipe"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": []
                },
                {
                    "type": "exports",
                    "elements": [
                        {
                            "name": "ArraySortPipe"
                        },
                        {
                            "name": "MapValuesPipe"
                        },
                        {
                            "name": "RoundingPipe"
                        }
                    ]
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "UiModule",
            "children": [
                {
                    "type": "providers",
                    "elements": [
                        {
                            "name": "LoadingSpinnerService"
                        }
                    ]
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "EventGraphComponent"
                        },
                        {
                            "name": "HistoryGraphComponent"
                        },
                        {
                            "name": "LoadingSpinnerComponent"
                        },
                        {
                            "name": "SearchComponent"
                        },
                        {
                            "name": "SpatialUnionComponent"
                        },
                        {
                            "name": "TrestleMapComponent"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": [
                        {
                            "name": "MaterialModule"
                        },
                        {
                            "name": "SharedModule"
                        }
                    ]
                },
                {
                    "type": "exports",
                    "elements": [
                        {
                            "name": "HistoryGraphComponent"
                        },
                        {
                            "name": "SearchComponent"
                        },
                        {
                            "name": "SpatialUnionComponent"
                        },
                        {
                            "name": "TrestleMapComponent"
                        }
                    ]
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "UserModule",
            "children": [
                {
                    "type": "providers",
                    "elements": [
                        {
                            "name": "AuthService"
                        },
                        {
                            "name": "UserService"
                        }
                    ]
                },
                {
                    "type": "declarations",
                    "elements": []
                },
                {
                    "type": "imports",
                    "elements": []
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        }
    ],
    "miscellaneous": {
        "variables": [
            {
                "name": "_authReducer",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "",
                "defaultValue": "createReducer(initialUserState, on(login, state => {\n    console.log('Trying to login');\n    return state;\n  }),\n  on(loginSuccess, (state, {user, token}) => ({\n    userError: null,\n    user,\n    userToken: token\n  })),\n  on(loginFailure, (state, {error}) => ({\n    user: null,\n    userError: error,\n    userToken: ''\n  })),\n  on(logout, (state) => ({\n    ...state,\n    user: null,\n    userToken: ''\n  })))"
            },
            {
                "name": "_key",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/user/authentication.service.ts",
                "type": "string",
                "defaultValue": "'access_token'"
            },
            {
                "name": "AdminRoutes",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/admin/admin.routing.ts",
                "type": "ITrestleRoute[]",
                "defaultValue": "[\n  {path: '', redirectTo: 'dashboard', pathMatch: 'full'},\n  {\n    path: 'dashboard',\n    component: DashboardComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.ADMIN]}\n  },\n  {\n    path: 'users',\n    component: UsersComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.ADMIN]}\n  },\n  {\n    path: 'metrics',\n    component: MetricsComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.ADMIN]}\n  },\n  {\n    path: 'index',\n    component: IndexComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.DBA]}\n  }\n]"
            },
            {
                "name": "BBOX_PROPERTY",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                "type": "string",
                "defaultValue": "'BOUNDING_BOX'"
            },
            {
                "name": "CACHE_SERVICE_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/shared/cache/cache.service.config.ts",
                "type": "",
                "defaultValue": "new InjectionToken<ICacheServiceConfig>(\"cache.service.config\")"
            },
            {
                "name": "COLOR_DI_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/explore.config.ts",
                "type": "IColorServiceConfig",
                "defaultValue": "{\n  colorType: COLOR_SCHEME.CATEGORY_20B\n}"
            },
            {
                "name": "COLOR_SERVICE_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/explore.config.ts",
                "type": "",
                "defaultValue": "new InjectionToken<IColorServiceConfig>(\"color-service.config\")"
            },
            {
                "name": "COLOR_SERVICE_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/shared/color/color-service.config.ts",
                "type": "",
                "defaultValue": "new InjectionToken<IColorServiceConfig>(\"color-service.config\")"
            },
            {
                "name": "createMockUser",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/test.helpers.ts",
                "type": "",
                "defaultValue": "(role: Privileges): TrestleUser => {\n  return new TrestleUser({\n    username: 'test',\n    firstName: '',\n    lastName: '',\n    email: '',\n    password: '',\n    privileges: role\n  });\n}"
            },
            {
                "name": "ctx",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "type": "Worker",
                "defaultValue": "self as any"
            },
            {
                "name": "dashboard",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/login.steps.ts",
                "type": "",
                "defaultValue": "new DashboardPageObject()"
            },
            {
                "name": "dashboard",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/navigation.steps.ts",
                "type": "",
                "defaultValue": "new DashboardPageObject()"
            },
            {
                "name": "dashboard",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/permission.steps.ts",
                "type": "",
                "defaultValue": "new DashboardPageObject()"
            },
            {
                "name": "DATASET_CACHE",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/shared/dataset/dataset.service.ts",
                "type": "",
                "defaultValue": "new InjectionToken<CacheService<string, string[]>>('dataset.cache')"
            },
            {
                "name": "DATASET_CACHE_DI_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/shared/shared.config.ts",
                "type": "ICacheServiceConfig",
                "defaultValue": "{\n  maxAge: 600000,\n  maxSize: 10\n}"
            },
            {
                "name": "Default",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                "type": "",
                "defaultValue": "() => ({\n  component: FactTableComponent,\n  props: {\n    facts: defaultFactData\n  }\n})"
            },
            {
                "name": "defaultFactData",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                "type": "[]",
                "defaultValue": "[\n  fact1\n]"
            },
            {
                "name": "environment",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/environments/environment.prod.ts",
                "type": "object",
                "defaultValue": "{\n  production: true,\n  baseUrl: window.location.origin,\n  domain: \"localhost:8080\"\n}"
            },
            {
                "name": "environment",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/environments/environment.ts",
                "type": "object",
                "defaultValue": "{\n  production: false,\n  baseUrl: \"http://localhost:8080\",\n  domain: \"localhost:8080\"\n}"
            },
            {
                "name": "expect",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/login.steps.ts",
                "type": "",
                "defaultValue": "chai.expect"
            },
            {
                "name": "ExploreRoutes",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/explore.routing.ts",
                "type": "ITrestleRoute[]",
                "defaultValue": "[\n  {path: '', redirectTo: 'viewer', pathMatch: 'full'},\n  {\n    path: 'visualize', component: VisualizeComponent, canActivate: [LoggedInGuard],\n    children: [\n      {path: ':id', component: VisualizeDetailsComponent}\n\n    ]\n  },\n  {path: 'query', component: QueryComponent, canActivate: [LoggedInGuard]},\n  {path: 'viewer', component: ViewerComponent, canActivate: [LoggedInGuard]},\n  {path: 'compare', component: CompareComponent, canActivate: [LoggedInGuard]},\n  {path: 'aggregate', component: AggregateComponent, canActivate: [LoggedInGuard]}\n]"
            },
            {
                "name": "fact1",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                "type": "[]",
                "defaultValue": "[\n  new TrestleFact({\n    identifier: 'http://test.id',\n    name: 'Test Fact',\n    type: 'String',\n    value: 'Test Fact Value',\n    databaseTemporal: {\n      ID: '',\n      From: new Date('1989-03-26'),\n      To: new Date('1990-05-11')\n    },\n    validTemporal: {\n      ID: '',\n      From: new Date('2020-01-01')\n    }\n  })\n]"
            },
            {
                "name": "firstLoad",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/env.ts",
                "type": "",
                "defaultValue": "true"
            },
            {
                "name": "INDIVIDUAL_CACHE",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/shared/individual/individual.service.ts",
                "type": "",
                "defaultValue": "new InjectionToken<CacheService<string, TrestleIndividual>>('individual.cache')"
            },
            {
                "name": "INDIVIDUAL_CACHE_DI_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/explore/explore.config.ts",
                "type": "ICacheServiceConfig",
                "defaultValue": "{\n  maxAge: 30000,\n  maxSize: 1000\n}"
            },
            {
                "name": "initialUserState",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "UserState",
                "defaultValue": "{\n  user: null,\n  userError: null,\n  userToken: ''\n}"
            },
            {
                "name": "Large",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "localStorageKey",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "string",
                "defaultValue": "'__trestle__'"
            },
            {
                "name": "LoggedIn",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Header.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "LoggedIn",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Page.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "LoggedOut",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Header.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "LoggedOut",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Page.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "login",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/login.steps.ts",
                "type": "",
                "defaultValue": "new LoginPageObject()"
            },
            {
                "name": "login",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "",
                "defaultValue": "createAction(\n  '[Auth] Login',\n  props<{username: string, password: string, returnUrl: string}>()\n)"
            },
            {
                "name": "loginFailure",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "",
                "defaultValue": "createAction(\n  '[Auth] Login Failure',\n  props<{ error: Error }>()\n)"
            },
            {
                "name": "loginSuccess",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "",
                "defaultValue": "createAction(\n  '[Auth] Login Success',\n  props<{ user: TrestleUser, returnUrl: string, token: string }>()\n)"
            },
            {
                "name": "logout",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "",
                "defaultValue": "createAction(\n  '[Auth] Logout'\n)"
            },
            {
                "name": "metaReducers",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "MetaReducer[]",
                "defaultValue": "[storageMetaReducer]"
            },
            {
                "name": "Primary",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "reducers",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "ActionReducerMap<State>",
                "defaultValue": "{\n  user: authReducer\n}"
            },
            {
                "name": "Secondary",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "selectErrorFromUser",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "",
                "defaultValue": "createSelector(\n  selectUserState,\n  (state) => state.userError\n)"
            },
            {
                "name": "selectTokenFromUser",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "",
                "defaultValue": "createSelector(\n  selectUserState,\n  (state) => state.userToken\n)"
            },
            {
                "name": "selectUser",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "",
                "defaultValue": "(state: UserState) => state.user"
            },
            {
                "name": "selectUserFromUser",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "",
                "defaultValue": "createSelector(\n  selectUserState,\n  selectUser)"
            },
            {
                "name": "selectUserState",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "type": "",
                "defaultValue": "(state: State) => state.user"
            },
            {
                "name": "Small",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "stateKeys",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "[]",
                "defaultValue": "['user.user', 'user.userToken']"
            },
            {
                "name": "Template",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "type": "Story<Button>",
                "defaultValue": "(args: Button) => ({\n  component: Button,\n  props: args,\n})"
            },
            {
                "name": "Template",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Header.stories.ts",
                "type": "Story<Header>",
                "defaultValue": "(args: Header) => ({\n  component: Header,\n  props: args,\n})"
            },
            {
                "name": "Template",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Page.stories.ts",
                "type": "Story<Page>",
                "defaultValue": "(args: Page) => ({\n  component: Page,\n  props: args,\n})"
            },
            {
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/env.ts",
                "type": "",
                "defaultValue": "require('cucumber')"
            },
            {
                "name": "userPage",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test/e2e/step_definitions/user.steps.ts",
                "type": "",
                "defaultValue": "new UsersPage()"
            }
        ],
        "functions": [
            {
                "name": "authReducer",
                "file": "src/main/webapp/src/app/reducers/index.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "",
                "args": [
                    {
                        "name": "state"
                    },
                    {
                        "name": "action",
                        "type": ""
                    }
                ],
                "returnType": "UserState",
                "jsdoctags": [
                    {
                        "name": "state",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "action",
                        "type": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getSavedState",
                "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "",
                "args": [
                    {
                        "name": "key"
                    }
                ],
                "returnType": "any",
                "jsdoctags": [
                    {
                        "name": "key",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isID",
                "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "<p>Determines if a given {string} property name represents the object ID\nIt does so by peaking at the last 2 characters to see if their lowercase representation equals &#39;id&#39;</p>\n",
                "args": [
                    {
                        "name": "x"
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": {
                            "pos": 1907,
                            "end": 1908,
                            "flags": 0,
                            "escapedText": "x"
                        },
                        "tagName": {
                            "pos": 1901,
                            "end": 1906,
                            "flags": 0,
                            "escapedText": "param"
                        },
                        "comment": "<ul>\n<li>Property name</li>\n</ul>\n"
                    },
                    {
                        "tagName": {
                            "pos": 1929,
                            "end": 1936,
                            "flags": 0,
                            "escapedText": "returns"
                        },
                        "comment": "<p>is id</p>\n",
                        "returnType": "boolean"
                    }
                ]
            },
            {
                "name": "isSerializedUser",
                "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "",
                "args": [
                    {
                        "name": "value",
                        "type": "any"
                    }
                ],
                "returnType": "ITrestleUser",
                "jsdoctags": [
                    {
                        "name": "value",
                        "type": "any",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isSpatial",
                "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "<p>Crummy regex function to determine if a provided value is a WKT literal</p>\n",
                "args": [
                    {
                        "name": "x",
                        "type": "any"
                    }
                ],
                "returnType": "wktType",
                "jsdoctags": [
                    {
                        "name": {
                            "pos": 2301,
                            "end": 2302,
                            "flags": 0,
                            "escapedText": "x"
                        },
                        "type": "any",
                        "tagName": {
                            "pos": 2295,
                            "end": 2300,
                            "flags": 0,
                            "escapedText": "param"
                        },
                        "comment": "<ul>\n<li>any object at all</li>\n</ul>\n"
                    },
                    {
                        "tagName": {
                            "pos": 2327,
                            "end": 2334,
                            "flags": 0,
                            "escapedText": "returns"
                        },
                        "comment": "<p>is wkt</p>\n",
                        "returnType": "boolean"
                    }
                ]
            },
            {
                "name": "jwtOptionsFactory",
                "file": "src/main/webapp/src/app/app.module.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "",
                "args": [
                    {
                        "name": "store"
                    }
                ],
                "jsdoctags": [
                    {
                        "name": "store",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "parseObjectToGeoJSON",
                "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "",
                "args": [
                    {
                        "name": "responseObject"
                    }
                ],
                "returnType": "FeatureCollection<GeometryObject>",
                "jsdoctags": [
                    {
                        "name": "responseObject",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "setSavedState",
                "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "",
                "args": [
                    {
                        "name": "state",
                        "type": "any"
                    },
                    {
                        "name": "localStorageKey"
                    }
                ],
                "jsdoctags": [
                    {
                        "name": "state",
                        "type": "any",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "localStorageKey",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "storageMetaReducer",
                "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "description": "",
                "args": [
                    {
                        "name": "reducer"
                    }
                ],
                "jsdoctags": [
                    {
                        "name": "reducer",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            }
        ],
        "typealiases": [
            {
                "name": "AggregationOperation",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"EQ\" | \"NEQ\" | \"GT\" | \"GTEQ\" | \"LT\" | \"LTEQ\"",
                "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "loadingColor",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"accent\" | \"warn\" | \"primary\"",
                "file": "src/main/webapp/src/app/explore/compare/compare.component.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "loadingState",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"determinate\" | \"indeterminate\"",
                "file": "src/main/webapp/src/app/explore/compare/compare.component.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "MapBoxSource",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw",
                "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "MapEvent",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"mousemove\" | \"mouseleave\" | \"click\" | \"moveend\"",
                "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "MapSource",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "I3DMapSource | ITrestleMapSource",
                "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "PageActionType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"admin\" | \"dba\"",
                "file": "src/test/e2e/page_objects/main.page.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "TrestleRelationType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"CONTAINS\" | \"COVERS\" | \"DISJOINT\" | \"EQUALS\" | \"INSIDE\" | \"MEETS\" | \"SPATIAL_OVERLAPS\" | \"AFTER\" | \"BEFORE\" | \"BEGINS\" | \"DURING\" | \"ENDS\" | \"TEMPORAL_OVERLAPS\" | \"SPLIT_INTO\" | \"SPLIT_FROM\" | \"MERGED_INTO\" | \"MERGED_FROM\" | \"COMPONENT_WITH\"",
                "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-relation.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "UserType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"user\" | \"admin\" | \"dba\"",
                "file": "src/test/e2e/page_objects/user.details.modal.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "wktType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"POINT\" | \"MULTIPOINT\" | \"LINESTRING\" | \"MULTILINESTRING\" | \"POLYGON\" | \"MULTIPOLYGON\"",
                "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "description": "",
                "kind": 168
            },
            {
                "name": "wktValue",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "LngLatBounds | GeometryObject",
                "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "description": "",
                "kind": 168
            }
        ],
        "enumerations": [
            {
                "name": "COLOR_SCHEME",
                "childs": [
                    {
                        "name": "CATEGORY_20B"
                    },
                    {
                        "name": "CATEGORY_20C"
                    },
                    {
                        "name": "CATEGORY_20"
                    },
                    {
                        "name": "CATEGORY_10"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "description": "",
                "file": "src/main/webapp/src/app/explore/explore.config.ts"
            },
            {
                "name": "COLOR_SCHEME",
                "childs": [
                    {
                        "name": "CATEGORY_20B"
                    },
                    {
                        "name": "CATEGORY_20C"
                    },
                    {
                        "name": "CATEGORY_20"
                    },
                    {
                        "name": "CATEGORY_10"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "description": "",
                "file": "src/main/webapp/src/app/shared/color/color-service.config.ts"
            },
            {
                "name": "DatasetState",
                "childs": [
                    {
                        "name": "UNLOADED"
                    },
                    {
                        "name": "LOADING"
                    },
                    {
                        "name": "LOADED"
                    },
                    {
                        "name": "ERROR"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "description": "",
                "file": "src/main/webapp/src/app/explore/viewer/viewer.component.ts"
            },
            {
                "name": "NodeType",
                "childs": [
                    {
                        "name": "INDIVIDUAL"
                    },
                    {
                        "name": "VTEMPORAL"
                    },
                    {
                        "name": "FACT"
                    },
                    {
                        "name": "RELATION"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "description": "",
                "file": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts"
            },
            {
                "name": "Privileges",
                "childs": [
                    {
                        "name": "USER",
                        "value": "1"
                    },
                    {
                        "name": "ADMIN",
                        "value": "2"
                    },
                    {
                        "name": "DBA",
                        "value": "4"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "description": "",
                "file": "src/main/webapp/src/app/user/trestle-user.ts"
            },
            {
                "name": "TrestleEventType",
                "childs": [
                    {
                        "name": "CREATED"
                    },
                    {
                        "name": "DESTROYED"
                    },
                    {
                        "name": "BECAME"
                    },
                    {
                        "name": "SPLIT"
                    },
                    {
                        "name": "MERGED"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "description": "",
                "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-event.ts"
            },
            {
                "name": "UserDialogResponseType",
                "childs": [
                    {
                        "name": "ADD"
                    },
                    {
                        "name": "DELETE"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "description": "",
                "file": "src/main/webapp/src/app/admin/users/users.dialog.component.ts"
            }
        ],
        "groupedVariables": {
            "src/main/webapp/src/app/reducers/index.ts": [
                {
                    "name": "_authReducer",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "",
                    "defaultValue": "createReducer(initialUserState, on(login, state => {\n    console.log('Trying to login');\n    return state;\n  }),\n  on(loginSuccess, (state, {user, token}) => ({\n    userError: null,\n    user,\n    userToken: token\n  })),\n  on(loginFailure, (state, {error}) => ({\n    user: null,\n    userError: error,\n    userToken: ''\n  })),\n  on(logout, (state) => ({\n    ...state,\n    user: null,\n    userToken: ''\n  })))"
                },
                {
                    "name": "initialUserState",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "UserState",
                    "defaultValue": "{\n  user: null,\n  userError: null,\n  userToken: ''\n}"
                },
                {
                    "name": "metaReducers",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "MetaReducer[]",
                    "defaultValue": "[storageMetaReducer]"
                },
                {
                    "name": "reducers",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "ActionReducerMap<State>",
                    "defaultValue": "{\n  user: authReducer\n}"
                },
                {
                    "name": "selectErrorFromUser",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "",
                    "defaultValue": "createSelector(\n  selectUserState,\n  (state) => state.userError\n)"
                },
                {
                    "name": "selectTokenFromUser",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "",
                    "defaultValue": "createSelector(\n  selectUserState,\n  (state) => state.userToken\n)"
                },
                {
                    "name": "selectUser",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "",
                    "defaultValue": "(state: UserState) => state.user"
                },
                {
                    "name": "selectUserFromUser",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "",
                    "defaultValue": "createSelector(\n  selectUserState,\n  selectUser)"
                },
                {
                    "name": "selectUserState",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "type": "",
                    "defaultValue": "(state: State) => state.user"
                }
            ],
            "src/main/webapp/src/app/user/authentication.service.ts": [
                {
                    "name": "_key",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/user/authentication.service.ts",
                    "type": "string",
                    "defaultValue": "'access_token'"
                }
            ],
            "src/main/webapp/src/app/admin/admin.routing.ts": [
                {
                    "name": "AdminRoutes",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/admin/admin.routing.ts",
                    "type": "ITrestleRoute[]",
                    "defaultValue": "[\n  {path: '', redirectTo: 'dashboard', pathMatch: 'full'},\n  {\n    path: 'dashboard',\n    component: DashboardComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.ADMIN]}\n  },\n  {\n    path: 'users',\n    component: UsersComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.ADMIN]}\n  },\n  {\n    path: 'metrics',\n    component: MetricsComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.ADMIN]}\n  },\n  {\n    path: 'index',\n    component: IndexComponent,\n    canActivate: [LoggedInGuard, PermissionsGuard],\n    data: {roles: [Privileges.DBA]}\n  }\n]"
                }
            ],
            "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts": [
                {
                    "name": "BBOX_PROPERTY",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                    "type": "string",
                    "defaultValue": "'BOUNDING_BOX'"
                }
            ],
            "src/main/webapp/src/app/shared/cache/cache.service.config.ts": [
                {
                    "name": "CACHE_SERVICE_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/shared/cache/cache.service.config.ts",
                    "type": "",
                    "defaultValue": "new InjectionToken<ICacheServiceConfig>(\"cache.service.config\")"
                }
            ],
            "src/main/webapp/src/app/explore/explore.config.ts": [
                {
                    "name": "COLOR_DI_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/explore.config.ts",
                    "type": "IColorServiceConfig",
                    "defaultValue": "{\n  colorType: COLOR_SCHEME.CATEGORY_20B\n}"
                },
                {
                    "name": "COLOR_SERVICE_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/explore.config.ts",
                    "type": "",
                    "defaultValue": "new InjectionToken<IColorServiceConfig>(\"color-service.config\")"
                },
                {
                    "name": "INDIVIDUAL_CACHE_DI_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/explore.config.ts",
                    "type": "ICacheServiceConfig",
                    "defaultValue": "{\n  maxAge: 30000,\n  maxSize: 1000\n}"
                }
            ],
            "src/main/webapp/src/app/shared/color/color-service.config.ts": [
                {
                    "name": "COLOR_SERVICE_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/shared/color/color-service.config.ts",
                    "type": "",
                    "defaultValue": "new InjectionToken<IColorServiceConfig>(\"color-service.config\")"
                }
            ],
            "src/main/webapp/src/test.helpers.ts": [
                {
                    "name": "createMockUser",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/test.helpers.ts",
                    "type": "",
                    "defaultValue": "(role: Privileges): TrestleUser => {\n  return new TrestleUser({\n    username: 'test',\n    firstName: '',\n    lastName: '',\n    email: '',\n    password: '',\n    privileges: role\n  });\n}"
                }
            ],
            "src/main/webapp/src/app/explore/viewer/map.worker.ts": [
                {
                    "name": "ctx",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                    "type": "Worker",
                    "defaultValue": "self as any"
                }
            ],
            "src/test/e2e/step_definitions/login.steps.ts": [
                {
                    "name": "dashboard",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/login.steps.ts",
                    "type": "",
                    "defaultValue": "new DashboardPageObject()"
                },
                {
                    "name": "expect",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/login.steps.ts",
                    "type": "",
                    "defaultValue": "chai.expect"
                },
                {
                    "name": "login",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/login.steps.ts",
                    "type": "",
                    "defaultValue": "new LoginPageObject()"
                }
            ],
            "src/test/e2e/step_definitions/navigation.steps.ts": [
                {
                    "name": "dashboard",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/navigation.steps.ts",
                    "type": "",
                    "defaultValue": "new DashboardPageObject()"
                }
            ],
            "src/test/e2e/step_definitions/permission.steps.ts": [
                {
                    "name": "dashboard",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/permission.steps.ts",
                    "type": "",
                    "defaultValue": "new DashboardPageObject()"
                }
            ],
            "src/main/webapp/src/app/shared/dataset/dataset.service.ts": [
                {
                    "name": "DATASET_CACHE",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/shared/dataset/dataset.service.ts",
                    "type": "",
                    "defaultValue": "new InjectionToken<CacheService<string, string[]>>('dataset.cache')"
                }
            ],
            "src/main/webapp/src/app/shared/shared.config.ts": [
                {
                    "name": "DATASET_CACHE_DI_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/shared/shared.config.ts",
                    "type": "ICacheServiceConfig",
                    "defaultValue": "{\n  maxAge: 600000,\n  maxSize: 10\n}"
                }
            ],
            "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts": [
                {
                    "name": "Default",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                    "type": "",
                    "defaultValue": "() => ({\n  component: FactTableComponent,\n  props: {\n    facts: defaultFactData\n  }\n})"
                },
                {
                    "name": "defaultFactData",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                    "type": "[]",
                    "defaultValue": "[\n  fact1\n]"
                },
                {
                    "name": "fact1",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                    "type": "[]",
                    "defaultValue": "[\n  new TrestleFact({\n    identifier: 'http://test.id',\n    name: 'Test Fact',\n    type: 'String',\n    value: 'Test Fact Value',\n    databaseTemporal: {\n      ID: '',\n      From: new Date('1989-03-26'),\n      To: new Date('1990-05-11')\n    },\n    validTemporal: {\n      ID: '',\n      From: new Date('2020-01-01')\n    }\n  })\n]"
                }
            ],
            "src/main/webapp/src/environments/environment.prod.ts": [
                {
                    "name": "environment",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/environments/environment.prod.ts",
                    "type": "object",
                    "defaultValue": "{\n  production: true,\n  baseUrl: window.location.origin,\n  domain: \"localhost:8080\"\n}"
                }
            ],
            "src/main/webapp/src/environments/environment.ts": [
                {
                    "name": "environment",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/environments/environment.ts",
                    "type": "object",
                    "defaultValue": "{\n  production: false,\n  baseUrl: \"http://localhost:8080\",\n  domain: \"localhost:8080\"\n}"
                }
            ],
            "src/main/webapp/src/app/explore/explore.routing.ts": [
                {
                    "name": "ExploreRoutes",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/explore/explore.routing.ts",
                    "type": "ITrestleRoute[]",
                    "defaultValue": "[\n  {path: '', redirectTo: 'viewer', pathMatch: 'full'},\n  {\n    path: 'visualize', component: VisualizeComponent, canActivate: [LoggedInGuard],\n    children: [\n      {path: ':id', component: VisualizeDetailsComponent}\n\n    ]\n  },\n  {path: 'query', component: QueryComponent, canActivate: [LoggedInGuard]},\n  {path: 'viewer', component: ViewerComponent, canActivate: [LoggedInGuard]},\n  {path: 'compare', component: CompareComponent, canActivate: [LoggedInGuard]},\n  {path: 'aggregate', component: AggregateComponent, canActivate: [LoggedInGuard]}\n]"
                }
            ],
            "src/test/e2e/step_definitions/env.ts": [
                {
                    "name": "firstLoad",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/env.ts",
                    "type": "",
                    "defaultValue": "true"
                },
                {
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/env.ts",
                    "type": "",
                    "defaultValue": "require('cucumber')"
                }
            ],
            "src/main/webapp/src/app/shared/individual/individual.service.ts": [
                {
                    "name": "INDIVIDUAL_CACHE",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/shared/individual/individual.service.ts",
                    "type": "",
                    "defaultValue": "new InjectionToken<CacheService<string, TrestleIndividual>>('individual.cache')"
                }
            ],
            "src/stories/Button.stories.ts": [
                {
                    "name": "Large",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Primary",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Secondary",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Small",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Template",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "type": "Story<Button>",
                    "defaultValue": "(args: Button) => ({\n  component: Button,\n  props: args,\n})"
                }
            ],
            "src/main/webapp/src/app/reducers/storage.metareducer.ts": [
                {
                    "name": "localStorageKey",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                    "type": "string",
                    "defaultValue": "'__trestle__'"
                },
                {
                    "name": "stateKeys",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                    "type": "[]",
                    "defaultValue": "['user.user', 'user.userToken']"
                }
            ],
            "src/stories/Header.stories.ts": [
                {
                    "name": "LoggedIn",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Header.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "LoggedOut",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Header.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Template",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Header.stories.ts",
                    "type": "Story<Header>",
                    "defaultValue": "(args: Header) => ({\n  component: Header,\n  props: args,\n})"
                }
            ],
            "src/stories/Page.stories.ts": [
                {
                    "name": "LoggedIn",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Page.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "LoggedOut",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Page.stories.ts",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Template",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Page.stories.ts",
                    "type": "Story<Page>",
                    "defaultValue": "(args: Page) => ({\n  component: Page,\n  props: args,\n})"
                }
            ],
            "src/main/webapp/src/app/actions/auth.actions.ts": [
                {
                    "name": "login",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                    "type": "",
                    "defaultValue": "createAction(\n  '[Auth] Login',\n  props<{username: string, password: string, returnUrl: string}>()\n)"
                },
                {
                    "name": "loginFailure",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                    "type": "",
                    "defaultValue": "createAction(\n  '[Auth] Login Failure',\n  props<{ error: Error }>()\n)"
                },
                {
                    "name": "loginSuccess",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                    "type": "",
                    "defaultValue": "createAction(\n  '[Auth] Login Success',\n  props<{ user: TrestleUser, returnUrl: string, token: string }>()\n)"
                },
                {
                    "name": "logout",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/main/webapp/src/app/actions/auth.actions.ts",
                    "type": "",
                    "defaultValue": "createAction(\n  '[Auth] Logout'\n)"
                }
            ],
            "src/test/e2e/step_definitions/user.steps.ts": [
                {
                    "name": "userPage",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test/e2e/step_definitions/user.steps.ts",
                    "type": "",
                    "defaultValue": "new UsersPage()"
                }
            ]
        },
        "groupedFunctions": {
            "src/main/webapp/src/app/reducers/index.ts": [
                {
                    "name": "authReducer",
                    "file": "src/main/webapp/src/app/reducers/index.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "",
                    "args": [
                        {
                            "name": "state"
                        },
                        {
                            "name": "action",
                            "type": ""
                        }
                    ],
                    "returnType": "UserState",
                    "jsdoctags": [
                        {
                            "name": "state",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "action",
                            "type": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/main/webapp/src/app/reducers/storage.metareducer.ts": [
                {
                    "name": "getSavedState",
                    "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "",
                    "args": [
                        {
                            "name": "key"
                        }
                    ],
                    "returnType": "any",
                    "jsdoctags": [
                        {
                            "name": "key",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isSerializedUser",
                    "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "",
                    "args": [
                        {
                            "name": "value",
                            "type": "any"
                        }
                    ],
                    "returnType": "ITrestleUser",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setSavedState",
                    "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "",
                    "args": [
                        {
                            "name": "state",
                            "type": "any"
                        },
                        {
                            "name": "localStorageKey"
                        }
                    ],
                    "jsdoctags": [
                        {
                            "name": "state",
                            "type": "any",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "localStorageKey",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "storageMetaReducer",
                    "file": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "",
                    "args": [
                        {
                            "name": "reducer"
                        }
                    ],
                    "jsdoctags": [
                        {
                            "name": "reducer",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/main/webapp/src/app/explore/viewer/map.worker.ts": [
                {
                    "name": "isID",
                    "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "<p>Determines if a given {string} property name represents the object ID\nIt does so by peaking at the last 2 characters to see if their lowercase representation equals &#39;id&#39;</p>\n",
                    "args": [
                        {
                            "name": "x"
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1907,
                                "end": 1908,
                                "flags": 0,
                                "escapedText": "x"
                            },
                            "tagName": {
                                "pos": 1901,
                                "end": 1906,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>Property name</li>\n</ul>\n"
                        },
                        {
                            "tagName": {
                                "pos": 1929,
                                "end": 1936,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<p>is id</p>\n",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "isSpatial",
                    "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "<p>Crummy regex function to determine if a provided value is a WKT literal</p>\n",
                    "args": [
                        {
                            "name": "x",
                            "type": "any"
                        }
                    ],
                    "returnType": "wktType",
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 2301,
                                "end": 2302,
                                "flags": 0,
                                "escapedText": "x"
                            },
                            "type": "any",
                            "tagName": {
                                "pos": 2295,
                                "end": 2300,
                                "flags": 0,
                                "escapedText": "param"
                            },
                            "comment": "<ul>\n<li>any object at all</li>\n</ul>\n"
                        },
                        {
                            "tagName": {
                                "pos": 2327,
                                "end": 2334,
                                "flags": 0,
                                "escapedText": "returns"
                            },
                            "comment": "<p>is wkt</p>\n",
                            "returnType": "boolean"
                        }
                    ]
                },
                {
                    "name": "parseObjectToGeoJSON",
                    "file": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "",
                    "args": [
                        {
                            "name": "responseObject"
                        }
                    ],
                    "returnType": "FeatureCollection<GeometryObject>",
                    "jsdoctags": [
                        {
                            "name": "responseObject",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/main/webapp/src/app/app.module.ts": [
                {
                    "name": "jwtOptionsFactory",
                    "file": "src/main/webapp/src/app/app.module.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "description": "",
                    "args": [
                        {
                            "name": "store"
                        }
                    ],
                    "jsdoctags": [
                        {
                            "name": "store",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ]
        },
        "groupedEnumerations": {
            "src/main/webapp/src/app/explore/explore.config.ts": [
                {
                    "name": "COLOR_SCHEME",
                    "childs": [
                        {
                            "name": "CATEGORY_20B"
                        },
                        {
                            "name": "CATEGORY_20C"
                        },
                        {
                            "name": "CATEGORY_20"
                        },
                        {
                            "name": "CATEGORY_10"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "description": "",
                    "file": "src/main/webapp/src/app/explore/explore.config.ts"
                }
            ],
            "src/main/webapp/src/app/shared/color/color-service.config.ts": [
                {
                    "name": "COLOR_SCHEME",
                    "childs": [
                        {
                            "name": "CATEGORY_20B"
                        },
                        {
                            "name": "CATEGORY_20C"
                        },
                        {
                            "name": "CATEGORY_20"
                        },
                        {
                            "name": "CATEGORY_10"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "description": "",
                    "file": "src/main/webapp/src/app/shared/color/color-service.config.ts"
                }
            ],
            "src/main/webapp/src/app/explore/viewer/viewer.component.ts": [
                {
                    "name": "DatasetState",
                    "childs": [
                        {
                            "name": "UNLOADED"
                        },
                        {
                            "name": "LOADING"
                        },
                        {
                            "name": "LOADED"
                        },
                        {
                            "name": "ERROR"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "description": "",
                    "file": "src/main/webapp/src/app/explore/viewer/viewer.component.ts"
                }
            ],
            "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts": [
                {
                    "name": "NodeType",
                    "childs": [
                        {
                            "name": "INDIVIDUAL"
                        },
                        {
                            "name": "VTEMPORAL"
                        },
                        {
                            "name": "FACT"
                        },
                        {
                            "name": "RELATION"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "description": "",
                    "file": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts"
                }
            ],
            "src/main/webapp/src/app/user/trestle-user.ts": [
                {
                    "name": "Privileges",
                    "childs": [
                        {
                            "name": "USER",
                            "value": "1"
                        },
                        {
                            "name": "ADMIN",
                            "value": "2"
                        },
                        {
                            "name": "DBA",
                            "value": "4"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "description": "",
                    "file": "src/main/webapp/src/app/user/trestle-user.ts"
                }
            ],
            "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-event.ts": [
                {
                    "name": "TrestleEventType",
                    "childs": [
                        {
                            "name": "CREATED"
                        },
                        {
                            "name": "DESTROYED"
                        },
                        {
                            "name": "BECAME"
                        },
                        {
                            "name": "SPLIT"
                        },
                        {
                            "name": "MERGED"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "description": "",
                    "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-event.ts"
                }
            ],
            "src/main/webapp/src/app/admin/users/users.dialog.component.ts": [
                {
                    "name": "UserDialogResponseType",
                    "childs": [
                        {
                            "name": "ADD"
                        },
                        {
                            "name": "DELETE"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "description": "",
                    "file": "src/main/webapp/src/app/admin/users/users.dialog.component.ts"
                }
            ]
        },
        "groupedTypeAliases": {
            "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts": [
                {
                    "name": "AggregationOperation",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"EQ\" | \"NEQ\" | \"GT\" | \"GTEQ\" | \"LT\" | \"LTEQ\"",
                    "file": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                    "description": "",
                    "kind": 168
                }
            ],
            "src/main/webapp/src/app/explore/compare/compare.component.ts": [
                {
                    "name": "loadingColor",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"accent\" | \"warn\" | \"primary\"",
                    "file": "src/main/webapp/src/app/explore/compare/compare.component.ts",
                    "description": "",
                    "kind": 168
                },
                {
                    "name": "loadingState",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"determinate\" | \"indeterminate\"",
                    "file": "src/main/webapp/src/app/explore/compare/compare.component.ts",
                    "description": "",
                    "kind": 168
                }
            ],
            "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts": [
                {
                    "name": "MapBoxSource",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "GeoJSONSource | VectorSource | RasterSource | ImageSource | VideoSource | GeoJSONSourceRaw",
                    "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                    "description": "",
                    "kind": 168
                },
                {
                    "name": "MapEvent",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"mousemove\" | \"mouseleave\" | \"click\" | \"moveend\"",
                    "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                    "description": "",
                    "kind": 168
                },
                {
                    "name": "MapSource",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "I3DMapSource | ITrestleMapSource",
                    "file": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                    "description": "",
                    "kind": 168
                }
            ],
            "src/test/e2e/page_objects/main.page.ts": [
                {
                    "name": "PageActionType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"admin\" | \"dba\"",
                    "file": "src/test/e2e/page_objects/main.page.ts",
                    "description": "",
                    "kind": 168
                }
            ],
            "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-relation.ts": [
                {
                    "name": "TrestleRelationType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"CONTAINS\" | \"COVERS\" | \"DISJOINT\" | \"EQUALS\" | \"INSIDE\" | \"MEETS\" | \"SPATIAL_OVERLAPS\" | \"AFTER\" | \"BEFORE\" | \"BEGINS\" | \"DURING\" | \"ENDS\" | \"TEMPORAL_OVERLAPS\" | \"SPLIT_INTO\" | \"SPLIT_FROM\" | \"MERGED_INTO\" | \"MERGED_FROM\" | \"COMPONENT_WITH\"",
                    "file": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-relation.ts",
                    "description": "",
                    "kind": 168
                }
            ],
            "src/test/e2e/page_objects/user.details.modal.ts": [
                {
                    "name": "UserType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"user\" | \"admin\" | \"dba\"",
                    "file": "src/test/e2e/page_objects/user.details.modal.ts",
                    "description": "",
                    "kind": 168
                }
            ],
            "src/main/webapp/src/app/explore/viewer/map.service.ts": [
                {
                    "name": "wktType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"POINT\" | \"MULTIPOINT\" | \"LINESTRING\" | \"MULTILINESTRING\" | \"POLYGON\" | \"MULTIPOLYGON\"",
                    "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                    "description": "",
                    "kind": 168
                },
                {
                    "name": "wktValue",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "LngLatBounds | GeometryObject",
                    "file": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                    "description": "",
                    "kind": 168
                }
            ]
        }
    },
    "routes": {
        "name": "<root>",
        "kind": "module",
        "className": "AppModule",
        "children": [
            {
                "name": "routes",
                "filename": "src/main/webapp/src/app/app-routing.module.ts",
                "module": "AppRoutingModule",
                "children": [
                    {
                        "path": "",
                        "canActivate": [
                            "DefaultRouteGuard"
                        ],
                        "component": "NavigationComponent"
                    },
                    {
                        "path": "login",
                        "component": "LoginComponent"
                    },
                    {
                        "path": "admin",
                        "loadChildren": "./admin/admin.module#AdminModule",
                        "children": [
                            {
                                "kind": "module",
                                "children": [],
                                "module": "AdminModule"
                            }
                        ]
                    },
                    {
                        "path": "explore",
                        "loadChildren": "./explore/explore.module#ExploreModule",
                        "children": [
                            {
                                "kind": "module",
                                "children": [],
                                "module": "ExploreModule"
                            }
                        ]
                    }
                ],
                "kind": "module"
            }
        ]
    },
    "coverage": {
        "count": 6,
        "status": "low",
        "files": [
            {
                "filePath": "jest/jest.stubs.ts",
                "type": "class",
                "linktype": "classe",
                "name": "Worker",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "login",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "loginFailure",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "loginSuccess",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/actions/auth.actions.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "logout",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/admin.routing.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "AdminRoutes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/admin/admin.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AdminComponent",
                "coveragePercent": 33,
                "coverageCount": "3/9",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/dashboard/dashboard.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "DashboardComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/index-table/index-table.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "IndexTableComponent",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/index.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "IndexComponent",
                "coveragePercent": 18,
                "coverageCount": "2/11",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/index.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "IndexService",
                "coveragePercent": 50,
                "coverageCount": "3/6",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/index.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ICacheStatistics",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/index.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IIndexLeafStatistics",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/tree-graph/tree-graph.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TreeGraphComponent",
                "coveragePercent": 4,
                "coverageCount": "1/24",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/tree-graph/tree-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IGraphHeader",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/indicies/warning-dialog/warning-dialog-component.ts",
                "type": "component",
                "linktype": "component",
                "name": "WarningDialogComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/metrics-graph/metrics-graph.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MetricsGraphComponent",
                "coveragePercent": 4,
                "coverageCount": "1/21",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/metrics-graph/metrics-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ID3Margin",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "MetricsService",
                "coveragePercent": 50,
                "coverageCount": "3/6",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMetricsData",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMetricsValue",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/metrics-graph/metrics.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleMetricsHeader",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/metrics/metrics.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MetricsComponent",
                "coveragePercent": 16,
                "coverageCount": "3/18",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/users/users.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "UsersComponent",
                "coveragePercent": 20,
                "coverageCount": "3/15",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/users/users.dialog.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "UserDialogComponent",
                "coveragePercent": 28,
                "coverageCount": "6/21",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/admin/users/users.dialog.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IUserDialogResponse",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/app.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AppComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/app.module.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "jwtOptionsFactory",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/effects/auth.effects.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "AuthEffects",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/aggregate/aggregate.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AggregateComponent",
                "coveragePercent": 0,
                "coverageCount": "0/22",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "AggregationService",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IAggregationRequest",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IAggregationRestriction",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IAggregationStrategy",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/aggregate/aggregation.service.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "BBOX_PROPERTY",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/compare/compare.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CompareComponent",
                "coveragePercent": 42,
                "coverageCount": "16/38",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/compare/compare.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ICompareIndividual",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/compare/compare.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ILoadingState",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/explore.config.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IColorServiceConfig",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/explore.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "COLOR_DI_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/explore.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "COLOR_SERVICE_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/explore.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "INDIVIDUAL_CACHE_DI_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/explore.routing.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "ExploreRoutes",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/exporter/exporter.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ExporterComponent",
                "coveragePercent": 11,
                "coverageCount": "1/9",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/exporter/exporter.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IDataExport",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/exporter/exporter.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ExporterService",
                "coveragePercent": 33,
                "coverageCount": "1/3",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/exporter/exporter.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IExportRequest",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/query/codemirror/codemirror.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CodeMirrorComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/query/query-viewer/query-viewer.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "QueryViewerComponent",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/query/query.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "QueryComponent",
                "coveragePercent": 12,
                "coverageCount": "1/8",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/query/query.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "QueryService",
                "coveragePercent": 40,
                "coverageCount": "2/5",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/query/query.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleResult",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/query/query.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleResultSet",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "MapService",
                "coveragePercent": 33,
                "coverageCount": "4/12",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ICompareBody",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IComparisonReport",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IContributionPart",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IContributionReport",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IIntersectionBody",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMapWorkerRequest",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMapWorkerResponse",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ISpatialComparisonReport",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "isID",
                "coveragePercent": 100,
                "coverageCount": "1/1",
                "status": "very-good"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "isSpatial",
                "coveragePercent": 100,
                "coverageCount": "1/1",
                "status": "very-good"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "parseObjectToGeoJSON",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/map.worker.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "ctx",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/viewer.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ViewerComponent",
                "coveragePercent": 25,
                "coverageCount": "5/20",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/viewer/viewer.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IDatasetState",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "IndividualGraphComponent",
                "coveragePercent": 0,
                "coverageCount": "0/34",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ID3Margin",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IFactNode",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IGraphLayout",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/individual-graph/individual-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IIndividualConfig",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/individual-value.dialog.ts",
                "type": "component",
                "linktype": "component",
                "name": "IndividualValueDialog",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "FactTableComponent",
                "coveragePercent": 9,
                "coverageCount": "1/11",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Default",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "defaultFactData",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/visualize-details/fact-table/fact-table.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "fact1",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/visualize-details/visualize-details.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "VisualizeDetailsComponent",
                "coveragePercent": 17,
                "coverageCount": "3/17",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/visualize-details/visualize-details.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IRouteObservable",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/explore/visualize/visualize.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "VisualizeComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/login/login.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "LoginComponent",
                "coveragePercent": 9,
                "coverageCount": "1/11",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/login/login.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IUserLogin",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/navigation.module.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleRoute",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/navigation.module.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleRouteData",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/navigation/navigation.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "NavigationComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/sidebar/sidebar.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SidebarComponent",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/top-nav/top-nav.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TopNavComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/navigation/user-icon/user-icon.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "UserIconComponent",
                "coveragePercent": 11,
                "coverageCount": "1/9",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "State",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "UserState",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "authReducer",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "_authReducer",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "initialUserState",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "metaReducers",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "reducers",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "selectErrorFromUser",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "selectTokenFromUser",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "selectUser",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "selectUserFromUser",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/index.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "selectUserState",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "getSavedState",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "isSerializedUser",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "setSavedState",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "function",
                "linksubtype": "function",
                "name": "storageMetaReducer",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "localStorageKey",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/reducers/storage.metareducer.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "stateKeys",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/cache/cache.service.config.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ICacheServiceConfig",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/cache/cache.service.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "CACHE_SERVICE_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/cache/cache.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "CacheService",
                "coveragePercent": 50,
                "coverageCount": "4/8",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/color/color-service.config.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IColorServiceConfig",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/color/color-service.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "COLOR_SERVICE_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/color/color.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ColorService",
                "coveragePercent": 37,
                "coverageCount": "3/8",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/dataset/dataset.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "DatasetService",
                "coveragePercent": 33,
                "coverageCount": "3/9",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/dataset/dataset.service.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "DATASET_CACHE",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-event.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TrestleEvent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-event.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleEvent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-fact.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TrestleFact",
                "coveragePercent": 5,
                "coverageCount": "1/17",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-fact.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleFact",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-individual.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TrestleIndividual",
                "coveragePercent": 65,
                "coverageCount": "23/35",
                "status": "good"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-individual.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleIndividual",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-relation.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TrestleRelation",
                "coveragePercent": 10,
                "coverageCount": "1/10",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-relation.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleRelation",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-temporal.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TrestleTemporal",
                "coveragePercent": 7,
                "coverageCount": "1/13",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/TrestleIndividual/trestle-temporal.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleTemporal",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/individual.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "IndividualService",
                "coveragePercent": 33,
                "coverageCount": "2/6",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/individual/individual.service.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "INDIVIDUAL_CACHE",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/interfacable.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IInterfacable",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/pipes/array-sort.pipe.ts",
                "type": "pipe",
                "linktype": "pipe",
                "name": "ArraySortPipe",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/pipes/map-values.pipe.ts",
                "type": "pipe",
                "linktype": "pipe",
                "name": "MapValuesPipe",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/pipes/rounding-pipe.pipe.ts",
                "type": "pipe",
                "linktype": "pipe",
                "name": "RoundingPipe",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/shared/shared.config.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "DATASET_CACHE_DI_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/common.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ID3Margin",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "EventGraphComponent",
                "coveragePercent": 4,
                "coverageCount": "1/23",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IEventData",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IEventElement",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/event-graph/event-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IEventLink",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/history-graph/history-graph.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HistoryGraphComponent",
                "coveragePercent": 0,
                "coverageCount": "0/22",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/history-graph/history-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IIndividualHistory",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/history-graph/history-graph.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITemporalEntity",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/loading-spinner/loading-spinner.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "LoadingSpinnerComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/loading-spinner/loading-spinner.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "LoadingSpinnerService",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/search/search.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SearchComponent",
                "coveragePercent": 20,
                "coverageCount": "2/10",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/spatial-union/spatial-union.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SpatialUnionComponent",
                "coveragePercent": 25,
                "coverageCount": "3/12",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TrestleMapComponent",
                "coveragePercent": 21,
                "coverageCount": "9/42",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "GeoJSONDataSource",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "I3DMapSource",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMapAttributeChange",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMapEventHandler",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMapFillLayer",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMapHoverLayer",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IMapLineLayer",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleMapLayers",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/ui/trestle-map/trestle-map.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleMapSource",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/user/DefaultRouteGuard.ts",
                "type": "guard",
                "linktype": "guard",
                "name": "DefaultRouteGuard",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/user/LoggedInGuard.ts",
                "type": "guard",
                "linktype": "guard",
                "name": "LoggedInGuard",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/user/authentication.service.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TrestleToken",
                "coveragePercent": 37,
                "coverageCount": "3/8",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/user/authentication.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "AuthService",
                "coveragePercent": 46,
                "coverageCount": "6/13",
                "status": "medium"
            },
            {
                "filePath": "src/main/webapp/src/app/user/authentication.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ITrestleUser",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/user/authentication.service.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "_key",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/user/permissions.guard.ts",
                "type": "guard",
                "linktype": "guard",
                "name": "PermissionsGuard",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/user/trestle-user.ts",
                "type": "class",
                "linktype": "classe",
                "name": "TrestleUser",
                "coveragePercent": 15,
                "coverageCount": "2/13",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/app/user/users.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "UserService",
                "coveragePercent": 57,
                "coverageCount": "4/7",
                "status": "good"
            },
            {
                "filePath": "src/main/webapp/src/environments/environment.prod.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "environment",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/environments/environment.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "environment",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/main/webapp/src/test.helpers.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "createMockUser",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Large",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Primary",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Secondary",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Small",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Template",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Header.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedIn",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Header.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedOut",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Header.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Template",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Page.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedIn",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Page.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedOut",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Page.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Template",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/button.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ButtonComponent",
                "coveragePercent": 83,
                "coverageCount": "5/6",
                "status": "very-good"
            },
            {
                "filePath": "src/stories/header.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HeaderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/stories/page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/page_objects/login.page.ts",
                "type": "class",
                "linktype": "classe",
                "name": "LoginPageObject",
                "coveragePercent": 40,
                "coverageCount": "4/10",
                "status": "medium"
            },
            {
                "filePath": "src/test/e2e/page_objects/main.page.ts",
                "type": "class",
                "linktype": "classe",
                "name": "DashboardPageObject",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/page_objects/user.details.modal.ts",
                "type": "class",
                "linktype": "classe",
                "name": "UserDetailsModal",
                "coveragePercent": 30,
                "coverageCount": "4/13",
                "status": "medium"
            },
            {
                "filePath": "src/test/e2e/page_objects/user.details.modal.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IUserTable",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/page_objects/users.page.ts",
                "type": "class",
                "linktype": "classe",
                "name": "UsersPage",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/env.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "firstLoad",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/env.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/login.steps.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "dashboard",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/login.steps.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "expect",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/login.steps.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "login",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/navigation.steps.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "dashboard",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/permission.steps.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "dashboard",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/user.steps.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CucumberTable",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/test/e2e/step_definitions/user.steps.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "userPage",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            }
        ]
    }
}